<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Animancer.Lite</name>
    </assembly>
    <members>
        <member name="T:Animancer.AnimancerUtilities">
            <summary>Various extension methods and utilities.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Wrap01(System.Single)">
            <summary>[Animancer Extension] Loops the `value` so that <c>0 &lt;= value &lt; 1</c>.</summary>
            <remarks>This is more efficient than using <see cref="M:UnityEngine.Mathf.Repeat(System.Single,System.Single)"/> with a length of 1.</remarks>
        </member>
        <member name="M:Animancer.AnimancerUtilities.AddAnimancerComponent``1(UnityEngine.Animator)">
            <summary>[Animancer Extension]
            Adds the specified type of <see cref="T:Animancer.IAnimancerComponent"/>, links it to the `animator`, and returns it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GetOrAddAnimancerComponent``1(UnityEngine.Animator)">
            <summary>[Animancer Extension]
            Returns the <see cref="T:Animancer.IAnimancerComponent"/> on the same <see cref="T:UnityEngine.GameObject"/> as the `animator` if
            there is one. Otherwise this method adds a new one and returns it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.HasEvent(Animancer.IAnimationClipCollection,System.String)">
            <summary>
            Checks if any <see cref="T:UnityEngine.AnimationClip"/> in the `source` has an animation event with the specified
            `functionName`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.HasEvent(UnityEngine.AnimationClip,System.String)">
            <summary>Checks if the `clip` has an animation event with the specified `functionName`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.CalculateThresholdsFromAverageVelocityXZ(Animancer.MixerState{UnityEngine.Vector2})">
            <summary>[Pro-Only]
            Calculates all thresholds using the <see cref="P:Animancer.AnimancerState.AverageVelocity"/> of each state.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.SetDirty(UnityEngine.Object)">
            <summary>[Editor-Conditional] Marks the `target` as dirty.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.IfMultiComponentThenChangeType``1(``0)">
            <summary>[Editor-Conditional]
            If there are multiple components which inherit from <typeparamref name="T"/>, the first one is changed to
            the type of the second and any after the first are destroyed. This allows you to change the type without
            losing the values of any serialized fields they share.
            <para></para>
            The `currentComponent` is used to determine which <see cref="T:UnityEngine.GameObject"/> to examine and the base
            component type <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.EditModePlay(Animancer.IAnimancerComponent,UnityEngine.AnimationClip,System.Boolean)">
            <summary>[Editor-Conditional]
            Plays the specified `clip` if called in Edit Mode and optionally pauses it immediately.
            </summary>
            <remarks>
            Before Unity 2018.3, playing animations in Edit Mode didn't work properly.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)">
            <summary>[Animancer Extension]
            Adds the `clip` to the `clips` if it wasn't there already.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Collections.Generic.IList{UnityEngine.AnimationClip})">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)"/> for each of the `newClips`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Collections.Generic.IEnumerable{UnityEngine.AnimationClip})">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)"/> for each of the `newClips`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GatherFromAsset(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.Playables.PlayableAsset)">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)"/> for each clip in the `asset`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GatherAnimationClips(System.Collections.IEnumerable,System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>Gathers all the animations in the `tracks`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GatherFromSource(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},Animancer.IAnimationClipSource)">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)"/> for each clip gathered by
            <see cref="!:IAnimationClipSource.GetAnimationClips"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GatherFromSource(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Object)">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)"/> for each clip in the `source`,
            supporting both <see cref="T:Animancer.IAnimationClipSource"/> and <see cref="T:Animancer.IAnimationClipCollection"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GatherFromSources(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Collections.IList)">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.GatherFromSource(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Object)"/> for each of the `sources`.
            </summary>
        </member>
        <member name="T:Animancer.FastComparer">
            <summary>
            An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> which ignores overloaded equality operators so it's faster than
            <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/> for types derived from <see cref="T:UnityEngine.Object"/>.
            </summary>
        </member>
        <member name="F:Animancer.FastComparer.Instance">
            <summary>Singleton instance.</summary>
        </member>
        <member name="M:Animancer.FastComparer.System#Collections#Generic#IEqualityComparer{System#Object}#Equals(System.Object,System.Object)">
            <summary>Calls <see cref="M:System.Object.Equals(System.Object,System.Object)"/>.</summary>
            <remarks>
            We could use <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> for slightly better performance, but that would not work
            for boxed value types (enums in particular).
            </remarks>
        </member>
        <member name="M:Animancer.FastComparer.System#Collections#Generic#IEqualityComparer{System#Object}#GetHashCode(System.Object)">
            <summary>Calls <see cref="M:System.Object.GetHashCode"/>.</summary>
        </member>
        <member name="T:Animancer.IKeyHolder">
            <summary>
            An object with a <see cref="T:Animancer.Key"/> so it can be used in a <see cref="T:Animancer.Key.KeyedList`1"/>.
            </summary>
        </member>
        <member name="P:Animancer.IKeyHolder.Key">
            <summary>The <see cref="T:Animancer.Key"/> which stores the list index of this object.</summary>
        </member>
        <member name="T:Animancer.Key">
            <summary>
            Stores the index of an object in a <see cref="T:Animancer.Key.KeyedList`1"/> to allow it to be efficiently removed.
            </summary>
        </member>
        <member name="M:Animancer.Key.IndexOf(Animancer.Key)">
            <summary>Returns location of this object in the list (or -1 if it isn't currently in a keyed list).</summary>
        </member>
        <member name="M:Animancer.Key.IsInList(Animancer.Key)">
            <summary>Indicates whether the specified object is currently in a keyed list.</summary>
        </member>
        <member name="P:Animancer.Key.Animancer#IKeyHolder#Key">
            <summary>A <see cref="T:Animancer.Key"/> is its own <see cref="T:Animancer.Key"/>.</summary>
        </member>
        <member name="T:Animancer.Key.KeyedList`1">
             <summary>
             A <see cref="T:System.Collections.Generic.List`1"/> which can remove items without needing to search through the entire collection.
             Does not allow nulls to be added.
             </summary>
            
             <example>
             To use an object in a Keyed List, it must either inherit from <see cref="T:Animancer.Key"/> or implement
             <see cref="T:Animancer.IKeyHolder"/> like so:
             <code>
             class MyClass : IKeyHolder
             {
                 private readonly Key Key = new Key();
                 Key IKeyHolder.Key { get { return Key; } }
             }
             </code>
             Note that the <c>Key</c> field can be made <c>public</c> if desired.
             </example>
            
             <remarks>
             This class is nested inside <see cref="T:Animancer.Key"/> so it can modify the private <see cref="F:Animancer.Key._Index"/> without
             exposing that capability to anything else.
             </remarks>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.#ctor">
            <summary>Creates a new <see cref="T:Animancer.Key.KeyedList`1"/> using the default <see cref="T:System.Collections.Generic.List`1"/> constructor.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.#ctor(System.Int32)">
            <summary>Creates a new <see cref="T:Animancer.Key.KeyedList`1"/> with the specified initial `capacity`.</summary>
        </member>
        <member name="P:Animancer.Key.KeyedList`1.Count">
            <summary>The number of items currently in the list.</summary>
        </member>
        <member name="P:Animancer.Key.KeyedList`1.Capacity">
            <summary>The number of items that this list can contain before resizing is required.</summary>
        </member>
        <member name="P:Animancer.Key.KeyedList`1.Item(System.Int32)">
            <summary>Gets or sets the item at the specified `index`.</summary>
            <exception cref="T:System.ArgumentException">Thrown by the setter if the `value` was already in a keyed list.</exception>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.Add(`0)">
            <summary>Adds the `item` to the end of this list.</summary>
            <exception cref="T:System.ArgumentException">Thrown if the `item` was already in a keyed list.</exception>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.AddNew(`0)">
            <summary>Adds the `item` to the end of this list if it wasn't already in one.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.RemoveAt(System.Int32)">
            <summary>Removes the item at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.RemoveAtSwap(System.Int32)">
            <summary>
            Removes the item at the specified `index` by swapping the last item in this list into its place.
            <para></para>
            This does not maintain the order of items, but is more efficient than <see cref="M:Animancer.Key.KeyedList`1.RemoveAt(System.Int32)"/> because
            it avoids the need to move every item after the removed one down one place.
            </summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.Remove(`0)">
            <summary>Removes the `item` from this list.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.RemoveSwap(`0)">
            <summary>
            Removes the `item` by swapping the last item in this list into its place.
            <para></para>
            This does not maintain the order of items, but is more efficient than <see cref="M:Animancer.Key.KeyedList`1.Remove(`0)"/> because
            it avoids the need to move every item after the removed one down one place.
            </summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.Clear">
            <summary>Removes all items from this list.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.Contains(`0)">
            <summary>Indicates whether the `item` is currently in this list.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.IndexOf(`0)">
            <summary>Returns the index of the `item` in this list or -1 if it is not in this list.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.Insert(System.Int32,`0)">
            <summary>Adds the `item` to this list at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.CopyTo(`0[],System.Int32)">
            <summary>Copies all the items from this list into the `array`, starting at the specified `arrayIndex`.</summary>
        </member>
        <member name="P:Animancer.Key.KeyedList`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>Returns false.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.GetEnumerator">
            <summary>Returns an enumerator that iterates through this list.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through this list.</summary>
        </member>
        <member name="T:Animancer.ObjectPool">
            <summary>Convenience methods for accessing <see cref="T:Animancer.ObjectPool`1"/>.</summary>
        </member>
        <member name="M:Animancer.ObjectPool.Acquire``1">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Acquire"/> to get a spare item if there are any, or create a new one.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.Acquire``1(``0@)">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Acquire"/> to get a spare item if there are any, or create a new one.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.Release``1(``0)">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Release(`0)"/> to add the `item` to the list of spares so it can be reused.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.Release``1(``0@)">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Release(`0)"/> to add the `item` to the list of spares so it can be reused.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.AcquireList``1">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Acquire"/> to get a spare <see cref="T:System.Collections.Generic.List`1"/> if
            there are any or create a new one.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.Release``1(System.Collections.Generic.List{``0})">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Release(`0)"/> to clear the `list` and mark it as a spare
            so it can be later returned by <see cref="M:Animancer.ObjectPool.AcquireList``1"/>.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.AcquireSet``1">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Acquire"/> to get a spare <see cref="T:System.Collections.Generic.HashSet`1"/> if
            there are any or create a new one.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.Release``1(System.Collections.Generic.HashSet{``0})">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Release(`0)"/> to clear the `set` and mark it as a spare
            so it can be later returned by <see cref="M:Animancer.ObjectPool.AcquireSet``1"/>.
            </summary>
        </member>
        <member name="T:Animancer.ObjectPool`1">
            <summary>A simple object pooling system.</summary>
        </member>
        <member name="P:Animancer.ObjectPool`1.Count">
            <summary>The number of spare items currently in the pool.</summary>
        </member>
        <member name="P:Animancer.ObjectPool`1.Capacity">
            <summary>The <see cref="P:System.Collections.Generic.List`1.Capacity"/> of the internal list of spare items.</summary>
        </member>
        <member name="M:Animancer.ObjectPool`1.Acquire">
            <summary>Returns a spare item if there are any, or creates a new one.</summary>
        </member>
        <member name="M:Animancer.ObjectPool`1.Release(`0)">
            <summary>Adds the `item` to the list of spares so it can be reused.</summary>
        </member>
        <member name="T:Animancer.ControllerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which plays a <see cref="T:UnityEngine.RuntimeAnimatorController"/>.
            You can control this state very similarly to an <see cref="T:UnityEngine.Animator"/> via its <see cref="P:Animancer.ControllerState.Playable"/> field.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Controller">
            <summary>The <see cref="T:UnityEngine.RuntimeAnimatorController"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ControllerState.MainObject">
            <summary>The <see cref="T:UnityEngine.RuntimeAnimatorController"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ControllerState.Playable">
            <summary>The internal system which plays the <see cref="T:UnityEngine.RuntimeAnimatorController"/>.</summary>
        </member>
        <member name="P:Animancer.ControllerState.KeepStateOnStop">
            <summary>
            If false, <see cref="M:Animancer.ControllerState.Stop"/> will reset all layers to their default state. Default False.
            <para></para>
            If you set this value to false after the constructor, you must assign the <see cref="P:Animancer.ControllerState.DefaultStateHashes"/>
            or call <see cref="M:Animancer.ControllerState.GatherDefaultStates"/> yourself.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.DefaultStateHashes">
            <summary>
            The <see cref="P:UnityEngine.AnimatorStateInfo.shortNameHash"/> of the default state on each layer, used to reset to
            those states when <see cref="M:Animancer.ControllerState.Stop"/> is called.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.#ctor(Animancer.AnimancerPlayable,UnityEngine.RuntimeAnimatorController,System.Boolean)">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState"/> to play the `animatorController` without connecting
            it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.#ctor(Animancer.AnimancerLayer,UnityEngine.RuntimeAnimatorController,System.Boolean)">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState"/> to play the `animatorController` and connects it to
            the `layer`.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.#ctor(Animancer.AnimancerNode,System.Int32,UnityEngine.RuntimeAnimatorController,System.Boolean)">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState"/> to play the `animatorController` and
            connects it to the `parent` at the specified `index`.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.StateInfo">
            <summary>
            The current state on layer 0, or the next state if it is currently in a transition.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.NewTime">
            <summary>
            The <see cref="P:UnityEngine.AnimatorStateInfo.normalizedTime"/> * <see cref="P:UnityEngine.AnimatorStateInfo.length"/> of the
            <see cref="P:Animancer.ControllerState.StateInfo"/>
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Length">
            <summary>The current <see cref="P:UnityEngine.AnimatorStateInfo.length"/> (on layer 0).</summary>
        </member>
        <member name="P:Animancer.ControllerState.IsLooping">
            <summary>
            Indicates whether the current state on layer 0 will loop back to the start when it reaches the end.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.GatherDefaultStates">
            <summary>
            Gathers the <see cref="P:Animancer.ControllerState.DefaultStateHashes"/> from the current states.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Stop">
            <summary>
            Calls the base <see cref="M:Animancer.AnimancerState.Stop"/> and if <see cref="P:Animancer.ControllerState.KeepStateOnStop"/> is false it also
            calls <see cref="M:Animancer.ControllerState.ResetToDefaultStates"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.ResetToDefaultStates">
            <summary>
            Resets all layers to their default state.
            </summary>
            <exception cref="T:System.NullReferenceException">Thrown if <see cref="P:Animancer.ControllerState.DefaultStateHashes"/> is null.</exception>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown if the size of <see cref="P:Animancer.ControllerState.DefaultStateHashes"/> is larger than the number of layers in the
            <see cref="P:Animancer.ControllerState.Controller"/>.
            </exception>
        </member>
        <member name="M:Animancer.ControllerState.ToString">
            <summary>
            Returns a string describing the type of this state and the name of the <see cref="P:Animancer.ControllerState.Controller"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>]
            Gathers all the animations in this state.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Destroy">
            <summary>Destroys the <see cref="P:Animancer.ControllerState.Playable"/>.</summary>
        </member>
        <member name="T:Animancer.ControllerState.Parameter">
            <summary>
            A wrapper for the name and hash of an <see cref="T:UnityEngine.AnimatorControllerParameter"/> to allow easy access.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Parameter.Name">
            <summary>
            The name of the wrapped parameter. This will be null if the <see cref="P:Animancer.ControllerState.Parameter.Hash"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Parameter.Hash">
            <summary>
            The name hash of the wrapped parameter.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.#ctor(System.String)">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState.Parameter"/> with the specified <see cref="P:Animancer.ControllerState.Parameter.Name"/> and uses
            <see cref="M:UnityEngine.Animator.StringToHash(System.String)"/> to calculate the <see cref="P:Animancer.ControllerState.Parameter.Hash"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.#ctor(System.Int32)">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState.Parameter"/> with the specified <see cref="P:Animancer.ControllerState.Parameter.Hash"/> and leaves the
            <see cref="P:Animancer.ControllerState.Parameter.Name"/> null.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.op_Implicit(System.String)~Animancer.ControllerState.Parameter">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState.Parameter"/> with the specified <see cref="P:Animancer.ControllerState.Parameter.Name"/> and uses
            <see cref="M:UnityEngine.Animator.StringToHash(System.String)"/> to calculate the <see cref="P:Animancer.ControllerState.Parameter.Hash"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.op_Implicit(System.Int32)~Animancer.ControllerState.Parameter">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState.Parameter"/> with the specified <see cref="P:Animancer.ControllerState.Parameter.Hash"/> and leaves the
            <see cref="P:Animancer.ControllerState.Parameter.Name"/> null.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.op_Implicit(Animancer.ControllerState.Parameter)~System.Int32">
            <summary>Returns the <see cref="P:Animancer.ControllerState.Parameter.Hash"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.ValidateHasParameter(UnityEngine.RuntimeAnimatorController,UnityEngine.AnimatorControllerParameterType)">
            <summary>[Editor-Conditional]
            Throws if the `controller` doesn't have a parameter with the specified <see cref="P:Animancer.ControllerState.Parameter.Hash"/>
            and `type`.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.ToString">
            <summary>Returns a string containing the <see cref="P:Animancer.ControllerState.Parameter.Name"/> and <see cref="P:Animancer.ControllerState.Parameter.Hash"/>.</summary>
        </member>
        <member name="P:Animancer.ControllerState.ParameterCount">
            <summary>The number of parameters being wrapped by this state.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetParameterHash(System.Int32)">
            <summary>Returns the hash of a parameter being wrapped by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't wrap any parameters.</exception>
        </member>
        <member name="M:Animancer.ControllerState.GetDrawer">
            <summary>[Editor-Only] Returns a <see cref="T:Animancer.ControllerState.Drawer"/> for this state.</summary>
        </member>
        <member name="T:Animancer.ControllerState.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.ControllerState"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.#ctor(Animancer.ControllerState)">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState.Drawer"/> to manage the Inspector GUI for the `state`.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.DoDetailsGUI(Animancer.IAnimancerComponent)">
            <summary> Draws the details of the target state in the GUI.</summary>
        </member>
        <member name="P:Animancer.ControllerState.Drawer.ParameterCount">
            <summary>The number of parameters being managed by the target state.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if the target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if the target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if the target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if the target state doesn't manage any parameters.</exception>
        </member>
        <member name="T:Animancer.ControllerState.Transition`1">
            <summary>
            Base class for serializable <see cref="T:Animancer.IAnimancerTransition"/>s which can create a particular type of
            <see cref="T:Animancer.ControllerState"/> when passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            <para></para>
            Even though it has the <see cref="T:System.SerializableAttribute"/>, this class won't actually get serialized
            by Unity because it's generic and abstract. Each child class still needs to include the attribute.
            </remarks>
        </member>
        <member name="P:Animancer.ControllerState.Transition`1.Controller">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.ControllerState.Controller"/> that will be used for the created state.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Transition`1.KeepStateOnStop">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            If false, <see cref="M:Animancer.ControllerState.Stop"/> will reset all layers to their default state.
            <para></para>
            If you set this value to false after the constructor, you must assign the <see cref="P:Animancer.ControllerState.DefaultStateHashes"/>
            or call <see cref="M:Animancer.ControllerState.GatherDefaultStates"/> yourself.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Transition`1.MaximumDuration">
            <summary>[<see cref="T:Animancer.IAnimancerTransitionDetailed"/>]
            The maximum amount of time the animation is expected to take (in seconds).
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition`1.op_Implicit(Animancer.ControllerState.Transition{`0})~UnityEngine.RuntimeAnimatorController">
            <summary>Returns the <see cref="P:Animancer.ControllerState.Transition`1.Controller"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition`1.Animancer#IAnimationClipCollection#GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>Adds all clips in the <see cref="P:Animancer.ControllerState.Transition`1.Controller"/> to the collection.</summary>
        </member>
        <member name="T:Animancer.ControllerState.Transition">
            <summary>
            A serializable <see cref="T:Animancer.IAnimancerTransition"/> which can create a <see cref="T:Animancer.ControllerState"/> when
            passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>.
            <para></para>
            This class can be implicitly cast to and from <see cref="T:UnityEngine.RuntimeAnimatorController"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ControllerState"/> connected to the `layer`.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.ControllerState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition.#ctor(UnityEngine.RuntimeAnimatorController)">
            <summary>Constructs a new <see cref="T:Animancer.ControllerState.Transition"/> with the specified Animator Controller.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition.op_Implicit(UnityEngine.RuntimeAnimatorController)~Animancer.ControllerState.Transition">
            <summary>Constructs a new <see cref="T:Animancer.ControllerState.Transition"/> with the specified Animator Controller.</summary>
        </member>
        <member name="T:Animancer.ControllerState.Transition.Drawer">
            <summary>
            [Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.ControllerState.Transition`1"/> or
            <see cref="T:Animancer.ControllerState.Transition"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition.Drawer.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.ControllerState.Transition.Drawer"/> without any parameters.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition.Drawer.#ctor(System.String[])">
            <summary>Constructs a new <see cref="T:Animancer.ControllerState.Transition.Drawer"/> and sets the <see cref="F:Animancer.ControllerState.Transition.Drawer.Parameters"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition.Drawer.DoPropertyGUI(UnityEngine.Rect@,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            Draws the `property` GUI in relation to the `rootProperty` which was passed into
            <see cref="M:Animancer.Editor.TransitionDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition.Drawer.DoParameterGUI(UnityEngine.Rect,UnityEditor.Animations.AnimatorController,UnityEditor.SerializedProperty)">
            <summary>
            Draws a dropdown menu to select the name of a parameter in the `controller`.
            </summary>
        </member>
        <member name="T:Animancer.Float1ControllerState">
            <summary>[Pro-Only]
            A <see cref="T:Animancer.ControllerState"/> which manages one float parameter.
            </summary>
            <remarks>
            See also: <see cref="T:Animancer.Float2ControllerState"/> and <see cref="T:Animancer.Float3ControllerState"/>.
            </remarks>
        </member>
        <member name="P:Animancer.Float1ControllerState.ParameterName">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Float1ControllerState.Parameter"/> will get and set.
            This will be null if the <see cref="P:Animancer.Float1ControllerState.ParameterHash"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Float1ControllerState.ParameterHash">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Float1ControllerState.Parameter"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Float1ControllerState.Parameter">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float1ControllerState.ParameterHash"/> as the id.
            </summary>
        </member>
        <member name="M:Animancer.Float1ControllerState.#ctor(Animancer.AnimancerPlayable,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,System.Boolean)">
            <summary>
            Constructs a new <see cref="T:Animancer.Float1ControllerState"/> to play the `controller` without connecting
            it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            </summary>
        </member>
        <member name="M:Animancer.Float1ControllerState.#ctor(Animancer.AnimancerLayer,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,System.Boolean)">
            <summary>
            Constructs a new <see cref="T:Animancer.Float1ControllerState"/> to play the `controller` and connects it to the
            the `layer`.
            </summary>
        </member>
        <member name="M:Animancer.Float1ControllerState.#ctor(Animancer.AnimancerNode,System.Int32,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,System.Boolean)">
            <summary>
            Constructs a new <see cref="T:Animancer.Float1ControllerState"/> to play the `controller` and connects
            connects it to the `parent` at the specified `index`.
            </summary>
        </member>
        <member name="P:Animancer.Float1ControllerState.ParameterCount">
            <summary>The number of parameters being wrapped by this state.</summary>
        </member>
        <member name="M:Animancer.Float1ControllerState.GetParameterHash(System.Int32)">
            <summary>Returns the hash of a parameter being wrapped by this state.</summary>
        </member>
        <member name="T:Animancer.Float1ControllerState.Transition">
            <summary>
            A serializable <see cref="T:Animancer.IAnimancerTransition"/> which can create a <see cref="T:Animancer.Float1ControllerState"/>
            when passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            </remarks>
        </member>
        <member name="P:Animancer.Float1ControllerState.Transition.ParameterName">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.Float1ControllerState.ParameterName"/> that will be used for the created state.
            </summary>
        </member>
        <member name="M:Animancer.Float1ControllerState.Transition.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.Float1ControllerState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.Float1ControllerState.Transition.#ctor(UnityEngine.RuntimeAnimatorController,System.String)">
            <summary>Constructs a new <see cref="T:Animancer.Float1ControllerState.Transition"/> with the specified Animator Controller and parameter.</summary>
        </member>
        <member name="M:Animancer.Float1ControllerState.Transition.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.Float1ControllerState"/> connected to the `layer`.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="T:Animancer.Float1ControllerState.Transition.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.Float1ControllerState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.Float1ControllerState.Transition.Drawer.#ctor">
            <summary>
            Constructs a new <see cref="T:Animancer.Float1ControllerState.Transition.Drawer"/> and sets the
            <see cref="F:Animancer.ControllerState.Transition.Drawer.Parameters"/>.
            </summary>
        </member>
        <member name="T:Animancer.Float2ControllerState">
            <summary>[Pro-Only]
            A <see cref="T:Animancer.ControllerState"/> which manages two float parameters.
            </summary>
            <remarks>
            See also: <see cref="T:Animancer.Float1ControllerState"/> and <see cref="T:Animancer.Float3ControllerState"/>.
            </remarks>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterNameX">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Float2ControllerState.ParameterX"/> will get and set.
            This will be null if the <see cref="P:Animancer.Float2ControllerState.ParameterHashX"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterHashX">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Float2ControllerState.ParameterX"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterX">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float2ControllerState.ParameterHashX"/> as the id.
            </summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterNameY">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Float2ControllerState.ParameterY"/> will get and set.
            This will be null if the <see cref="P:Animancer.Float2ControllerState.ParameterHashY"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterHashY">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Float2ControllerState.ParameterY"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterY">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float2ControllerState.ParameterHashY"/> as the id.
            </summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.Parameter">
            <summary>
            Gets and sets <see cref="P:Animancer.Float2ControllerState.ParameterX"/> and <see cref="P:Animancer.Float2ControllerState.ParameterY"/>.
            </summary>
        </member>
        <member name="M:Animancer.Float2ControllerState.#ctor(Animancer.AnimancerPlayable,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter,System.Boolean)">
            <summary>
            Constructs a new <see cref="T:Animancer.Float2ControllerState"/> to play the `controller` without connecting
            it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            </summary>
        </member>
        <member name="M:Animancer.Float2ControllerState.#ctor(Animancer.AnimancerLayer,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter,System.Boolean)">
            <summary>
            Constructs a new <see cref="T:Animancer.Float2ControllerState"/> to play the `controller` and connects it to the
            the `layer`.
            </summary>
        </member>
        <member name="M:Animancer.Float2ControllerState.#ctor(Animancer.AnimancerNode,System.Int32,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter,System.Boolean)">
            <summary>
            Constructs a new <see cref="T:Animancer.Float2ControllerState"/> to play the `controller` and
            connects it to the `parent` at the specified `index`.
            </summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterCount">
            <summary>The number of parameters being wrapped by this state.</summary>
        </member>
        <member name="M:Animancer.Float2ControllerState.GetParameterHash(System.Int32)">
            <summary>Returns the hash of a parameter being wrapped by this state.</summary>
        </member>
        <member name="T:Animancer.Float2ControllerState.Transition">
            <summary>
            A serializable <see cref="T:Animancer.IAnimancerTransition"/> which can create a <see cref="T:Animancer.Float2ControllerState"/>
            when passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            </remarks>
        </member>
        <member name="P:Animancer.Float2ControllerState.Transition.ParameterNameX">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.Float2ControllerState.ParameterNameX"/> that will be used for the created state.
            </summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.Transition.ParameterNameY">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.Float2ControllerState.ParameterNameY"/> that will be used for the created state.
            </summary>
        </member>
        <member name="M:Animancer.Float2ControllerState.Transition.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.Float2ControllerState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.Float2ControllerState.Transition.#ctor(UnityEngine.RuntimeAnimatorController,System.String,System.String)">
            <summary>Constructs a new <see cref="T:Animancer.Float2ControllerState.Transition"/> with the specified Animator Controller and parameters.</summary>
        </member>
        <member name="M:Animancer.Float2ControllerState.Transition.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.Float2ControllerState"/> connected to the `layer`.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="T:Animancer.Float2ControllerState.Transition.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.Float2ControllerState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.Float2ControllerState.Transition.Drawer.#ctor">
            <summary>
            Constructs a new <see cref="T:Animancer.Float2ControllerState.Transition.Drawer"/> and sets the
            <see cref="F:Animancer.ControllerState.Transition.Drawer.Parameters"/>.
            </summary>
        </member>
        <member name="T:Animancer.Float3ControllerState">
            <summary>[Pro-Only]
            A <see cref="T:Animancer.ControllerState"/> which manages three float parameters.
            </summary>
            <remarks>
            See also: <see cref="T:Animancer.Float1ControllerState"/> and <see cref="T:Animancer.Float2ControllerState"/>.
            </remarks>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterNameX">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Float3ControllerState.ParameterX"/> will get and set.
            This will be null if the <see cref="P:Animancer.Float3ControllerState.ParameterHashX"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterHashX">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Float3ControllerState.ParameterX"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterX">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float3ControllerState.ParameterHashX"/> as the id.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterNameY">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Float3ControllerState.ParameterY"/> will get and set.
            This will be null if the <see cref="P:Animancer.Float3ControllerState.ParameterHashY"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterHashY">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Float3ControllerState.ParameterY"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterY">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float3ControllerState.ParameterHashY"/> as the id.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterNameZ">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Float3ControllerState.ParameterZ"/> will get and set.
            This will be null if the <see cref="P:Animancer.Float3ControllerState.ParameterHashZ"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterHashZ">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Float3ControllerState.ParameterZ"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterZ">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float3ControllerState.ParameterHashZ"/> as the id.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.Parameter">
            <summary>
            Gets and sets <see cref="P:Animancer.Float3ControllerState.ParameterX"/>, <see cref="P:Animancer.Float3ControllerState.ParameterY"/>, and <see cref="P:Animancer.Float3ControllerState.ParameterZ"/>.
            </summary>
        </member>
        <member name="M:Animancer.Float3ControllerState.#ctor(Animancer.AnimancerPlayable,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter,System.Boolean)">
            <summary>
            Constructs a new <see cref="T:Animancer.Float3ControllerState"/> to play the `controller` without connecting
            it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            </summary>
        </member>
        <member name="M:Animancer.Float3ControllerState.#ctor(Animancer.AnimancerLayer,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter,System.Boolean)">
            <summary>
            Constructs a new <see cref="T:Animancer.Float3ControllerState"/> to play the `controller` and connects it to the
            the `layer`.
            </summary>
        </member>
        <member name="M:Animancer.Float3ControllerState.#ctor(Animancer.AnimancerNode,System.Int32,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter,System.Boolean)">
            <summary>
            Constructs a new <see cref="T:Animancer.Float3ControllerState"/> to play the `controller` and
            connects it to the `parent` at the specified `index`.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterCount">
            <summary>The number of parameters being wrapped by this state.</summary>
        </member>
        <member name="M:Animancer.Float3ControllerState.GetParameterHash(System.Int32)">
            <summary>Returns the hash of a parameter being wrapped by this state.</summary>
        </member>
        <member name="T:Animancer.Float3ControllerState.Transition">
            <summary>
            A serializable <see cref="T:Animancer.IAnimancerTransition"/> which can create a <see cref="T:Animancer.Float3ControllerState"/>
            when passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            </remarks>
        </member>
        <member name="P:Animancer.Float3ControllerState.Transition.ParameterNameX">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.Float3ControllerState.ParameterNameX"/> that will be used for the created state.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.Transition.ParameterNameY">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.Float3ControllerState.ParameterNameY"/> that will be used for the created state.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.Transition.ParameterNameZ">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.Float3ControllerState.ParameterNameZ"/> that will be used for the created state.
            </summary>
        </member>
        <member name="M:Animancer.Float3ControllerState.Transition.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.Float3ControllerState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.Float3ControllerState.Transition.#ctor(UnityEngine.RuntimeAnimatorController,System.String,System.String,System.String)">
            <summary>Constructs a new <see cref="T:Animancer.Float3ControllerState.Transition"/> with the specified Animator Controller and parameters.</summary>
        </member>
        <member name="M:Animancer.Float3ControllerState.Transition.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.Float3ControllerState"/> connected to the `layer`.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="T:Animancer.Float3ControllerState.Transition.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.Float3ControllerState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.Float3ControllerState.Transition.Drawer.#ctor">
            <summary>
            Constructs a new <see cref="T:Animancer.Float3ControllerState.Transition.Drawer"/> and sets the
            <see cref="F:Animancer.ControllerState.Transition.Drawer.Parameters"/>.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerEvent">
            <summary>
            A <see cref="F:Animancer.AnimancerEvent.callback"/> delegate paired with a <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> to determine when to invoke it.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.normalizedTime">
            <summary>The <see cref="P:Animancer.AnimancerState.NormalizedTime"/> at which to invoke the <see cref="F:Animancer.AnimancerEvent.callback"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.callback">
            <summary>The delegate to invoke when the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> passes.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.AlmostOne">
            <summary>The largest possible float value less than 1.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.#ctor(System.Single,System.Action)">
            <summary>Constructs a new <see cref="T:Animancer.AnimancerEvent"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.ToString">
            <summary>Returns "AnimancerEvent(normalizedTime, callbackTarget.CallbackMethod)".</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.AppendDetails(System.Text.StringBuilder,System.String,System.String)">
            <summary>Appends the details of this event to the `text`.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.CurrentState">
            <summary>The <see cref="T:Animancer.AnimancerState"/> currently triggering an event using <see cref="M:Animancer.AnimancerEvent.Invoke(Animancer.AnimancerState)"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.CurrentEvent">
            <summary>The <see cref="T:Animancer.AnimancerEvent"/> currently being triggered by <see cref="M:Animancer.AnimancerEvent.Invoke(Animancer.AnimancerState)"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Invoke(Animancer.AnimancerState)">
            <summary>
            Sets the static <see cref="P:Animancer.AnimancerEvent.CurrentState"/> and <see cref="P:Animancer.AnimancerEvent.CurrentEvent"/> then invokes the <see cref="F:Animancer.AnimancerEvent.callback"/>.
            <para></para>
            This method catches and logs any exception thrown by the <see cref="F:Animancer.AnimancerEvent.callback"/>.
            </summary>
            <exception cref="T:System.NullReferenceException">Thrown if the <see cref="F:Animancer.AnimancerEvent.callback"/> is null.</exception>
        </member>
        <member name="M:Animancer.AnimancerEvent.GetFadeOutDuration(System.Single)">
            <summary>
            Returns either the `minDuration` or the <see cref="P:Animancer.AnimancerState.RemainingDuration"/> of the
            <see cref="P:Animancer.AnimancerEvent.CurrentState"/> state (whichever is higher).
            </summary>
        </member>
        <member name="T:Animancer.AnimancerEvent.Sequence">
            <summary>
            A variable-size list of <see cref="T:Animancer.AnimancerEvent"/>s which keeps itself sorted by
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>.
            <para></para>
            Animancer Lite does not allow the use of events in a runtime build, except for <see cref="P:Animancer.AnimancerEvent.Sequence.OnEnd"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.EmptyArray">
            <summary>
            A zero length array of <see cref="T:Animancer.AnimancerEvent"/>s which is used by all lists before any elements are
            added to them (unless their <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is set manually).
            </summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.DefaultCapacity">
            <summary>The initial <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> that will be used if another value is not specified.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.endEvent">
            <summary>
            An <see cref="T:Animancer.AnimancerEvent"/> which denotes the end of the animation. Its values can be accessed via
            <see cref="P:Animancer.AnimancerEvent.Sequence.OnEnd"/> and <see cref="P:Animancer.AnimancerEvent.Sequence.NormalizedEndTime"/>.
            <para></para>
            By default, the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> will be <see cref="F:System.Single.NaN"/> so that it can choose the
            correct value based on the current play direction: forwards ends at 1 and backwards ends at 0.
            <para></para>
            Animancer Lite does not allow the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> to be changed in a runtime build.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence._Events">
            <summary>The internal array in which the events are stored (excluding the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>).</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Count">
            <summary>[Pro-Only] The number of events in this sequence (excluding the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>).</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Version">
            <summary>[Pro-Only]
            The number of times the contents of this sequence have been modified. This applies to general events,
            but not the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.#ctor">
            <summary>
            Creates a new <see cref="T:Animancer.AnimancerEvent.Sequence"/> which starts at 0 <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/>.
            <para></para>
            Adding anything to the list will set the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> = <see cref="F:Animancer.AnimancerEvent.Sequence.DefaultCapacity"/>
            and then double it whenever the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> would exceed the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.#ctor(System.Int32)">
            <summary>[Pro-Only]
            Creates a new <see cref="T:Animancer.AnimancerEvent.Sequence"/> which starts with the specified <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/>. It will be
            initially empty, but will have room for the given number of elements before any reallocations are
            required.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.#ctor(Animancer.AnimancerEvent.Sequence)">
            <summary>
            Creates a new <see cref="T:Animancer.AnimancerEvent.Sequence"/>, copying the contents of `copyFrom` into it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.#ctor(System.Collections.Generic.ICollection{Animancer.AnimancerEvent})">
            <summary>[Pro-Only]
            Creates a new <see cref="T:Animancer.AnimancerEvent.Sequence"/>, copying and sorting the contents of the `collection` into it.
            The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> and <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> will be equal to the
            <see cref="P:System.Collections.Generic.ICollection`1.Count"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.#ctor(System.Collections.Generic.IEnumerable{Animancer.AnimancerEvent})">
            <summary>[Pro-Only]
            Creates a new <see cref="T:Animancer.AnimancerEvent.Sequence"/>, copying and sorting the contents of the `enumerable` into it.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.IsEmpty">
            <summary>
            Indicates whether the list has any events in it or the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/> event's
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> is not at the default value (1).
            </summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Capacity">
            <summary>[Pro-Only]
            The size of the internal array used to hold events.
            <para></para>
            When set, the array is reallocated to the given size.
            <para></para>
            By default, the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> starts at 0 and increases to the <see cref="F:Animancer.AnimancerEvent.Sequence.DefaultCapacity"/>
            when the first event is added.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Item(System.Int32)">
            <summary>[Pro-Only] Gets the event at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AssertNormalizedTimes">
            <summary>[Assert]
            Throws an <see cref="T:System.ArgumentOutOfRangeException"/> if the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> of any events
            is less than 0 or greater than or equal to 1.
            <para></para>
            This does not include the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/> since it works differently to other events.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AssertNormalizedTimes(System.Boolean)">
            <summary>[Assert]
            Calls <see cref="M:Animancer.AnimancerEvent.Sequence.AssertNormalizedTimes"/> if `isLooping` is true.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.DeepToString(System.Boolean)">
            <summary>Returns a string containing the details of all events in this sequence.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.GetEnumerator">
            <summary>[Pro-Only] Returns an <see cref="T:Animancer.AnimancerEvent.Sequence.Enumerator"/> for this sequence.</summary>
        </member>
        <member name="T:Animancer.AnimancerEvent.Sequence.Enumerator">
            <summary>[Pro-Only]
            An iterator that can cycle through every event in a <see cref="F:Animancer.AnimancerEvent.Sequence.Enumerator.Sequence"/> except for the
            <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Enumerator.Sequence">
            <summary>The target <see cref="T:Animancer.AnimancerEvent.Sequence"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Enumerator.Current">
            <summary>The event this iterator is currently pointing to.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Enumerator.System#Collections#IEnumerator#Current">
            <summary>The event this iterator is currently pointing to.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Enumerator.#ctor(Animancer.AnimancerEvent.Sequence)">
            <summary>Creates a new <see cref="T:Animancer.AnimancerEvent.Sequence.Enumerator"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Enumerator.MoveNext">
            <summary>
            Moves to the next event in the <see cref="F:Animancer.AnimancerEvent.Sequence.Enumerator.Sequence"/> and returns true if there is one.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the <see cref="P:Animancer.AnimancerEvent.Sequence.Version"/> has changed since this iterator was created.
            </exception>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Enumerator.System#Collections#IEnumerator#Reset">
            <summary>
            Returns this iterator to the start of the <see cref="F:Animancer.AnimancerEvent.Sequence.Enumerator.Sequence"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the <see cref="P:Animancer.AnimancerEvent.Sequence.Version"/> has changed since this iterator was created.
            </exception>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Add(Animancer.AnimancerEvent)">
            <summary>[Pro-Only]
            Adds the given event to this list. The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> is increased by one and if required, the
            <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is doubled to fit the new event.
            <para></para>
            This methods returns the index at which the event is added, which is determined by its
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> in order to keep the list sorted in ascending order. If there are already
            any events with the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, the new event is added immediately after them.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Add(System.Single,System.Action)">
            <summary>[Pro-Only]
            Adds the given event to this list. The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> is increased by one and if required, the
            <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is doubled to fit the new event.
            <para></para>
            This methods returns the index at which the event is added, which is determined by its
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> in order to keep the list sorted in ascending order. If there are already
            any events with the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, the new event is added immediately after them.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Add(System.Int32,Animancer.AnimancerEvent)">
            <summary>[Pro-Only]
            Adds the given event to this list. The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> is increased by one and if required, the
            <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is doubled to fit the new event.
            <para></para>
            This methods returns the index at which the event is added, which is determined by its
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> in order to keep the list sorted in ascending order. If there are already
            any events with the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, the new event is added immediately after them.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Add(System.Int32,System.Single,System.Action)">
            <summary>[Pro-Only]
            Adds the given event to this list. The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> is increased by one and if required, the
            <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is doubled to fit the new event.
            <para></para>
            This methods returns the index at which the event is added, which is determined by its
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> in order to keep the list sorted in ascending order. If there are already
            any events with the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, the new event is added immediately after them.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AddRange(System.Collections.Generic.IEnumerable{Animancer.AnimancerEvent})">
            <summary>[Pro-Only]
            Adds every event in the `enumerable` to this list. The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> is increased by one and if
            required, the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is doubled to fit the new event.
            <para></para>
            This methods returns the index at which the event is added, which is determined by its
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> in order to keep the list sorted in ascending order. If there are already
            any events with the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, the new event is added immediately after them.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Set(System.Int32,System.Action)">
            <summary>[Pro-Only]
            Replaces the <see cref="F:Animancer.AnimancerEvent.callback"/> of the event at the specified `index`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Insert(System.Single)">
            <summary>[Pro-Only]
            Determines the index where a new event with the specified `normalizedTime` should be added in order to
            keep this list sorted, increases the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> by one, doubles the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> if
            required, moves any existing events to open up the chosen index, and returns that index.
            <para></para>
            This overload starts searching for the desired index from the end of the list, using the assumption
            that elements will usually be added in order.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Insert(System.Int32,System.Single)">
            <summary>[Pro-Only]
            Determines the index where a new event with the specified `normalizedTime` should be added in order to
            keep this list sorted, increases the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> by one, doubles the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> if
            required, moves any existing events to open up the chosen index, and returns that index.
            <para></para>
            This overload starts searching for the desired index from the `hint`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Insert(System.Int32)">
            <summary>[Pro-Only]
            Increases the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> by one, doubles the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> if required, and moves any
            existing events to open up the `index`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Remove(System.Int32)">
            <summary>[Pro-Only]
            Removes the event at the specified `index` from this list by decrementing the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> and
            copying all events after the removed one down one place.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Remove(Animancer.AnimancerEvent)">
            <summary>[Pro-Only]
            Removes the `animancerEvent` from this list by decrementing the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> and copying all
            events after the removed one down one place. Returns true if the event was found and removed.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.RemoveAll">
            <summary>[Pro-Only]
            Removes all events except the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>.
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.Clear"/>
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Clear">
            <summary>
            Removes all events, including the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>.
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.RemoveAll"/>
            </summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.OnEnd">
             <summary>
             Shorthand for the <c>endEvent.callback</c>. This callback is triggered when the animation passed the
             <see cref="P:Animancer.AnimancerEvent.Sequence.NormalizedEndTime"/> (not when the state is interrupted or exited for whatever reason).
             <para></para>
             Unlike regular events, this callback will be triggered every frame while it is past the end so if you
             want to ensure that your callback only occurs once, you will need to clear it as part of that callback.
             <para></para>
             This callback is automatically cleared by <see cref="M:Animancer.AnimancerState.Play"/>,
             <see cref="M:Animancer.AnimancerState.OnStartFade"/>, and <see cref="M:Animancer.AnimancerState.Stop"/>.
             </summary>
            
             <example>
             <code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 Debug.Log("Playing " + clip.name);
                 var state = animancer.Play(clip);
            
                 // Lambda expression:
                 state.Events.OnEnd = () =>
                 {
                     Debug.Log(clip.name + " ended");
                 };
            
                 // One-line Lambda expression:
                 state.Events.OnEnd = () => Debug.Log(clip.name + " ended");
            
                 // Anonymous method (functionally identical to the Lambda expression):
                 state.Events.OnEnd = delegate()
                 {
                     Debug.Log(clip.name + " ended");
                 };
            
                 // Regular Method:
                 state.Events.OnEnd = OnAnimationEnd;
             }
            
             void OnAnimationEnd()
             {
                 Debug.Log("Animation ended");
             }
             </code>
             <h2>Caching Delegates</h2>
             The above examples will all allocate some garbage every time they are used which can cause performance
             issues. This can be avoided by caching the delegate:
             <para></para><code>
             private System.Action _OnAnimationEnd;
            
             void Awake()
             {
                 _OnAnimationEnd = () => Debug.Log("Animation ended");
             }
            
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 animancer.Play(clip).Events.OnEnd = _OnAnimationEnd;
             }
             </code>
             <h2>Transitions</h2>
             You can also use the <see cref="P:Animancer.AnimancerState.Transition`1.Events"/> which do not get cleared,
             so you can assign the delegate once on startup and it will use that every time the state is played:
             <para></para><code>
             [SerializeField]
             private ClipState.Transition _Animation;
            
             void Awake()
             {
                 _Animation.Events.GetOrCreateSequence().OnEnd = () => Debug.Log("Animation ended");
             }
            
             void PlayAnimation(AnimancerComponent animancer)
             {
                 animancer.Transition(_Animation);
             }
             </code>
             Note that we aren't passing an <see cref="T:UnityEngine.AnimationClip"/> into <c>PlayAnimation</c> like the previous
             examples. Usually you would already have a serialized field for the <see cref="T:UnityEngine.AnimationClip"/> so you
             would simply replace it with a <see cref="T:Animancer.ClipState.Transition"/>.
             </example>
            
             <remarks>
             The reason for this callback being automatically cleared all the time is so that you don't have to worry
             about other scripts that might have used the same animation previously.
             <para></para>
             For example, if a character has an <em>Attack</em> animation which wants to return to <em>Idle</em> when it
             finishes but the character gets hit by an enemy in the middle of the <em>Attack</em>, the character will
             now want to play the <em>Flinch</em> animation and return to <em>Idle</em> after that instead. At that
             point, we no longer care about the end of the <em>Attack</em> animation.
             <para></para>
             If we want to attack again, we just play the animation and register the callback again. But if the
             character has a special skill that lets them perform an attack combo which includes the same
             <em>Attack</em> animation followed by several others in sequence, that skill won't want it to still have
             the <see cref="P:Animancer.AnimancerEvent.Sequence.OnEnd"/> that returns to idle.
             <para></para>
             This way, each script that plays an animation takes over the responsibility for managing what it expects to
             happen without worrying about the expectations of other scripts.
             <para></para>
             That said, enforcing rules for which animations/actions are allowed to interrupt each other is often very
             important so it is covered in the
             <see href="kybernetik.com.au/animancer/docs/examples/state-machines/interrupt-management">
             State Machines/Interrupt Management</see> example.
             </remarks>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.NormalizedEndTime">
            <summary>[Pro-Only]
            Shorthand for <c>endEvent.normalizedTime</c>. See <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/> for more details.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.GetDefaultNormalizedEndTime(System.Single)">
            <summary>
            The default <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> for an <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/> when playing forwards is 1 (the
            end of the animation) and when playing backwards is 0 (the start of the animation).
            <para></para>
            `speed` 0 or <see cref="F:System.Single.NaN"/> will also return 1.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.CopyFrom(Animancer.AnimancerEvent.Sequence)">
            <summary>
            Copies all the events from the `source` to replace the previous contents of this list.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.CopyTo(Animancer.AnimancerEvent[],System.Int32)">
            <summary>[<see cref="T:System.Collections.Generic.ICollection`1"/>]
            Copies all the events from this list into the `array`, starting at the `index`.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerEvent.Sequence.Serializable">
            <summary>
            An <see cref="T:Animancer.AnimancerEvent.Sequence"/> that can be serialized and uses
            <see cref="T:UnityEngine.Events.UnityEvent"/>s to define the <see cref="F:Animancer.AnimancerEvent.callback"/>s.
            </summary>
            <remarks>
            If you have Animancer Pro you can replace <see cref="T:UnityEngine.Events.UnityEvent"/>s with
            <see href="kybernetik.com.au/ultevents">UltEvents</see> using the following procedure:
            <list type="number">
            <item>Select the <c>Assets/Plugins/Animancer/Animancer.asmdef</c> and add a Reference to the
            <c>UltEvents</c> Assembly Definition.</item>
            <item>Go into the Player Settings of your project and add <c>ANIMANCER_ULT_EVENTS</c> as a Scripting
            Define Symbol. Or you can simply edit this script to change the event type (it is located at
            <c>Assets/Plugins/Animancer/Internal/Core/AnimancerEvent.Sequence.Serializable.cs</c> by default.</item>
            </list>
            </remarks>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Serializable._NormalizedTimes">
            <summary>The serialized <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>s.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Serializable.NormalizedTimesField">
            <summary>The name of the array field which stores the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>s.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Serializable._Callbacks">
            <summary>The serialized <see cref="F:Animancer.AnimancerEvent.callback"/>s.</summary>
            <remarks>
            This array only needs to be large enough to hold the last event that actually contains any calls.
            Any empty or missing elements will simply use the <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable.DummyCallback"/> at runtime.
            </remarks>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Serializable.Callbacks">
            <summary>The name of the array field which stores the <see cref="F:Animancer.AnimancerEvent.callback"/>s.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Serializable.Sequence">
            <summary>
            The runtime <see cref="T:Animancer.AnimancerEvent.Sequence"/> compiled from this <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/>.
            Each call after the first will return the same value.
            <para></para>
            Unlike <see cref="M:Animancer.AnimancerEvent.Sequence.Serializable.GetSequenceOptional"/>, this method will create an empty
            <see cref="T:Animancer.AnimancerEvent.Sequence"/> instead of returning null.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.GetSequenceOptional">
            <summary>
            Returns the runtime <see cref="T:Animancer.AnimancerEvent.Sequence"/> compiled from this
            <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/>. Each call after the first will return the same value.
            <para></para>
            This method returns null if the sequence would be empty anyway and is used by the implicit
            conversion from <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/> to <see cref="T:Animancer.AnimancerEvent.Sequence"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.op_Implicit(Animancer.AnimancerEvent.Sequence.Serializable)~Animancer.AnimancerEvent.Sequence">
            <summary>Calls <see cref="M:Animancer.AnimancerEvent.Sequence.Serializable.GetSequenceOptional"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Serializable.DummyCallback">
            <summary>
            A delegate that does nothing which is used whenever the <see cref="T:UnityEngine.Events.UnityEvent"/> is not
            defined for a particular event or it is empty.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.GetInvoker(UnityEngine.Events.UnityEvent)">
            <summary>
            If the `callback` has any persistent calls, this method returns a delegate to call its
            <see cref="M:UnityEngine.Events.UnityEvent.Invoke"/> method. Otherwise it returns the
            <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable.DummyCallback"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.HasPersistentCalls(UnityEngine.Events.UnityEvent)">
            <summary>
            Determines if the `callback` contains any method calls that will be serialized (otherwise the
            <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable.DummyCallback"/> can be used instead of creating a new delegate to invoke the empty
            `callback`).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.HasPersistentCalls(System.Object)">
            <summary>
            Determines if the `callback` contains any method calls that will be serialized (otherwise the
            <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable.DummyCallback"/> can be used instead of creating a new delegate to invoke the empty
            `callback`).
            <para></para>
            This method casts the `callback` to <see cref="T:UnityEngine.Events.UnityEvent"/> so the caller does not need
            to know what type is actually being used.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.GetNormalizedEndTime(System.Single)">
            <summary>
            Returns the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> of the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>.
            <para></para>
            If the value is not set, the value is determined by <see cref="M:Animancer.AnimancerEvent.Sequence.GetDefaultNormalizedEndTime(System.Single)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.GetDetails(Animancer.AnimancerEvent.Sequence.Serializable,System.Int32@,System.Int32@)">
            <summary>Gets the internal details of the specified `serializable`.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.UnityEngine#ISerializationCallbackReceiver#OnAfterDeserialize">
            <summary>[Editor-Only] Does nothing.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.UnityEngine#ISerializationCallbackReceiver#OnBeforeSerialize">
            <summary>[Editor-Only] Ensures that the events are sorted by time (excluding the end event).</summary>
        </member>
        <member name="T:Animancer.Editor.SerializableCallbackHolder">
            <summary>[Editor-Only] [Internal]
            A serializable container which holds a <see cref="T:UnityEngine.Events.UnityEvent"/> in a field named "_Callback".
            </summary>
            <remarks>
            <see cref="T:Animancer.Editor.DummySerializableCallback"/> needs to be in a file with the same name as it (otherwise it can't
            draw the callback properly) and this class needs to be in the same file as
            <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/> to use the <see cref="T:UnityEngine.Events.UnityEvent"/> alias.
            </remarks>
        </member>
        <member name="T:Animancer.Editor.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.ClipState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Drawer.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.Editor.Drawer"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerEditorUtilities">
            <summary>[Editor-Only]
            Various utilities used throughout <see cref="N:Animancer"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.GetComponentInHierarchy``1(UnityEngine.GameObject)">
            <summary>
            Tries to find a <typeparamref name="T"/> component on the `gameObject` or its parents or children (in that
            order).
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.ShouldAllowReference(UnityEngine.Object,UnityEngine.Object)">
            <summary>
            Assets cannot reference scene objects.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.GetIsInspectorExpanded(UnityEngine.Object)">
            <summary>Wraps <see cref="M:UnityEditorInternal.InternalEditorUtility.GetIsInspectorExpanded(UnityEngine.Object)"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.SetIsInspectorExpanded(UnityEngine.Object,System.Boolean)">
            <summary>Wraps <see cref="M:UnityEditorInternal.InternalEditorUtility.SetIsInspectorExpanded(UnityEngine.Object,System.Boolean)"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.SetIsInspectorExpanded(UnityEngine.Object[],System.Boolean)">
            <summary>Calls <see cref="M:Animancer.Editor.AnimancerEditorUtilities.SetIsInspectorExpanded(UnityEngine.Object,System.Boolean)"/> on all `objects`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.Invoke(System.Object,System.String)">
            <summary>
            Tries to find a method with the specified name on the `target` object and invoke it.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.Invoke(System.Type,System.Object,System.String)">
            <summary>
            Tries to find a method with the specified name on the `target` object and invoke it.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.RegisterNonCriticalIssue(System.Action{System.Text.StringBuilder})">
            <summary>
            Registers a delegate that can construct a description of an issue at a later time so that it doesn't waste
            the user's time on unimportant issues.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.RegisterNonCriticalMissingType(System.String)">
            <summary>
            Calls <see cref="M:Animancer.Editor.AnimancerEditorUtilities.RegisterNonCriticalIssue(System.Action{System.Text.StringBuilder})"/> with an issue indicating that a particular type was not
            found by reflection.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.RegisterNonCriticalMissingMember(System.String,System.String)">
            <summary>
            Calls <see cref="M:Animancer.Editor.AnimancerEditorUtilities.RegisterNonCriticalIssue(System.Action{System.Text.StringBuilder})"/> with an issue indicating that a particular member was not
            found by reflection.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.AppendNonCriticalIssues(System.Text.StringBuilder)">
            <summary>
            Appends all issues given to <see cref="M:Animancer.Editor.AnimancerEditorUtilities.RegisterNonCriticalIssue(System.Action{System.Text.StringBuilder})"/> to the `text`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.GetParameterValue(UnityEngine.Animator,UnityEngine.AnimatorControllerParameter)">
            <summary>Gets the value of the `parameter` in the `animator`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.GetParameterValue(UnityEngine.Animations.AnimatorControllerPlayable,UnityEngine.AnimatorControllerParameter)">
            <summary>Gets the value of the `parameter` in the `playable`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.SetParameterValue(UnityEngine.Animator,UnityEngine.AnimatorControllerParameter,System.Object)">
            <summary>Sets the value of the `parameter` in the `animator`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.SetParameterValue(UnityEngine.Animations.AnimatorControllerPlayable,UnityEngine.AnimatorControllerParameter,System.Object)">
            <summary>Sets the value of the `parameter` in the `playable`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.IsValid(Animancer.AnimancerNode)">
            <summary>
            Returns true if the `node` is not null and <see cref="P:Animancer.AnimancerNode.IsValid"/>.
            </summary>
            <remarks>
            Normally a method can't have the same name as a property, but an extension method can.
            </remarks>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.EditModeDelayCall(System.Action)">
            <summary>
            Waits one frame to call the `method` as long as Unity is currently in Edit Mode.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.AddMenuItem(UnityEditor.GenericMenu,System.String,System.Boolean,UnityEditor.GenericMenu.MenuFunction)">
            <summary>
            Adds a menu function which is disabled if `isEnabled` is false.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.AddFadeFunction(UnityEditor.GenericMenu,System.String,System.Boolean,Animancer.AnimancerNode,System.Action{System.Single})">
            <summary>
            Adds a menu function which passes the result of <see cref="M:Animancer.Editor.AnimancerEditorUtilities.CalculateEditorFadeDuration(Animancer.AnimancerNode,System.Single)"/> into `startFade`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.CalculateEditorFadeDuration(Animancer.AnimancerNode,System.Single)">
            <summary>
            Returns the duration of the `node`s current fade (if any), otherwise returns the `defaultDuration`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.AddDocumentationLink(UnityEditor.GenericMenu,System.String,System.String)">
            <summary>
            Adds a menu function to open a web page. If the `linkSuffix` starts with a '/' then it will be relative to
            the <see cref="F:Animancer.Strings.DocumentationURL"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.ToggleLooping(UnityEditor.MenuCommand)">
            <summary>
            Toggles the <see cref="P:UnityEngine.Motion.isLooping"/> flag between true and false.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.SetLooping(UnityEngine.AnimationClip,System.Boolean)">
            <summary>
            Sets the <see cref="P:UnityEngine.Motion.isLooping"/> flag.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.ToggleLegacy(UnityEditor.MenuCommand)">
            <summary>Swaps the <see cref="P:UnityEngine.AnimationClip.legacy"/> flag between true and false.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.RestoreBindPose(UnityEditor.MenuCommand)">
            <summary>Calls <see cref="M:UnityEngine.Animator.Rebind"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent">
            <summary>[Editor-Only]
            An <see cref="T:Animancer.IAnimancerComponent"/> that isn't actually a <see cref="T:UnityEngine.Component"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.#ctor(UnityEngine.Animator,Animancer.AnimancerPlayable)">
            <summary>Creates a new <see cref="T:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.enabled">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns true.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.gameObject">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns the <see cref="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.Animator"/>'s <see cref="T:UnityEngine.GameObject"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.Animator">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] The target <see cref="T:UnityEngine.Animator"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.Playable">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] The target <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.IsPlayableInitialised">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns true.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.ResetOnDisable">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns false.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.UpdateMode">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Does nothing.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.GetKey(UnityEngine.AnimationClip)">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns the `clip`.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.AnimatorFieldName">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns null.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.InitialUpdateMode">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns null.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.GetAnimationType(UnityEngine.AnimationClip)">
            <summary>
            Attempts to determine the <see cref="T:Animancer.Editor.AnimationType"/> of the specified `clip`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.GetAnimationType(UnityEngine.Animator)">
            <summary>
            Attempts to determine the <see cref="T:Animancer.Editor.AnimationType"/> of the specified `animator`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.FindRoot(UnityEngine.GameObject)">
             <summary>
             Takes a `gameObject` and returns the root <see cref="T:UnityEngine.Transform"/> of the character it is part of.
             <para></para>
             This method first searches all parents for an <see cref="T:Animancer.IAnimancerRoot"/>. If it finds one, it returns the
             <see cref="P:Animancer.IAnimancerRoot.transform"/>.
             <para></para>
             Otherwise, if the object is part of a prefab then it returns the root of that prefab instance.
             <para></para>
             Otherwise, it counts the number of <see cref="T:UnityEngine.Animator"/>s in the children of the `gameObject` then does
             the same for each parent. If it finds a parent with a different number of child <see cref="T:UnityEngine.Animator"/>s, it
             assumes that object is the parent of multiple characters and returns the previous parent as the root.
             </summary>
            
             <example>
             <h2>Simple Hierarchy</h2>
             <code>    - Character - Rigidbody, etc.
                 - Model - Animator, AnimancerComponent
                 - States - Various components which reference the AnimationClips they will play</code>
             Passing the <c>Model</c> into this method will return the <c>Character</c> because it has the same
             number of <see cref="T:UnityEngine.Animator"/> components in its children.
            
             <h2>Shared Hierarchy</h2>
             <code>    - Characters - Empty object used to group all characters
                 - Character - Rigidbody, etc.
                     - Model - Animator, AnimancerComponent
                     - States - Various components which reference the AnimationClips they will play
                 - Another Character
                     - Model
                     - States</code>
             <list type="bullet">
             <item><c>Model</c> has one <see cref="T:UnityEngine.Animator"/> and no more in its children.</item>
             <item>And <c>Character</c> has one <see cref="T:UnityEngine.Animator"/> in its children (the same one).</item>
             <item>But <c>Characters</c> has two <see cref="T:UnityEngine.Animator"/>s in its children (one on each character).</item>
             </list>
             So it picks the <c>Character</c> as the root.
            
             <h2>Complex Hierarchy</h2>
             <code>    - Character - Rigidbody, etc.
                 - Model - Animator, AnimancerComponent
                 - States - Various components which reference the AnimationClips they will play
                 - Another Model - Animator (maybe the character is holding a gun which has a reload animation)</code>
             In this case, the automatic system would see that the <c>Character</c> already has more child
             <see cref="T:UnityEngine.Animator"/>s than the selected <c>Model</c> so it would only return the <c>Model</c> itself.
             This can be fixed by making any of the scripts on the <c>Character</c> implement <see cref="T:Animancer.IAnimancerRoot"/>
             to tell the system which object you want it to use as the root.
             </example>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.FindRoot(UnityEngine.Object)">
            <summary>
            Calls <see cref="M:Animancer.Editor.AnimancerEditorUtilities.FindRoot(UnityEngine.GameObject)"/> if the specified `obj` is a <see cref="T:UnityEngine.GameObject"/> or
            <see cref="T:UnityEngine.Component"/>.
            </summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerGUI">
            <summary>[Editor-Only] Various GUI utilities used throughout Animancer.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI.WarningFieldColor">
            <summary>The highlight color used for fields showing a warning.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI.ErrorFieldColor">
            <summary>The highlight color used for fields showing an error.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI.DontExpandWidth">
            <summary><see cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)"/> set to false.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.LineHeight">
            <summary>Wrapper around <see cref="P:UnityEditor.EditorGUIUtility.singleLineHeight"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.StandardSpacing">
            <summary>Wrapper around <see cref="P:UnityEditor.EditorGUIUtility.standardVerticalSpacing"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.IndentSize">
            <summary>
            The number of pixels of indentation for each <see cref="P:UnityEditor.EditorGUI.indentLevel"/> increment.
            </summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.ToggleWidth">
            <summary>The width of a standard <see cref="P:UnityEngine.GUISkin.toggle"/> with no label.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.TextColor">
            <summary>The color of the standard label text.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI.MiniButton">
            <summary>
            A more compact <see cref="P:UnityEditor.EditorStyles.miniButton"/> with a fixed size as a tiny box.
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI._TempContent">
            <summary>Used by <see cref="M:Animancer.Editor.AnimancerGUI.TempContent(System.String,System.String,System.Boolean)"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.TempContent(System.String,System.String,System.Boolean)">
            <summary>
            Returns a <see cref="T:UnityEngine.GUIContent"/> with the specified parameters. The same instance is returned by
            every subsequent call.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.TempContent(UnityEditor.SerializedProperty,System.Boolean)">
            <summary>
            Returns a <see cref="T:UnityEngine.GUIContent"/> with the <see cref="P:UnityEditor.SerializedProperty.displayName"/> and
            <see cref="P:UnityEditor.SerializedProperty.tooltip"/>. The same instance is returned by every subsequent call.
            </summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerGUI.SpacingMode">
            <summary>Indicates where <see cref="M:Animancer.Editor.AnimancerGUI.LayoutSingleLineRect(Animancer.Editor.AnimancerGUI.SpacingMode)"/> should add the <see cref="P:Animancer.Editor.AnimancerGUI.StandardSpacing"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.LayoutSingleLineRect(Animancer.Editor.AnimancerGUI.SpacingMode)">
            <summary>
            Uses <see cref="M:UnityEngine.GUILayoutUtility.GetRect(System.Single,System.Single)"/> to get a <see cref="T:UnityEngine.Rect"/> occupying a single
            standard line with the <see cref="P:Animancer.Editor.AnimancerGUI.StandardSpacing"/> added according to the specified `spacing`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.NextVerticalArea(UnityEngine.Rect@)">
            <summary>
            If the <see cref="P:UnityEngine.Rect.height"/> is positive, this method moves the <see cref="P:UnityEngine.Rect.y"/> by that amount and
            adds the <see cref="P:UnityEditor.EditorGUIUtility.standardVerticalSpacing"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.StealFromLeft(UnityEngine.Rect@,System.Single,System.Single)">
            <summary>
            Subtracts the `width` from the left side of the `area` and returns a new <see cref="T:UnityEngine.Rect"/> occupying the
            removed section.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.StealFromRight(UnityEngine.Rect@,System.Single,System.Single)">
            <summary>
            Subtracts the `width` from the right side of the `area` and returns a new <see cref="T:UnityEngine.Rect"/> occupying the
            removed section.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.CalculateWidth(UnityEngine.GUIStyle,UnityEngine.GUIContent)">
            <summary>
            Calls <see cref="M:UnityEngine.GUIStyle.CalcMinMaxWidth(UnityEngine.GUIContent,System.Single@,System.Single@)"/> and returns the max width.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.CalculateWidth(UnityEngine.GUIStyle,System.String)">
            <summary>
            Calls <see cref="M:UnityEngine.GUIStyle.CalcMinMaxWidth(UnityEngine.GUIContent,System.Single@,System.Single@)"/> and returns the max width.
            <para></para>
            This method uses the <see cref="M:Animancer.Editor.AnimancerGUI.TempContent(System.String,System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.CreateWidthCache(UnityEngine.GUIStyle)">
            <summary>
            Creates a <see cref="T:Animancer.Editor.ConversionCache`2"/> for calculating the GUI width occupied by text using the
            specified `style`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.CalculateLabelWidth(System.String)">
            <summary>
            Calls <see cref="M:UnityEngine.GUIStyle.CalcMinMaxWidth(UnityEngine.GUIContent,System.Single@,System.Single@)"/> using <see cref="P:UnityEngine.GUISkin.label"/> and returns the max
            width. The result is cached for efficient reuse.
            <para></para>
            This method uses the <see cref="M:Animancer.Editor.AnimancerGUI.TempContent(System.String,System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.TryUseClickEvent(UnityEngine.Rect,System.Int32)">
            <summary>
            Returns true and uses the current event if it is <see cref="F:UnityEngine.EventType.MouseUp"/> inside the specified
            `area`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.TryUseClickEventInLastRect(System.Int32)">
            <summary>
            Returns true and uses the current event if it is <see cref="F:UnityEngine.EventType.MouseUp"/> inside the last GUI Layout
            <see cref="T:UnityEngine.Rect"/> that was drawn.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.DoWeightLabel(UnityEngine.Rect@,System.Single)">
            <summary>
            Draws a label showing the `weight` aligned to the right side of the `area` and reduces its
            <see cref="P:UnityEngine.Rect.width"/> to remove that label from its area.
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI._TightLabelWidth">
            <summary>The <see cref="P:UnityEditor.EditorGUIUtility.labelWidth"/> from before <see cref="M:Animancer.Editor.AnimancerGUI.BeginTightLabel(System.String)"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.BeginTightLabel(System.String)">
            <summary>Stores the <see cref="P:UnityEditor.EditorGUIUtility.labelWidth"/> and changes it to the exact width of the `label`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.EndTightLabel">
            <summary>Reverts <see cref="P:UnityEditor.EditorGUIUtility.labelWidth"/> to its previous value.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.SplitHorizontally(UnityEngine.Rect,System.String,System.String,System.Single@,System.Single@,UnityEngine.Rect@,UnityEngine.Rect@)">
            <summary>
            Divides the given `area` such that the fields associated with both labels will have equal space
            remaining after the labels themselves.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.HandleDragAndDrop``1(UnityEngine.Rect,System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>
            Invokes `onDrop` if the <see cref="P:UnityEngine.Event.current"/> is a drag and drop event inside the `dropArea`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.TryDrop``1(System.Collections.IEnumerable,System.Func{``0,System.Boolean},System.Action{``0},System.Boolean)">
            <summary>
            Updates the <see cref="P:UnityEditor.DragAndDrop.visualMode"/> of calls `onDrop` for each of the `objects`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.HandleDragAndDropAnimations(UnityEngine.Rect,System.Action{UnityEngine.AnimationClip})">
            <summary>
            Uses <see cref="M:Animancer.Editor.AnimancerGUI.HandleDragAndDrop``1(UnityEngine.Rect,System.Func{``0,System.Boolean},System.Action{``0})"/> to deal with drag and drop operations involving
            <see cref="T:UnityEngine.AnimationClip"/>s of <see cref="T:Animancer.IAnimationClipSource"/>s.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.GetNarrowText(System.String)">
            <summary>
            Returns the `text` without any spaces if <see cref="P:UnityEditor.EditorGUIUtility.wideMode"/> is false.
            Otherwise simply returns the `text` without any changes.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.BeginVerticalBox(UnityEngine.GUIStyle)">
            <summary>
            Begins a vertical layout group using the given style and decreases the
            <see cref="P:UnityEditor.EditorGUIUtility.labelWidth"/> to compensate for the indentation.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.EndVerticalBox(UnityEngine.GUIStyle)">
            <summary>
            Ends a layout group started by <see cref="M:Animancer.Editor.AnimancerGUI.BeginVerticalBox(UnityEngine.GUIStyle)"/> and restores the
            <see cref="P:UnityEditor.EditorGUIUtility.labelWidth"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.Deselect">
            <summary>Deselects any selected IMGUI control.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.DoSpecialFloatField(UnityEngine.Rect,UnityEngine.GUIContent,System.Single,Animancer.Editor.ConversionCache{System.Single,System.String})">
            <summary>
            Draw a <see cref="M:UnityEditor.EditorGUI.FloatField(UnityEngine.Rect,UnityEngine.GUIContent,System.Single)"/> with an alternate cached string when it
            isn't selected (for example, "1" might become "1s" to indicate "seconds").
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.DoFloatFieldWithSuffix(UnityEngine.Rect,UnityEngine.GUIContent,UnityEditor.SerializedProperty,Animancer.Editor.ConversionCache{System.Single,System.String})">
            <summary>
            Draw a <see cref="M:UnityEditor.EditorGUI.FloatField(UnityEngine.Rect,UnityEngine.GUIContent,System.Single)"/> with an alternate cached string when it
            isn't selected (for example, "1" might become "1s" to indicate "seconds").
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.DoOptionalTimeField(UnityEngine.Rect@,UnityEngine.GUIContent,UnityEditor.SerializedProperty,System.Boolean,System.Single,System.Single,System.Boolean)">
            <summary>
            Draw a <see cref="M:UnityEngine.GUI.Toggle(UnityEngine.Rect,System.Boolean,UnityEngine.GUIContent)"/> which sets the value to <see cref="F:System.Single.NaN"/>
            when disabled followed by two float fields to display the <see cref="P:UnityEditor.SerializedProperty.floatValue"/> as
            both normalized time and seconds.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.DoOptionalTimeField(UnityEngine.Rect@,UnityEngine.GUIContent,System.Single,System.Boolean,System.Single,System.Single,System.Boolean)">
            <summary>
            Draw a <see cref="M:UnityEngine.GUI.Toggle(UnityEngine.Rect,System.Boolean,UnityEngine.GUIContent)"/> which sets the value to <see cref="F:System.Single.NaN"/>
            when disabled followed by two float fields to display the `time` both normalized and in seconds.
            </summary>
        </member>
        <member name="T:Animancer.Editor.AnimationGatherer">
            <summary>[Editor-Only]
            Allows animations to be procedurally gathered throughout the hierarchy without needing explicit references.
            </summary>
            <remarks>
            This class is [Editor-Only] because it uses reflection and isn't particularly efficient, but it does not
            actually use any Editor Only functionality so it could be made usable at runtime by simply removing the
            <c>#if UNITY_EDITOR</c> at the top of the file and <c>#endif</c> at the bottom.
            </remarks>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.GatherFromGameObject(UnityEngine.GameObject,System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>
            Fills the `clips` with any <see cref="T:UnityEngine.AnimationClip"/>s referenced by components in the same hierarchy as
            the `gameObject`. See <see cref="T:Animancer.IAnimancerRoot"/> for details.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.GatherFromGameObject(UnityEngine.GameObject,UnityEngine.AnimationClip[]@,System.Boolean)">
            <summary>
            Fills the `clips` with any <see cref="T:UnityEngine.AnimationClip"/>s referenced by components in the same hierarchy as
            the `gameObject`. See <see cref="T:Animancer.IAnimancerRoot"/> for details.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.GatherFromObject(System.Object,System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>
            Gathers all animations from the `source`s fields.
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimationGatherer.TypeToGatherer">
            <summary>Types mapped to a delegate that can quickly gather their clips.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.GatherFromFields(System.Object,System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>
            Uses reflection to gather <see cref="T:UnityEngine.AnimationClip"/>s from fields on the `source` object.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.BuildClipGatherer(System.Type)">
            <summary>
            Creates a delegate to gather <see cref="T:UnityEngine.AnimationClip"/>s from all relevant fields in a given `type`.
            </summary>
        </member>
        <member name="T:Animancer.Editor.AnimationType">
            <summary>[Editor-Only]
            The type of object an <see cref="T:UnityEngine.AnimationClip"/> can animate.
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimationType.None">
            <summary>Unable to determine a type.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationType.Humanoid">
            <summary>A Humanoid rig.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationType.Generic">
            <summary>A Generic rig.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationType.Sprite">
            <summary>
            An animation that modifies a <see cref="P:UnityEngine.SpriteRenderer.sprite"/>.
            <para></para>
            This is technically a <see cref="F:Animancer.Editor.AnimationType.Generic"/> animation.
            </summary>
        </member>
        <member name="T:Animancer.Editor.BoolPref">
            <summary>[Editor-Only]
            A simple wrapper around <see cref="T:UnityEditor.EditorPrefs"/> to get and set a bool.
            <para></para>
            If you are interested in a more comprehensive pref wrapper that supports more types, you should check out
            <see href="kybernetik.com.au/inspector-gadgets">Inspector Gadgets</see>.
            </summary>
        </member>
        <member name="F:Animancer.Editor.BoolPref.KeyPrefix">
            <summary>The prefix which is automatically added before the <see cref="F:Animancer.Editor.BoolPref.Key"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.BoolPref.Key">
            <summary>The identifier with which this pref will be saved.</summary>
        </member>
        <member name="F:Animancer.Editor.BoolPref.MenuItem">
            <summary>The label to use when adding a function to toggle this pref to a menu.</summary>
        </member>
        <member name="F:Animancer.Editor.BoolPref.DefaultValue">
            <summary>The starting value to use for this pref if none was previously saved.</summary>
        </member>
        <member name="P:Animancer.Editor.BoolPref.Value">
            <summary>The current value of this pref.</summary>
        </member>
        <member name="M:Animancer.Editor.BoolPref.op_Implicit(Animancer.Editor.BoolPref)~System.Boolean">
            <summary>Returns the current value of the `pref`.</summary>
        </member>
        <member name="M:Animancer.Editor.BoolPref.#ctor(System.String,System.Boolean)">
            <summary>Constructs a new <see cref="T:Animancer.Editor.BoolPref"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.BoolPref.AddToggleFunction(UnityEditor.GenericMenu)">
            <summary>
            Adds a menu function to toggle the <see cref="P:Animancer.Editor.BoolPref.Value"/> of this pref.
            </summary>
        </member>
        <member name="T:Animancer.Editor.ConversionCache`2">
            <summary>
            A simple system for converting objects and storing the results so they can be reused to minimise the need for
            garbage collection, particularly for string construction.
            </summary>
        </member>
        <member name="M:Animancer.Editor.ConversionCache`2.#ctor(System.Func{`0,`1})">
            <summary>
            Creates a new <see cref="T:Animancer.Editor.ConversionCache`2"/> which uses the specified delegate to convert values.
            </summary>
        </member>
        <member name="M:Animancer.Editor.ConversionCache`2.Convert(`0)">
            <summary>
            If a value has already been cached for the specified `key`, return it. Otherwise create a new one using
            the delegate provided in the constructor and cache it.
            <para></para>
            This method also periodically removes values that have not been used recently.
            </summary>
        </member>
        <member name="T:Animancer.Editor.GUIElementWidth">
            <summary>[Editor-Only] A cached width calculation for GUI elements.</summary>
        </member>
        <member name="M:Animancer.Editor.GUIElementWidth.GetWidth(UnityEngine.GUIStyle,System.String)">
            <summary>Returns the width the `text` would take up if drawn with the `style`.</summary>
        </member>
        <member name="M:Animancer.Editor.GUIElementWidth.OnRecalculate(UnityEngine.GUIStyle,System.String)">
            <summary>Called when <see cref="M:Animancer.Editor.GUIElementWidth.GetWidth(UnityEngine.GUIStyle,System.String)"/> is called with different parameters.</summary>
        </member>
        <member name="T:Animancer.Editor.GUIElementWidthBoldable">
            <summary>[Editor-Only]
            A cached width calculation for GUI elements which accounts for boldness in prefab overrides.
            </summary>
        </member>
        <member name="M:Animancer.Editor.GUIElementWidthBoldable.OnRecalculate(UnityEngine.GUIStyle,System.String)">
            <summary>Called when <see cref="M:Animancer.Editor.GUIElementWidth.GetWidth(UnityEngine.GUIStyle,System.String)"/> is called with different parameters.</summary>
        </member>
        <member name="M:Animancer.Editor.GUIElementWidthBoldable.GetWidth(UnityEngine.GUIStyle,System.String,System.Boolean)">
            <summary>Returns the width the `text` would take up if drawn with the `style`.</summary>
        </member>
        <member name="M:Animancer.Editor.GUIElementWidthBoldable.GetWidth(UnityEngine.GUIStyle,System.String,UnityEditor.SerializedProperty)">
            <summary>Returns the width the `text` would take up if drawn with the `style`.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerLayerDrawer">
            <summary>[Internal]
            A custom Inspector for an <see cref="T:Animancer.AnimancerLayer"/> which sorts and exposes some of its internal values.
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerLayerDrawer.ActiveStates">
            <summary>The states in the target layer which have non-zero <see cref="P:Animancer.AnimancerNode.Weight"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerLayerDrawer.InactiveStates">
            <summary>The states in the target layer which have zero <see cref="P:Animancer.AnimancerNode.Weight"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerLayerDrawer.RegionStyle">
            <summary>The <see cref="T:UnityEngine.GUIStyle"/> used for the area encompassing this drawer. <see cref="P:UnityEngine.GUISkin.box"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.GatherLayerEditors(Animancer.AnimancerPlayable,System.Collections.Generic.List{Animancer.Editor.AnimancerLayerDrawer},System.Int32@)">
            <summary>
            Initialises an editor in the list for each layer in the `animancer`.
            <para></para>
            The `count` indicates the number of elements actually being used. Spare elements are kept in the list in
            case they need to be used again later.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.GatherStates(Animancer.AnimancerLayer)">
            <summary>
            Sets the target `layer` and sorts its states and their keys into the active/inactive lists.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.SortAndGatherKeys(System.Collections.Generic.List{Animancer.AnimancerState})">
            <summary>
            Sorts any entries that use another state as their key to come right after that state.
            See <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoLabelGUI(UnityEngine.Rect)">
            <summary>
            Draws the layer's name and weight.
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerLayerDrawer.FoldoutIndent">
            <summary>The number of pixels of indentation required to fit the foldout arrow.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoFoldoutGUI(UnityEngine.Rect)">
            <summary>Draws a foldout arrow to expand/collapse the state details.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoDetailsGUI(Animancer.IAnimancerComponent)">
            <summary> Draws the details of the target state in the GUI.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoLayerDetailsGUI">
            <summary>
            Draws controls for <see cref="P:Animancer.AnimancerLayer.IsAdditive"/> and <see cref="F:Animancer.AnimancerLayer._Mask"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoStatesGUI(System.String,System.Collections.Generic.List{Animancer.AnimancerState},Animancer.IAnimancerComponent)">
            <summary>Draws all `states` in the given list.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerLayerDrawer.StateInspectors">
            <summary>Cached Inspectors that have already been created for states.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoStateGUI(Animancer.AnimancerState,Animancer.IAnimancerComponent)">
            <summary>Draws the Inspector for the given `state`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoChildStatesGUI(Animancer.AnimancerState,Animancer.IAnimancerComponent)">
            <summary>Draws all child states of the `state`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoGUI(Animancer.IAnimancerComponent)">
            <summary>
            Draws the details and controls for the target <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/> in the Inspector.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.HandleDragAndDropAnimations(UnityEngine.Rect,Animancer.IAnimancerComponent,System.Int32)">
            <summary>
            If <see cref="T:UnityEngine.AnimationClip"/>s or <see cref="T:Animancer.IAnimationClipSource"/>s are dropped inside the `dropArea`,
            this method creates a new state in the `target` for each animation.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.PopulateContextMenu(UnityEditor.GenericMenu)">
            <summary>Adds functions relevant to the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.IAnimancerNodeDrawer">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.AnimancerNode"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.IAnimancerNodeDrawer.DoGUI(Animancer.IAnimancerComponent)">
            <summary>Draws the details and controls for the target node in the Inspector.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerNodeDrawer`1">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.AnimancerNode"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerNodeDrawer`1.Target">
            <summary>The node being managed.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerNodeDrawer`1.IsExpanded">
            <summary>If true, the details of the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/> will be expanded in the Inspector.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerNodeDrawer`1.RegionStyle">
            <summary>The <see cref="T:UnityEngine.GUIStyle"/> used for the area encompassing this drawer.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoGUI(Animancer.IAnimancerComponent)">
            <summary>Draws the details and controls for the target <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/> in the Inspector.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoHeaderGUI">
            <summary>
            Draws the name and other details of the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/> in the GUI.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoLabelGUI(UnityEngine.Rect)">
            <summary>
            Draws a field for the <see cref="P:Animancer.AnimancerState.MainObject"/> if it has one, otherwise just a simple text
            label.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoFoldoutGUI(UnityEngine.Rect)">
            <summary>Draws a foldout arrow to expand/collapse the node details.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoDetailsGUI(Animancer.IAnimancerComponent)">
            <summary>Draws the details of the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/> in the GUI.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoNodeDetailsGUI">
            <summary>
            Draws controls for <see cref="P:Animancer.AnimancerState.IsPlaying"/>, <see cref="P:Animancer.AnimancerNode.Speed"/>, and
            <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoFadeDetailsGUI">
            <summary>
            Draws controls for <see cref="P:Animancer.AnimancerNode.FadeSpeed"/> and <see cref="P:Animancer.AnimancerNode.TargetWeight"/>.
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerNodeDrawer`1.DetailsPrefix">
            <summary>
            The menu label prefix used for details about the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.CheckContextMenu(UnityEngine.Rect)">
            <summary>
            Checks if the current event is a context menu click within the `clickArea` and opens a context menu with various
            functions for the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.PopulateContextMenu(UnityEditor.GenericMenu)">
            <summary>Adds functions relevant to the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerPlayableDrawer">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="P:Animancer.IAnimancerComponent.Playable"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerPlayableDrawer._IsGraphPlaying">
            <summary>Only get <see cref="P:Animancer.AnimancerPlayable.IsGraphPlaying"/> during <see cref="F:UnityEngine.EventType.Layout"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerPlayableDrawer.LayerInfos">
            <summary>A lazy list of information about the layers currently being displayed.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerPlayableDrawer._LayerCount">
            <summary>The number of elements in <see cref="F:Animancer.Editor.AnimancerPlayableDrawer.LayerInfos"/> that are currently being used.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.DoGUI(Animancer.IAnimancerComponent[])">
            <summary>Draws the GUI of the <see cref="P:Animancer.IAnimancerComponent.Playable"/> if there is only one target.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.DoGUI(Animancer.IAnimancerComponent)">
            <summary>Draws the GUI of the <see cref="P:Animancer.IAnimancerComponent.Playable"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerStateDrawer`1">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.AnimancerState"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.#ctor(`0)">
            <summary>
            Constructs a new <see cref="T:Animancer.Editor.AnimancerStateDrawer`1"/> to manage the Inspector GUI for the `target`.
            </summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerStateDrawer`1.RegionStyle">
            <summary>The <see cref="T:UnityEngine.GUIStyle"/> used for the area encompassing this drawer. Null.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.DoLabelGUI(UnityEngine.Rect)">
            <summary>
            Draws the state's main label: an <see cref="T:UnityEngine.Object"/> field if it has a
            <see cref="P:Animancer.AnimancerState.MainObject"/>, otherwise just a simple text label.
            <para></para>
            Also shows a bar to indicate its progress.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.HandleLabelClick(UnityEngine.Rect)">
            <summary>
            Handles Ctrl + Click on the label to CrossFade the animation.
            <para></para>
            If Shift is also held, the effect will be queued until after the previous animation finishes.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.DoFoldoutGUI(UnityEngine.Rect)">
            <summary>Draws a foldout arrow to expand/collapse the state details.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerStateDrawer`1.AnimationQueue">
            <summary>
            Manages the playing of animations in sequence.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.AnimationQueue.CleanUp">
            <summary>
            Clear out any playables that have been destroyed.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.GetWrappedTime(System.Single@)">
            <summary>
            Gets the current <see cref="P:Animancer.AnimancerState.Time"/>.
            If the state is looping, the value is modulo by the <see cref="P:Animancer.AnimancerState.Length"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.DoDetailsGUI(Animancer.IAnimancerComponent)">
            <summary> Draws the details of the target state in the GUI.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.DoTimeSliderGUI">
            <summary>Draws a slider for controlling the current <see cref="P:Animancer.AnimancerState.Time"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.PopulateContextMenu(UnityEditor.GenericMenu)">
            <summary>Adds functions relevant to the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.AddContextMenuFunctions(UnityEditor.GenericMenu)">
            <summary>[Editor-Only]
            Adds the details of this state to the menu.
            By default, that means a single item showing the path of the <see cref="P:Animancer.AnimancerState.MainObject"/>.
            </summary>
        </member>
        <member name="T:Animancer.Editor.BaseAnimancerComponentEditor">
            <summary>[Editor-Only]
            A custom Inspector for <see cref="T:Animancer.IAnimancerComponent"/>s.
            </summary>
        </member>
        <member name="P:Animancer.Editor.BaseAnimancerComponentEditor.Targets">
            <summary><see cref="P:UnityEditor.Editor.targets"/> casted to <see cref="T:Animancer.IAnimancerComponent"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.BaseAnimancerComponentEditor._AnimatorEditor">
            <summary>The serialized backing field for the target's <see cref="T:UnityEngine.Animator"/> reference.</summary>
        </member>
        <member name="F:Animancer.Editor.BaseAnimancerComponentEditor.PlayableDrawer">
            <summary>The drawer for the <see cref="P:Animancer.IAnimancerComponent.Playable"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.OnEnable">
            <summary>Initialises this <see cref="T:UnityEditor.Editor"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.GatherTargets">
            <summary>
            Copies the <see cref="P:UnityEditor.Editor.targets"/> into the <see cref="F:Animancer.Editor.BaseAnimancerComponentEditor._Targets"/> array.
            </summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.OnDisable">
            <summary>
            Cleans up this <see cref="T:UnityEditor.Editor"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.OnInspectorGUI">
            <summary>
            Called by the Unity editor to draw the custom Inspector GUI elements.
            </summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.RequiresConstantRepaint">
            <summary>
            If we have only one object selected and are in Play Mode, we need to constantly repaint to keep the
            Inspector up to date with the latest details.
            </summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.DoOtherFieldsGUI">
            <summary>
            Draws the rest of the Inspector fields after the Animator field.
            </summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.DoOverridePropertyGUI(System.String,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>[Editor-Only]
            Draws any custom GUI for the `property`.
            The return value indicates whether the GUI should replace the regular call to
            <see cref="M:UnityEditor.EditorGUILayout.PropertyField(UnityEditor.SerializedProperty,UnityEngine.GUIContent,System.Boolean,UnityEngine.GUILayoutOption[])"/> or
            not. True = GUI was drawn, so don't draw the regular GUI. False = Draw the regular GUI.
            </summary>
        </member>
        <member name="T:Animancer.Editor.EventSequenceDrawer">
            <summary>[Editor-Only] Draws the Inspector GUI for <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.EventSequenceDrawer.Context">
            <summary>Details of an <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.EventSequenceDrawer.Context.Property">
            <summary>The main property representing the <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/> field.</summary>
        </member>
        <member name="P:Animancer.Editor.EventSequenceDrawer.Context.Times">
            <summary>The property representing the <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable._NormalizedTimes"/> field.</summary>
        </member>
        <member name="P:Animancer.Editor.EventSequenceDrawer.Context.TimeCount">
            <summary>The cached <see cref="P:UnityEditor.SerializedProperty.arraySize"/> of <see cref="P:Animancer.Editor.EventSequenceDrawer.Context.Times"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.Context.GetTime(System.Int32)">
            <summary>Shorthand for <see cref="M:UnityEditor.SerializedProperty.GetArrayElementAtIndex(System.Int32)"/> on <see cref="P:Animancer.Editor.EventSequenceDrawer.Context.Times"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.EventSequenceDrawer.Context.Callbacks">
            <summary>The property representing the <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable._Callbacks"/> field.</summary>
        </member>
        <member name="P:Animancer.Editor.EventSequenceDrawer.Context.CallbackCount">
            <summary>The cached <see cref="P:UnityEditor.SerializedProperty.arraySize"/> of <see cref="P:Animancer.Editor.EventSequenceDrawer.Context.Callbacks"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.Context.GetCallback(System.Int32)">
            <summary>Shorthand for <see cref="M:UnityEditor.SerializedProperty.GetArrayElementAtIndex(System.Int32)"/> on <see cref="P:Animancer.Editor.EventSequenceDrawer.Context.Callbacks"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.EventSequenceDrawer.Context.SelectedEvent">
            <summary>The index of the currently selected event.</summary>
        </member>
        <member name="F:Animancer.Editor.EventSequenceDrawer.Context.Instance">
            <summary>The singleton instance.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.Context.Get(UnityEditor.SerializedProperty)">
            <summary>
            Returns a <see cref="T:Animancer.Editor.EventSequenceDrawer.Context"/> representing the `property`.
            <para></para>
            Note that the same instance is returned every time.
            </summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.Context.Dispose">
            <summary>[<see cref="T:System.IDisposable"/>]
            Reduces the <see cref="P:Animancer.Editor.EventSequenceDrawer.Context.Callbacks"/> array size to remove any empty elements.
            </summary>
        </member>
        <member name="P:Animancer.Editor.EventSequenceDrawer.Context.TransitionContext">
            <summary>Shorthand for <see cref="P:Animancer.Editor.TransitionDrawer.Context"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            Calculates the number of vertical pixels the `property` will occupy when it is drawn.
            </summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>Draws the GUI for the `property`.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.DoAddEventButtonGUI(UnityEngine.Rect,Animancer.Editor.EventSequenceDrawer.Context)">
            <summary>Draws a button to add a new event.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.DoEventGUI(UnityEngine.Rect@,Animancer.Editor.EventSequenceDrawer.Context,System.Int32,System.Boolean,System.Boolean)">
            <summary>Draws the GUI fields for the event at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.DoEventTimeGUI(UnityEngine.Rect@,Animancer.Editor.EventSequenceDrawer.Context,System.Int32,System.Boolean,System.String@)">
            <summary>Draws the time field for the event at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.RemoveEvent(Animancer.Editor.EventSequenceDrawer.Context,System.Int32)">
            <summary>Removes the event at the specified `index`.</summary>
        </member>
        <member name="T:Animancer.Editor.NestedAnimatorEditor">
            <summary>[Editor-Only]
            A custom Inspector for drawing the <see cref="P:Animancer.IAnimancerComponent.Animator"/> nested inside its own Inspector.
            </summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor.Targets">
            <summary>The <see cref="T:Animancer.IAnimancerComponent"/> objects being edited.</summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor.AnimatorProperty">
            <summary>The property that serializes the <see cref="P:Animancer.IAnimancerComponent.Animator"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor._Animators">
            <summary>The animator referenced by each target.</summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor._IsAnimatorOnSameObject">
            <summary>
            Indicates whether all <see cref="F:Animancer.Editor.NestedAnimatorEditor._Animators"/> are on the same <see cref="T:UnityEngine.GameObject"/> as the target that
            is referencing them.
            </summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor._SerializedAnimator">
            <summary>A <see cref="T:UnityEditor.SerializedObject"/> encapsulating the <see cref="F:Animancer.Editor.NestedAnimatorEditor._Animators"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor._Controller">
            <summary>A <see cref="T:UnityEditor.SerializedProperty"/> of the <see cref="F:Animancer.Editor.NestedAnimatorEditor._SerializedAnimator"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor._Avatar">
            <summary>A <see cref="T:UnityEditor.SerializedProperty"/> of the <see cref="F:Animancer.Editor.NestedAnimatorEditor._SerializedAnimator"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor._RootMotion">
            <summary>A <see cref="T:UnityEditor.SerializedProperty"/> of the <see cref="F:Animancer.Editor.NestedAnimatorEditor._SerializedAnimator"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor._UpdateMode">
            <summary>A <see cref="T:UnityEditor.SerializedProperty"/> of the <see cref="F:Animancer.Editor.NestedAnimatorEditor._SerializedAnimator"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor._CullingMode">
            <summary>A <see cref="T:UnityEditor.SerializedProperty"/> of the <see cref="F:Animancer.Editor.NestedAnimatorEditor._SerializedAnimator"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.NestedAnimatorEditor.#ctor(Animancer.IAnimancerComponent[],UnityEditor.SerializedProperty)">
            <summary>
            Creates a new <see cref="T:Animancer.Editor.NestedAnimatorEditor"/> to wrap the `animatorProperty`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.NestedAnimatorEditor.Destroy">
            <summary>
            Cleans up this editor.
            </summary>
        </member>
        <member name="M:Animancer.Editor.NestedAnimatorEditor.GatherAnimatorProperties">
            <summary>
            Ensures that the <see cref="T:UnityEditor.SerializedObject"/> and properties for the <see cref="F:Animancer.Editor.NestedAnimatorEditor._Animators"/> have been
            initialised.
            </summary>
        </member>
        <member name="M:Animancer.Editor.NestedAnimatorEditor.GatherAnimators">
            <summary>Gathers the <see cref="F:Animancer.Editor.NestedAnimatorEditor._Animators"/> from the <see cref="F:Animancer.Editor.NestedAnimatorEditor.Targets"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.NestedAnimatorEditor.DoInspectorGUI">
            <summary>
            Draws the animator reference field followed by its fields that are relevant to Animancer.
            </summary>
        </member>
        <member name="M:Animancer.Editor.NestedAnimatorEditor.DoControllerGUI">
            <summary>
            Draws the <see cref="P:UnityEngine.Animator.runtimeAnimatorController"/> field with a warning if a controller is
            assigned.
            </summary>
        </member>
        <member name="M:Animancer.Editor.NestedAnimatorEditor.DoUpdateModeGUI(System.Boolean)">
            <summary>
            Draws the <see cref="P:UnityEngine.Animator.updateMode"/> field with any appropriate warnings.
            </summary>
        </member>
        <member name="M:Animancer.Editor.NestedAnimatorEditor.DoCullingModeGUI">
            <summary>
            Draws the <see cref="P:UnityEngine.Animator.cullingMode"/> field.
            </summary>
        </member>
        <member name="T:Animancer.Editor.ParametizedAnimancerStateDrawer`1">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.AnimancerState"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.ParametizedAnimancerStateDrawer`1.ParameterCount">
            <summary>The number of parameters being managed by the target state.</summary>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if the target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if the target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if the target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if the target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.#ctor(`0)">
            <summary>
            Constructs a new <see cref="T:Animancer.Editor.ParametizedAnimancerStateDrawer`1"/> to manage the Inspector GUI for the `state`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.DoDetailsGUI(Animancer.IAnimancerComponent)">
            <summary> Draws the details of the target state in the GUI.</summary>
        </member>
        <member name="T:Animancer.Editor.TimeRuler">
            <summary>[Editor-Only] Draws a GUI box denoting a period of time.</summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.BeginGUI(UnityEngine.Rect)">
            <summary>
            Sets the `area` in which the ruler will be drawn and draws a <see cref="M:UnityEngine.GUI.Box(UnityEngine.Rect,System.String)"/> there.
            Must be followed by a call to <see cref="M:Animancer.Editor.TimeRuler.EndGUI"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.EndGUI">
            <summary>
            Uses any unused <see cref="F:UnityEngine.EventType.MouseDown"/> events in the area and ends the area started by
            <see cref="M:Animancer.Editor.TimeRuler.BeginGUI(UnityEngine.Rect)"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.DoGUI(UnityEngine.Rect,Animancer.Editor.EventSequenceDrawer.Context)">
            <summary>
            Draws the ruler GUI and handles input events for the specified `context`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.DoFadeHighlightGUI">
            <summary>
            Draws a polygon describing the start, end, and fade details.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.DoEventsGUI(Animancer.Editor.EventSequenceDrawer.Context)">
            <summary>
            Draws the details of the <see cref="P:Animancer.Editor.EventSequenceDrawer.Context.Callbacks"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.DoRulerGUI">
            <summary>
            Draws ticks and labels for important times throughout the area.
            </summary>
        </member>
        <member name="T:Animancer.Editor.TransitionDrawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.AnimancerState.Transition`1"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.TransitionDrawer.Mode">
            <summary>The visual state of a drawer.</summary>
        </member>
        <member name="F:Animancer.Editor.TransitionDrawer._Mode">
            <summary>The current state of this drawer.</summary>
        </member>
        <member name="F:Animancer.Editor.TransitionDrawer.MainPropertyName">
            <summary>
            If set, the field with this name will be drawn with the foldout arrow instead of in its default place.
            </summary>
        </member>
        <member name="F:Animancer.Editor.TransitionDrawer.MainPropertyPathSuffix">
            <summary>
            "." + <see cref="F:Animancer.Editor.TransitionDrawer.MainPropertyName"/> (to avoid creating garbage repeatedly).
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.Editor.TransitionDrawer"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.#ctor(System.String)">
            <summary>
            Constructs a new <see cref="T:Animancer.Editor.TransitionDrawer"/> and sets the
            <see cref="F:Animancer.Editor.TransitionDrawer.MainPropertyName"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.GetMainProperty(UnityEditor.SerializedProperty)">
            <summary>
            Returns the property specified by the <see cref="F:Animancer.Editor.TransitionDrawer.MainPropertyName"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            Calculates the number of vertical pixels the `property` will occupy when it is drawn.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.InitialiseMode(UnityEditor.SerializedProperty)">
            <summary>
            If the <see cref="F:Animancer.Editor.TransitionDrawer._Mode"/> is <see cref="F:Animancer.Editor.TransitionDrawer.Mode.Uninitialised"/>, this method determines how it should start
            based on the number of properties in the `serializedObject`. If the only serialized field is an
            <see cref="T:Animancer.AnimancerState.Transition`1"/> then it should start expanded.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            Draws the root `property` GUI and calls <see cref="M:Animancer.Editor.TransitionDrawer.DoPropertyGUI(UnityEngine.Rect@,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/> for each of its children.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.DoPropertyGUI(UnityEngine.Rect@,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            Draws the `property` GUI in relation to the `rootProperty` which was passed into <see cref="M:Animancer.Editor.TransitionDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/>.
            </summary>
        </member>
        <member name="F:Animancer.Editor.TransitionDrawer.NormalizedStartTimeFieldName">
            <summary>The name of the backing field of <see cref="P:Animancer.ClipState.Transition.NormalizedStartTime"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.TryDoStartTimeField(UnityEngine.Rect@,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            If the `property` is a "Start Time" field, this method draws it as well as the "End Time" below it and
            returns true.
            </summary>
        </member>
        <member name="P:Animancer.Editor.TransitionDrawer.Context">
            <summary>The current <see cref="T:Animancer.Editor.TransitionDrawer.TransitionContext"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.TransitionDrawer.TransitionContext">
            <summary>Details of an <see cref="T:Animancer.AnimancerState.Transition`1"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionDrawer.TransitionContext.Property">
            <summary>The main property representing the <see cref="T:Animancer.AnimancerState.Transition`1"/> field.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionDrawer.TransitionContext.Transition">
            <summary>The actual transition object rerieved from the <see cref="P:Animancer.Editor.TransitionDrawer.TransitionContext.Property"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionDrawer.TransitionContext.MaximumDuration">
            <summary>The cached value of <see cref="P:Animancer.IAnimancerTransitionDetailed.MaximumDuration"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.TransitionContext.Get(Animancer.Editor.TransitionDrawer,UnityEditor.SerializedProperty)">
            <summary>
            Returns a disposable <see cref="T:Animancer.Editor.TransitionDrawer.TransitionContext"/> representing the specified parameters.
            <para></para>
            Note that the same instance is returned every time and it can be accessed via <see cref="P:Animancer.Editor.TransitionDrawer.Context"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.TransitionContext.Dispose">
            <summary>Clears the <see cref="P:Animancer.Editor.TransitionDrawer.Context"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.Serialization">
            <summary>[Editor-Only] Various serialization utilities.</summary>
            <summary>[Editor-Only] Various serialization utilities.</summary>
            <summary>[Editor-Only] Various serialization utilities.</summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.ArrayDataPrefix">
            <summary>The text used in a <see cref="P:UnityEditor.SerializedProperty.propertyPath"/> to denote array elements.</summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.ArrayDataSuffix">
            <summary>The text used in a <see cref="P:UnityEditor.SerializedProperty.propertyPath"/> to denote array elements.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetFriendlyPath(UnityEditor.SerializedProperty)">
            <summary>Returns a user friendly version of the <see cref="P:UnityEditor.SerializedProperty.propertyPath"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetValue(UnityEditor.SerializedProperty,System.Object)">
            <summary>Gets the value of the specified <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetValue(UnityEditor.SerializedProperty)">
            <summary>Gets the value of the <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetValue``1(UnityEditor.SerializedProperty)">
            <summary>Gets the value of the <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetValue``1(UnityEditor.SerializedProperty,``0@)">
            <summary>Gets the value of the <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetValues``1(UnityEditor.SerializedProperty)">
            <summary>Gets the value of the <see cref="T:UnityEditor.SerializedProperty"/> for each of its target objects.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.SetValue(UnityEditor.SerializedProperty,System.Object,System.Object)">
            <summary>Sets the value of the specified <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.SetValue(UnityEditor.SerializedProperty,System.Object)">
            <summary>Sets the value of the <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.AreSameProperty(UnityEditor.SerializedProperty,UnityEditor.SerializedProperty)">
            <summary>Indicates whether both properties refer to the same underlying field.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ForEachTarget(UnityEditor.SerializedProperty,System.Action{UnityEditor.SerializedProperty},System.String)">
            <summary>
            Executes the `action` once with a new <see cref="T:UnityEditor.SerializedProperty"/> for each of the
            <see cref="P:UnityEditor.SerializedObject.targetObjects"/>. Or if there is only one target, it uses the `property`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.AddPropertyModifierFunction(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,System.String,System.Action{UnityEditor.SerializedProperty})">
            <summary>
            Adds a menu item to execute the specified `action` for each of the `property`s target objects.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ModifyValues``1(UnityEditor.SerializedProperty,System.Action{``0},System.String)">
            <summary>
            Calls the specified `method` for each of the underlying values of the `property` (in case it represents
            multiple selected objects) and records an undo step for any modifications made.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.RecordUndo(UnityEditor.SerializedProperty,System.String)">
            <summary>
            Records the state of the specified `property` so it can be undone.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.OnPropertyChanged(UnityEditor.SerializedProperty)">
            <summary>
            Updates the specified `property` and marks its target objects as dirty so any changes to a prefab will be saved.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetPropertyType(System.Type)">
            <summary>
            Returns the <see cref="T:UnityEditor.SerializedPropertyType"/> that represents fields of the specified `type`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetAccessor(UnityEditor.SerializedProperty)">
            <summary>
            Returns an <see cref="T:Animancer.Editor.Serialization.PropertyAccessor"/> that can be used to access the details of the specified `property`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetAccessor(System.String,System.Type@)">
            <summary>
            Returns an <see cref="T:Animancer.Editor.Serialization.PropertyAccessor"/> for a <see cref="T:UnityEditor.SerializedProperty"/> with the specified `propertyPath`
            on the specified `type` of object.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetField(System.Type,System.String)">
            <summary>
            Returns a field with the specified `name` in the `declaringType` or any of its base types.
            </summary>
        </member>
        <member name="T:Animancer.Editor.Serialization.PropertyAccessor">
            <summary>[Editor-Only]
            A wrapper for accessing the underlying values and fields of a <see cref="T:UnityEditor.SerializedProperty"/>.
            </summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.PropertyAccessor.Parent">
            <summary>The accessor for the field which this accessor is nested inside.</summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.PropertyAccessor.Field">
            <summary>The field wrapped by this accessor.</summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.PropertyAccessor.FieldType">
            <summary>The type of the wrapped <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.#ctor(Animancer.Editor.Serialization.PropertyAccessor,System.Reflection.FieldInfo)">
            <summary>[Internal] Creates a new <see cref="T:Animancer.Editor.Serialization.PropertyAccessor"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.#ctor(Animancer.Editor.Serialization.PropertyAccessor,System.Reflection.FieldInfo,System.Type)">
            <summary>Creates a new <see cref="T:Animancer.Editor.Serialization.PropertyAccessor"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetValue(System.Object)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to get and return
            the value of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetValue(UnityEditor.SerializedObject)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to get and return
            the value of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetValue(UnityEditor.SerializedProperty)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to get and return
            the value of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.SetValue(System.Object,System.Object)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to set the value
            of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.SetValue(UnityEditor.SerializedObject,System.Object)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to set the value
            of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.SetValue(UnityEditor.SerializedProperty,System.Object)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to set the value
            of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.ToString">
            <summary>Returns a description of this accessor's path.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetPath">
            <summary>Returns a this accessor's <see cref="P:UnityEditor.SerializedProperty.propertyPath"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.Serialization.ArrayPropertyAccessor">
            <summary>[Editor-Only]
            An <see cref="T:Animancer.Editor.Serialization.PropertyAccessor"/> for a particular element in an array.
            </summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.ArrayPropertyAccessor.ElementIndex">
            <summary>The index of the array element this accessor targets.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ArrayPropertyAccessor.#ctor(Animancer.Editor.Serialization.PropertyAccessor,System.Reflection.FieldInfo,System.Int32)">
            <summary>[Internal] Creates a new <see cref="T:Animancer.Editor.Serialization.ArrayPropertyAccessor"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ArrayPropertyAccessor.GetElementType(System.Type)">
            <summary>Returns the type of elements in the array.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ArrayPropertyAccessor.GetValue(System.Object)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to
            get and return the value of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ArrayPropertyAccessor.SetValue(System.Object,System.Object)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to
            set the value of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ArrayPropertyAccessor.ToString">
            <summary>Returns a description of this accessor's path.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ArrayPropertyAccessor.GetPath">
            <summary>Returns a this accessor's <see cref="P:UnityEditor.SerializedProperty.propertyPath"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.Serialization.ObjectReference">
            <summary>[Editor-Only]
            Directly serializing an <see cref="T:UnityEngine.Object"/> reference doesn't always work (such as with scene
            objects when entering Play Mode), so this class also serialized their instance ID and uses that if the direct
            reference fails.
            </summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.ObjectReference.Object">
            <summary>The referenced <see cref="T:UnityEditor.SerializedObject"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.ObjectReference.InstanceID">
            <summary>The <see cref="M:UnityEngine.Object.GetInstanceID"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.#ctor(UnityEngine.Object)">
            <summary>
            Constructs a new <see cref="T:Animancer.Editor.Serialization.ObjectReference"/> which wraps the specified
            <see cref="T:UnityEngine.Object"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.op_Implicit(UnityEngine.Object)~Animancer.Editor.Serialization.ObjectReference">
            <summary>
            Constructs a new <see cref="T:Animancer.Editor.Serialization.ObjectReference"/> which wraps the specified
            <see cref="T:UnityEngine.Object"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.op_Implicit(Animancer.Editor.Serialization.ObjectReference)~UnityEngine.Object">
            <summary>
            Returns the target <see cref="P:Animancer.Editor.Serialization.ObjectReference.Object"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.Convert(UnityEngine.Object[])">
            <summary>
            Creates a new array of <see cref="T:Animancer.Editor.Serialization.ObjectReference"/>s representing the `objects`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.Convert(Animancer.Editor.Serialization.ObjectReference[])">
            <summary>
            Creates a new array of <see cref="T:UnityEngine.Object"/>s containing the target <see cref="P:Animancer.Editor.Serialization.ObjectReference.Object"/> of each
            of the `references`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.AreSameObjects(Animancer.Editor.Serialization.ObjectReference[],UnityEngine.Object[])">
            <summary>
            Indicates whether both arrays refer to the same set of objects.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.ToString">
            <summary>Returns a string describing this object.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.IsValid(Animancer.Editor.Serialization.ObjectReference)">
            <summary>Returns true if the `reference` and <see cref="P:Animancer.Editor.Serialization.ObjectReference.Object"/> are not null.</summary>
        </member>
        <member name="T:Animancer.Editor.Serialization.PropertyReference">
            <summary>[Editor-Only]
            A serializable reference to a <see cref="T:UnityEditor.SerializedProperty"/>.
            </summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.TargetObject">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The <see cref="P:UnityEditor.SerializedObject.targetObject"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.TargetObjects">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The <see cref="P:UnityEditor.SerializedObject.targetObjects"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.Context">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The <see cref="P:UnityEditor.SerializedObject.context"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.PropertyPath">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The <see cref="P:UnityEditor.SerializedProperty.propertyPath"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.IsInitialised">
            <summary>Indicates whether the <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/> has been accessed.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.Property">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The referenced <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.#ctor(UnityEditor.SerializedProperty)">
            <summary>
            Constructs a new <see cref="T:Animancer.Editor.Serialization.PropertyReference"/> which wraps the specified `property`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.op_Implicit(UnityEditor.SerializedProperty)~Animancer.Editor.Serialization.PropertyReference">
            <summary>
            Constructs a new <see cref="T:Animancer.Editor.Serialization.PropertyReference"/> which wraps the specified `property`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.op_Implicit(Animancer.Editor.Serialization.PropertyReference)~UnityEditor.SerializedProperty">
            <summary>
            Returns the target <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.IsTarget(UnityEditor.SerializedProperty,UnityEngine.Object[])">
            <summary>
            Returns true if the specified property and objects match the targets of this reference.
            </summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.TargetsExist">
            <summary>
            Returns true if there is at least one target and none of them are null.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.Update">
            <summary>
            Calls <see cref="M:UnityEditor.SerializedObject.Update"/> if the <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/> has been initialised.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.ApplyModifiedProperties">
            <summary>
            Calls <see cref="M:UnityEditor.SerializedObject.ApplyModifiedProperties"/> if the <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/> has been initialised.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.Dispose">
            <summary>
            Calls <see cref="M:UnityEditor.SerializedObject.Dispose"/> if the <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/> has been initialised.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.GetPropertyHeight">
            <summary>Gets the height needed to draw the target property.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.DoTargetGUI(UnityEngine.Rect)">
            <summary>Draws the target object within the specified `area`.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.DoPropertyGUI(UnityEngine.Rect)">
            <summary>Draws the target property within the specified `area`.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.IsValid(Animancer.Editor.Serialization.PropertyReference)">
            <summary>Returns true if the `reference` and <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/> are not null.</summary>
        </member>
        <member name="T:Animancer.Editor.TemporarySettings">
            <summary>[Editor-Only]
            Stores data which needs to survive assembly reloading (such as from script compilation), but can be discarded
            when the Unity Editor is closed.
            </summary>
        </member>
        <member name="T:Animancer.Editor.TransitionPreviewWindow">
            <summary>[Editor-Only] [Pro-Only]
            An <see cref="T:UnityEditor.EditorWindow"/> which allows the user to preview animation transitions separately from the rest
            of the scene in Edit Mode or Play Mode.
            </summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.Icon">
            <summary>The icon image used by this window.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.Open(UnityEditor.SerializedProperty)">
            <summary>Focusses the <see cref="T:Animancer.Editor.TransitionPreviewWindow"/> or creates one if none exists.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.SetPreviewNormalizedTime(System.Single)">
            <summary>
            Sets the <see cref="P:Animancer.AnimancerState.NormalizedTime"/> of the current transition if the property being
            previewed matches the <see cref="P:Animancer.Editor.TransitionDrawer.Context"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.GetPreviewTime(System.Boolean@)">
            <summary>
            Returns the <see cref="P:Animancer.AnimancerState.Time"/> of the current transition if the property being
            previewed matches the <see cref="P:Animancer.Editor.TransitionDrawer.Context"/>. Otherwise returns <see cref="F:System.Single.NaN"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.CanBePreviewed(UnityEditor.SerializedProperty)">
            <summary>Indicates whether the `property` is able to be previewed by this system.</summary>
        </member>
        <member name="F:Animancer.Editor.SoloAnimationEditor._Animators">
            <summary>The animator referenced by each target.</summary>
        </member>
        <member name="F:Animancer.Editor.SoloAnimationEditor._SerializedAnimator">
            <summary>A <see cref="T:UnityEditor.SerializedObject"/> encapsulating the <see cref="F:Animancer.Editor.SoloAnimationEditor._Animators"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.SoloAnimationEditor._KeepStateOnDisable">
            <summary>The <see cref="P:UnityEngine.Animator.keepAnimatorControllerStateOnDisable"/> property.</summary>
        </member>
        <member name="M:Animancer.Editor.SoloAnimationEditor.DoSerializedFieldsGUI">
            <summary>
            Draws the target's serialized fields.
            </summary>
        </member>
        <member name="M:Animancer.Editor.SoloAnimationEditor.DoStopOnDisableGUI">
            <summary>
            Draws a toggle inverted from the <see cref="P:UnityEngine.Animator.keepAnimatorControllerStateOnDisable"/> field.
            </summary>
        </member>
        <member name="M:Animancer.Editor.SoloAnimationEditor.DoRuntimeDetailsGUI">
            <summary>Draws the target's runtime details.</summary>
        </member>
        <member name="T:Animancer.AnimancerLayer">
            <summary>
            A layer on which animations can play with their states managed independantly of other layers while blending the
            output with those layers.
            <para></para>
            This class can be used as a custom yield instruction to wait until all animations finish playing.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.#ctor(Animancer.AnimancerPlayable,System.Int32)">
            <summary>[Internal] Constructs a new <see cref="T:Animancer.AnimancerLayer"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.Layer">
            <summary>A layer is its own root.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.Parent">
            <summary>The <see cref="F:Animancer.AnimancerNode.Root"/> receives the output of the <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.KeepChildrenConnected">
            <summary>Indicates whether child playables should stay connected to this mixer at all times.</summary>
        </member>
        <member name="F:Animancer.AnimancerLayer.States">
            <summary>All of the animation states connected to this layer.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.CurrentState">
            <summary>
            The state of the animation currently being played.
            <para></para>
            Specifically, this is the state that was most recently started using any of the Play or CrossFade methods
            on this layer. States controlled individually via methods in the <see cref="T:Animancer.AnimancerState"/> itself will
            not register in this property.
            <para></para>
            Each time this property changes, the <see cref="P:Animancer.AnimancerLayer.CommandCount"/> is incremented.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.CommandCount">
            <summary>
            The number of times the <see cref="P:Animancer.AnimancerLayer.CurrentState"/> has changed. By storing this value and later comparing
            the stored value to the current value, you can determine whether the state has been changed since then,
            even it has changed back to the same state.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.IsAdditive">
            <summary>[Pro-Only]
            Determines whether this layer is set to additive blending. Otherwise it will override any earlier layers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.SetMask(UnityEngine.AvatarMask)">
            <summary>[Pro-Only]
            Sets an <see cref="T:UnityEngine.AvatarMask"/> to determine which bones this layer will affect.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerLayer._Mask">
            <summary>[Editor-Only]
            The <see cref="T:UnityEngine.AvatarMask"/> that determines which bones this layer will affect.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.AverageVelocity">
            <summary>
            The average velocity of the root motion of all currently playing animations, taking their current
            <see cref="P:Animancer.AnimancerNode.Weight"/> into account.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.ChildCount">
            <summary>The number of states using this layer as their <see cref="P:Animancer.AnimancerState.Parent"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetChild(System.Int32)">
            <summary>Returns the state connected to the specified `index` as a child of this layer.</summary>
            <remarks>This method is identical to <see cref="P:Animancer.AnimancerLayer.Item(System.Int32)"/>.</remarks>
        </member>
        <member name="P:Animancer.AnimancerLayer.Item(System.Int32)">
            <summary>Returns the state connected to the specified `index` as a child of this layer.</summary>
            <remarks>This indexer is identical to <see cref="M:Animancer.AnimancerLayer.GetChild(System.Int32)"/>.</remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.AddChild(Animancer.AnimancerState)">
            <summary>
            Adds a new port and uses <see cref="M:Animancer.AnimancerState.SetParent(Animancer.AnimancerNode,System.Int32)"/> to connect the `state` to it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.OnAddChild(Animancer.AnimancerState)">
            <summary>Connects the `state` to this layer at its <see cref="P:Animancer.AnimancerNode.Index"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.OnRemoveChild(Animancer.AnimancerState)">
            <summary>Disconnects the `state` from this layer at its <see cref="P:Animancer.AnimancerNode.Index"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetEnumerator">
            <summary>
            Returns an enumerator that will iterate through all states connected directly to this layer (not inside
            <see cref="T:Animancer.MixerState"/>s).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateState(System.Object,UnityEngine.AnimationClip)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip` and registers it with the `key`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip[])">
            <summary>
            Calls <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetOrCreateState(UnityEngine.AnimationClip,System.Boolean)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)"/> and returns the state which registered with that key or
            creates one if it doesn't exist.
            <para></para>
            If the state already exists but has the wrong <see cref="P:Animancer.AnimancerState.Clip"/>, the `allowSetClip`
            parameter determines what will happen. False causes it to throw an <see cref="T:System.ArgumentException"/> while
            true allows it to change the <see cref="P:Animancer.AnimancerState.Clip"/>. Note that the change is somewhat costly to
            performance to use with caution.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetOrCreateState(Animancer.IAnimancerTransition)">
            <summary>
            Returns the state registered with the <see cref="P:Animancer.IHasKey.Key"/> if there is one. Otherwise
            this method uses <see cref="M:Animancer.IAnimancerTransition.CreateState(Animancer.AnimancerLayer)"/> to create a new one and registers it with
            that key before returning it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetOrCreateState(System.Object,UnityEngine.AnimationClip,System.Boolean)">
            <summary>
            Returns the state which registered with the `key` or creates one if it doesn't exist.
            <para></para>
            If the state already exists but has the wrong <see cref="P:Animancer.AnimancerState.Clip"/>, the `allowSetClip`
            parameter determines what will happen. False causes it to throw an <see cref="T:System.ArgumentException"/> while
            true allows it to change the <see cref="P:Animancer.AnimancerState.Clip"/>. Note that the change is somewhat costly to
            performance to use with caution.
            <seealso cref="T:Animancer.AnimancerState"/>
            </summary>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:System.ArgumentNullException">Thrown if the `key` is null.</exception>
            <remarks>
            See also: <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(System.Object,UnityEngine.AnimationClip,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.DestroyStates">
            <summary>
            Destroys all states connected to this layer. This operation cannot be undone.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.OnStartFade">
            <summary>
            Called by <see cref="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)"/> (when this layer starts fading, not when one of its states
            starts fading). Clears the <see cref="P:Animancer.AnimancerState.Events"/> of all states.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(UnityEngine.AnimationClip)">
            <summary>
            Stops all other animations, plays the `clip`, and returns its state.
            <para></para>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            To restart it from the beginning you can use <c>...Play(clip).Time = 0;</c>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState)">
            <summary>
            Stops all other animations, plays the `state`, and returns it.
            <para></para>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            If you wish to force it back to the start, you can simply set the `state`s time to 0.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(Animancer.IAnimancerTransition)">
            <summary>
            Creates a state for the `transition` if it didn't already exist, then calls
            <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState)"/> or <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/>
            depending on <see cref="P:Animancer.IAnimancerTransition.CrossFadeFromStart"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(System.Object)">
            <summary>
            Stops all other animations, plays the animation registered with the `key`, and returns that
            state. If no state is registered with the `key`, this method does nothing and returns null.
            <para></para>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            If you wish to force it back to the start, you can simply set the returned state's time to 0.
            on the returned state.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(UnityEngine.AnimationClip,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the `clip` over the course of the `fadeDuration` while fading out all others in the same
            layer. Returns its state.
            <para></para>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the `state` over the course of the `fadeDuration` while fading out all others in this
            layer. Returns the `state`.
            <para></para>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(Animancer.IAnimancerTransition,System.Single,Animancer.FadeMode)">
            <summary>
            Creates a state for the `transition` if it didn't already exist, then calls
            <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState)"/> or <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/>
            depending on <see cref="P:Animancer.IAnimancerTransition.CrossFadeFromStart"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(System.Object,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the animation registered with the `key` over the course of the `fadeDuration` while fading
            out all others in the same layer. Returns the animation's state (or null if none was registered).
            <para></para>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.EvaluateFadeMode(Animancer.FadeMode,Animancer.AnimancerState@,System.Single@,System.Boolean@)">
            <summary>
            Manipulates the other parameters according to the `mode`.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerLayer.maxStateDepth">
            <summary>[Editor-Only]
            The maximum number of duplicate states that can be created by <see cref="M:Animancer.AnimancerLayer.GetOrCreateWeightlessState(Animancer.AnimancerState)"/> for
            a single clip before it will start giving usage warnings. Default = 5.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetOrCreateWeightlessState(Animancer.AnimancerState)">
            <summary>
            If the `state` isn't currently at 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method finds a copy of it that
            is or creates a new one. States created for this purpose are cached so they can be reused in the future.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the <see cref="P:Animancer.AnimancerState.Clip"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if more states have been created for this <see cref="P:Animancer.AnimancerState.Clip"/> than the
            <see cref="F:Animancer.AnimancerLayer.maxStateDepth"/> allows.
            </exception>
        </member>
        <member name="M:Animancer.AnimancerLayer.Stop">
            <summary>
            Sets <see cref="P:Animancer.AnimancerNode.Weight"/> = 0 and calls <see cref="M:Animancer.AnimancerState.Stop"/> on all animations
            to stop them from playing and rewind them to the start.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.IsPlayingClip(UnityEngine.AnimationClip)">
            <summary>
            Returns true if the `clip` is currently being played by at least one state.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.IsAnyStatePlaying">
            <summary>
            Returns true if at least one animation is being played.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.IsPlayingAndNotEnding">
            <summary>
            Returns true if the <see cref="P:Animancer.AnimancerLayer.CurrentState"/> is playing and hasn't yet reached its end.
            <para></para>
            This method is called by <see cref="M:System.Collections.IEnumerator.MoveNext"/> so this object can be used as a custom yield
            instruction to wait until it finishes.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetTotalWeight">
            <summary>
            Calculates the total <see cref="P:Animancer.AnimancerNode.Weight"/> of all states in this layer.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.TryInvokeOnEndEvent(UnityEngine.AnimationEvent)">
            <summary>
            Invokes the <see cref="P:Animancer.AnimancerEvent.Sequence.OnEnd"/> callback of the state that is playing the animation
            which triggered the event. Returns true if such a state exists (even if it doesn't have a callback).
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.DefaultApplyAnimatorIK">
            <summary>
            Determines the default value of <see cref="P:Animancer.AnimancerState.ApplyAnimatorIK"/> for all new states created in
            this layer. Default false.
            <para></para>
            It requires Unity 2018.1 or newer, however 2018.3 or newer is recommended because a bug in earlier versions
            of the Playables API caused this value to only take effect while at least one state was at
            <see cref="P:Animancer.AnimancerNode.Weight"/> = 1 which meant that IK would not work while fading between animations.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.ApplyAnimatorIK">
            <summary>
            Determines whether <c>OnAnimatorIK(int layerIndex)</c> will be called on the animated object for any
            <see cref="F:Animancer.AnimancerLayer.States"/>. The initial value is determined by <see cref="P:Animancer.AnimancerLayer.DefaultApplyAnimatorIK"/> when a new
            state is created and setting this value will also set the default.
            <para></para>
            This is equivalent to the "IK Pass" toggle in Animator Controller layers, except that due to limitations in
            the Playables API the <c>layerIndex</c> will always be zero.
            <para></para>
            It requires Unity 2018.1 or newer, however 2018.3 or newer is recommended because a bug in earlier versions
            of the Playables API caused this value to only take effect while at least one state was at
            <see cref="P:Animancer.AnimancerNode.Weight"/> = 1 which meant that IK would not work while fading between animations.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.DefaultApplyFootIK">
            <summary>
            Determines the default value of <see cref="P:Animancer.AnimancerState.ApplyFootIK"/> for all new states created in this
            layer. Default false.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.ApplyFootIK">
            <summary>
            Determines whether any of the <see cref="F:Animancer.AnimancerLayer.States"/> in this layer are applying IK to the character's feet.
            The initial value is determined by <see cref="P:Animancer.AnimancerLayer.DefaultApplyFootIK"/> when a new state is created.
            <para></para>
            This is equivalent to the "Foot IK" toggle in Animator Controller states (applied to the whole layer).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>]
            Gathers all the animations in this layer.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerLayer._Name">
            <summary>[Editor-Only] The Inspector display name of this layer.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.ToString">
            <summary>The Inspector display name of this layer.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.SetName(System.String)">
            <summary>[Editor-Conditional]
            Sets the Inspector display name of this layer. Note that layer names are Editor-Only so any calls to this
            method will automatically be compiled out of a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.AppendDetails(System.Text.StringBuilder,System.String)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerNode.AppendDescription(System.Text.StringBuilder,System.Int32,System.String)"/> to append the details of this node.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerNode">
            <summary>
            Base class for <see cref="T:UnityEngine.Playables.Playable"/> wrapper objects in <see cref="N:Animancer"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerNode._Playable">
            <summary>
            The internal struct this state manages in the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            <para></para>
            Should be set in the child class constructor. Failure to do so will throw the following exception
            throughout the system when using this node: "<see cref="T:System.ArgumentException"/>: The playable passed as an
            argument is invalid. To create a valid playable, please use the appropriate Create method".
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Animancer#IPlayableWrapper#Playable">
            <summary>[Internal] The <see cref="T:UnityEngine.Playables.Playable"/> managed by this object.</summary>
        </member>
        <member name="F:Animancer.AnimancerNode.Root">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> at the root of the graph.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Layer">
            <summary>The root <see cref="T:Animancer.AnimancerLayer"/> which this node is connected to.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Parent">
            <summary>The object which receives the output of this node.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Index">
            <summary>
            The index of the port this node is connected to on the parent's <see cref="T:UnityEngine.Playables.Playable"/>.
            <para></para>
            A negative value indicates that it is not assigned to a port.
            </summary>
            <remarks>
            Indices are generally assigned starting from 0, ascending in the order they are connected to their layer.
            They won't usually change unless the <see cref="P:Animancer.AnimancerNode.Parent"/> changes or another state on the same layer is
            destroyed so the last state is swapped into its place to avoid shuffling everything down to cover the gap.
            <para></para>
            The setter is internal so user defined states can't set it incorrectly. Ideally,
            <see cref="T:Animancer.AnimancerLayer"/> should be able to set the port in its constructor and
            <see cref="M:Animancer.AnimancerState.SetParent(Animancer.AnimancerNode,System.Int32)"/> should also be able to set it, but classes that further inherit from
            there should not be able to change it without properly calling that method.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerNode.#ctor(Animancer.AnimancerPlayable)">
            <summary>Constructs a new <see cref="T:Animancer.AnimancerNode"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.ChildCount">
            <summary>The number of states using this node as their <see cref="P:Animancer.AnimancerState.Parent"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.GetChild(System.Int32)">
            <summary>
            Returns the state connected to the specified `index` as a child of this node.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if this node can't have children.</exception>
        </member>
        <member name="M:Animancer.AnimancerNode.OnAddChild(Animancer.AnimancerState)">
            <summary>
            Called when a child is connected with this node as its <see cref="P:Animancer.AnimancerState.Parent"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if this node can't have children.</exception>
        </member>
        <member name="M:Animancer.AnimancerNode.OnRemoveChild(Animancer.AnimancerState)">
            <summary>
            Called when a child's <see cref="P:Animancer.AnimancerState.Parent"/> is changed from this node to something else.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if this node can't have children.</exception>
        </member>
        <member name="M:Animancer.AnimancerNode.OnAddChild(System.Collections.Generic.IList{Animancer.AnimancerState},Animancer.AnimancerState)">
            <summary>Connects the `state` to the `mixer` at its <see cref="P:Animancer.AnimancerNode.Index"/>.</summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the <see cref="P:Animancer.AnimancerNode.Index"/> was already occupied.</exception>
        </member>
        <member name="M:Animancer.AnimancerNode.OnChildDestroyed(Animancer.AnimancerState)">
            <summary>[Internal]
            Called by <see cref="M:Animancer.AnimancerState.Destroy"/> for any states connected to this mixer.
            Adds the `state`s port to a list of spares to be reused by another state and notifies the root
            <see cref="T:Animancer.AnimancerPlayable"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.ConnectToGraph">
            <summary>
            Connects the <see cref="F:Animancer.AnimancerNode._Playable"/> to the <see cref="P:Animancer.AnimancerNode.Parent"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.DisconnectFromGraph">
            <summary>
            Disconnects the <see cref="F:Animancer.AnimancerNode._Playable"/> from the <see cref="P:Animancer.AnimancerNode.Parent"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.KeepChildrenConnected">
            <summary>
            Indicates whether child playables should stay connected to this mixer at all times (default false).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.ConnectAllChildrenToGraph">
            <summary>
            Ensures that all children of this node are connected to the <see cref="F:Animancer.AnimancerNode._Playable"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.DisconnectWeightlessChildrenFromGraph">
            <summary>
            Ensures that all children of this node which have zero weight are disconnected from the
            <see cref="F:Animancer.AnimancerNode._Playable"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.IsValid">
            <summary>
            Indicates whether the <see cref="F:Animancer.AnimancerNode._Playable"/> is usable (properly initialised and not destroyed).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.GetEnumerator">
            <summary>Gets an enumerator for all of this node's child states.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.IsPlayingAndNotEnding">
            <summary>
            Returns true if the animation is playing and hasn't yet reached its end.
            <para></para>
            This method is called by <see cref="M:System.Collections.IEnumerator.MoveNext"/> so this object can be used as a custom yield
            instruction to wait until it finishes.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.System#Collections#IEnumerator#MoveNext">
            <summary>Calls <see cref="M:Animancer.AnimancerNode.IsPlayingAndNotEnding"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.System#Collections#IEnumerator#Current">
            <summary>Returns null.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.System#Collections#IEnumerator#Reset">
            <summary>Does nothing.</summary>
        </member>
        <member name="F:Animancer.AnimancerNode._Weight">
            <summary>The current blend weight of this node. Accessed via <see cref="P:Animancer.AnimancerNode.Weight"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerNode._IsWeightDirty">
            <summary>Indicates whether the weight has changed and should be applied to the parent mixer.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Weight">
             <summary>
             The current blend weight of this node which determines how much it affects the final output. 0 has no
             effect while 1 applies the full effect of this node and values inbetween apply a proportional effect.
             <para></para>
             Setting this property cancels any fade currently in progress. If you don't wish to do that, you can use
             <see cref="M:Animancer.AnimancerNode.SetWeight(System.Single)"/> instead.
             <para></para>
             Animancer Lite only allows this value to be set to 0 or 1 in a runtime build.
             </summary>
            
             <example>
             Calling <see cref="M:Animancer.AnimancerPlayable.Play(UnityEngine.AnimationClip)"/> immediately sets the weight of all states to 0
             and the new state to 1. Note that this is separate from other values like
             <see cref="P:Animancer.AnimancerState.IsPlaying"/> so a state can be paused at any point and still show its pose on the
             character or it could be still playing at 0 weight if you want it to still trigger events (though states
             are normally stopped when they reach 0 weight so you would need to explicitly set it to playing again).
             <para></para>
             Calling <see cref="M:Animancer.AnimancerPlayable.Play(UnityEngine.AnimationClip,System.Single,Animancer.FadeMode)"/> does not immediately change
             the weights, but instead calls <see cref="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)"/> on every state to set their
             <see cref="P:Animancer.AnimancerNode.TargetWeight"/> and <see cref="P:Animancer.AnimancerNode.FadeSpeed"/>. Then every update each state's weight will move
             towards that target value at that speed.
             </example>
        </member>
        <member name="M:Animancer.AnimancerNode.SetWeight(System.Single)">
            <summary>
            Sets the current blend weight of this node which determines how much it affects the final output.
            0 has no effect while 1 applies the full effect of this node.
            <para></para>
            This method allows any fade currently in progress to continue. If you don't wish to do that, you can set
            the <see cref="P:Animancer.AnimancerNode.Weight"/> property instead.
            <para></para>
            Animancer Lite only allows this value to be set to 0 or 1 in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.SetWeightDirty">
            <summary>
            Flags this node as having a dirty weight that needs to be applied next update.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.ApplyWeight">
            <summary>[Internal]
            Applies the <see cref="P:Animancer.AnimancerNode.Weight"/> to the connection between this node and its <see cref="P:Animancer.AnimancerNode.Parent"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.TargetWeight">
            <summary>
            The desired <see cref="P:Animancer.AnimancerNode.Weight"/> which this node is fading towards according to the
            <see cref="P:Animancer.AnimancerNode.FadeSpeed"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.FadeSpeed">
            <summary>
            The speed at which this node is fading towards the <see cref="P:Animancer.AnimancerNode.TargetWeight"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerNode.OnStartFade"/> and starts fading the <see cref="P:Animancer.AnimancerNode.Weight"/> over the course
            of the `fadeDuration` (in seconds).
            <para></para>
            If the `targetWeight` is 0 then <see cref="M:Animancer.AnimancerNode.Stop"/> will be called when the fade is complete.
            <para></para>
            If the <see cref="P:Animancer.AnimancerNode.Weight"/> is already equal to the `targetWeight` then the fade will end
            immediately.
            <para></para>
            Animancer Lite only allows a `targetWeight` of 0 or 1 and the default `fadeDuration` in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.OnStartFade">
            <summary>
            Called by <see cref="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.Stop">
            <summary>
            Stops the animation and makes it inactive immediately so it no longer affects the output.
            Sets <see cref="P:Animancer.AnimancerNode.Weight"/> = 0 by default.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.UpdateFade(System.Boolean@)">
            <summary>
            Moves the <see cref="P:Animancer.AnimancerNode.Weight"/> towards the <see cref="P:Animancer.AnimancerNode.TargetWeight"/> according to the
            <see cref="P:Animancer.AnimancerNode.FadeSpeed"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.Update(System.Boolean@)">
            <summary>
            Updates the <see cref="P:Animancer.AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent mixer, and plays
            or pauses the <see cref="T:UnityEngine.Playables.Playable"/> if its state is dirty.
            <para></para>
            If the <see cref="P:Animancer.AnimancerNode.Parent"/>'s <see cref="P:Animancer.AnimancerNode.KeepChildrenConnected"/> is set to false, this method will
            also connect/disconnect this node from the <see cref="P:Animancer.AnimancerNode.Parent"/> in the playable graph.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerNode._IsInspectorExpanded">
            <summary>[Editor-Only] [Internal] Indicates whether the Inspector details for this node are expanded.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Speed">
             <summary>
             How fast the <see cref="P:Animancer.AnimancerState.Time"/> is advancing every frame.
             <para></para>
             1 is the normal speed.
             <para></para>
             A negative value will play the animation backwards.
             <para></para>
             Animancer Lite does not allow this value to be changed in a runtime build.
             </summary>
            
             <example>
             <code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 state.Speed = 1;// Normal speed.
                 state.Speed = 2;// Double speed.
                 state.Speed = 0.5f;// Half speed.
                 state.Speed = -1;// Normal speed playing backwards.
             }
             </code>
             </example>
        </member>
        <member name="P:Animancer.AnimancerNode.ParentEffectiveSpeed">
            <summary>
            The <see cref="P:Animancer.AnimancerNode.Speed"/> of each of this node's parents down the hierarchy, including the root
            <see cref="T:Animancer.AnimancerPlayable"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.EffectiveSpeed">
            <summary>
            The <see cref="P:Animancer.AnimancerNode.Speed"/> of this node multiplied by the <see cref="P:Animancer.AnimancerNode.Speed"/> of each of its parents down the
            hierarchy (including the root <see cref="T:Animancer.AnimancerPlayable"/>) to determine the actual speed its output is
            being played at.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.GetDescription(System.Int32,System.String)">
            <summary>Returns a detailed descrption of the current details of this node.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.AppendDescription(System.Text.StringBuilder,System.Int32,System.String)">
            <summary>Appends a detailed descrption of the current details of this node.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.AppendDetails(System.Text.StringBuilder,System.String)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerNode.AppendDescription(System.Text.StringBuilder,System.Int32,System.String)"/> to append the details of this node.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerPlayable">
            <summary>
            A <see cref="T:UnityEngine.Playables.PlayableBehaviour"/> which can be used as a substitute for the
            <see cref="T:UnityEngine.RuntimeAnimatorController"/> normally used to control an <see cref="T:UnityEngine.Animator"/>.
            <para></para>
            This class can be used as a custom yield instruction to wait until all animations finish playing.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.DefaultFadeDuration">
            <summary>
            The fade duration for any of the CrossFade methods to use if the caller doesn't specify.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._Graph">
            <summary>[Internal] The <see cref="T:UnityEngine.Playables.PlayableGraph"/> containing this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._RootPlayable">
            <summary>[Internal] The <see cref="T:UnityEngine.Playables.Playable"/> connected to the <see cref="T:UnityEngine.Playables.PlayableGraph"/> output.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._LayerMixer">
            <summary>[Internal] The <see cref="T:UnityEngine.Playables.Playable"/> which layers connect to.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Animancer#IPlayableWrapper#Playable">
            <summary>[Internal] The <see cref="T:UnityEngine.Playables.Playable"/> which layers connect to.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Animancer#IPlayableWrapper#Parent">
            <summary>An <see cref="T:Animancer.AnimancerPlayable"/> is the root of the graph so it has no parent.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Layers">
            <summary>[Pro-Only] The layers which each manage their own set of animations.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.States">
            <summary>The states managed by this playable.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._DirtyNodes">
            <summary>All of the nodes that need to be updated.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._Updatables">
            <summary>All of the objects that need to be updated early.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._LateUpdate">
            <summary>The <see cref="T:UnityEngine.Playables.PlayableBehaviour"/> that calls <see cref="M:Animancer.IAnimancerUpdatable.LateUpdate"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Component">
            <summary>The component that is playing this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.CommandCount">
            <summary>
            The number of times the <see cref="P:Animancer.AnimancerPlayable.StateDictionary.Current"/> has changed. By storing this
            value and later comparing the stored value to the current value, you can determine whether the state has
            been changed since then, even it has changed back to the same state.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.UpdateMode">
            <summary>Determines what time source is used to update the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Speed">
             <summary>
             How fast the <see cref="P:Animancer.AnimancerState.Time"/> of all animations is advancing every frame.
             <para></para>
             1 is the normal speed.
             <para></para>
             A negative value will play the animations backwards.
             <para></para>
             Setting this value to 0 would pause all animations, but calling <see cref="M:Animancer.AnimancerPlayable.PauseGraph"/> is more efficient.
             <para></para>
             Animancer Lite does not allow this value to be changed in a runtime build.
             </summary>
            
             <example>
             <code>
             void SetSpeed(AnimancerComponent animancer)
             {
                 animancer.Playable.Speed = 1;// Normal speed.
                 animancer.Playable.Speed = 2;// Double speed.
                 animancer.Playable.Speed = 0.5f;// Half speed.
                 animancer.Playable.Speed = -1;// Normal speed playing backwards.
             }
             </code>
             </example>
        </member>
        <member name="P:Animancer.AnimancerPlayable.KeepChildrenConnected">
            <summary>
            Indicates whether child playables should stay connected to the graph at all times.
            <para></para>
            By default, this value is false so that playables will be disconnected from the graph while they are at 0
            weight which stops it from evaluating them every frame and is generally more efficient.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.Template">
            <summary>
            Since <see cref="M:UnityEngine.Playables.ScriptPlayable`1.Create(UnityEngine.Playables.PlayableGraph,System.Int32)"/> needs to clone an existing instance, we
            keep a static template to avoid allocating an extra garbage one every time.
            This is why the fields are assigned in OnPlayableCreate rather than being readonly with field initialisers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Create">
            <summary>
            Creates a new <see cref="T:UnityEngine.Playables.PlayableGraph"/> containing an <see cref="T:Animancer.AnimancerPlayable"/>.
            <para></para>
            The caller is responsible for calling <see cref="M:Animancer.AnimancerPlayable.Destroy"/> on the returned object, except in Edit Mode
            where it will be called automatically.
            <para></para>
            Consider calling <see cref="M:Animancer.AnimancerPlayable.SetNextGraphName(System.String)"/> before this method to give it a name.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.OnPlayableCreate(UnityEngine.Playables.Playable)">
            <summary>[Internal] Called by Unity as it creates this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.SetNextGraphName(System.String)">
            <summary>[Editor-Conditional]
            Sets the display name for the next <see cref="M:Animancer.AnimancerPlayable.Create"/> call to give its <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            </summary>
            <remarks>
            Having this method separate from <see cref="M:Animancer.AnimancerPlayable.Create"/> allows the
            <see cref="T:System.Diagnostics.ConditionalAttribute"/> to compile it out of runtime builds which would
            otherwise require #ifs on the caller side.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerComponent)">
            <summary>
            Plays the <see cref="P:Animancer.IAnimancerComponent.Playable"/> on the <see cref="P:Animancer.IAnimancerComponent.Animator"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(UnityEngine.Animator,Animancer.AnimancerPlayable,Animancer.IAnimancerComponent)">
            <summary>
            Plays the `playable` on the specified `animator`.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.IsGraphPlaying">
            <summary>Indicates whether the <see cref="T:UnityEngine.Playables.PlayableGraph"/> is currently playing.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.UnpauseGraph">
            <summary>
            Resumes playing the <see cref="T:UnityEngine.Playables.PlayableGraph"/> if <see cref="M:Animancer.AnimancerPlayable.PauseGraph"/> was called previously.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.PauseGraph">
            <summary>
            Freezes the <see cref="T:UnityEngine.Playables.PlayableGraph"/> at its current state.
            <para></para>
            If you call this method, you are responsible for calling <see cref="M:Animancer.AnimancerPlayable.UnpauseGraph"/> to resume playing.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Evaluate">
            <summary>
            Evaluates all of the currently playing animations to apply their states to the animated objects.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Evaluate(System.Single)">
            <summary>
            Advances all currently playing animations by the specified amount of time (in seconds) and evaluates the
            graph to apply their states to the animated objects.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.IsValid">
            <summary>
            Returns true as long as the <see cref="T:UnityEngine.Playables.PlayableGraph"/> hasn't been destroyed (such as by <see cref="M:Animancer.AnimancerPlayable.Destroy"/>).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Destroy">
            <summary>
            Destroys the <see cref="T:UnityEngine.Playables.PlayableGraph"/> and all its layers and states. This operation cannot be undone.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Finalize">
            <summary>[Editor-Only]
            Ensures that the <see cref="T:UnityEngine.Playables.PlayableGraph"/> is destroyed in Edit Mode.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetDescription(System.Int32)">
            <summary>Appends a detailed descrption of all currently playing states and other registered states.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.AppendDescription(System.Text.StringBuilder,System.Int32)">
            <summary>
            Appends a detailed descrption of all currently playing states and other registered states.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)">
            <summary>Calls <see cref="M:Animancer.IAnimancerComponent.GetKey(UnityEngine.AnimationClip)"/> on the <see cref="P:Animancer.AnimancerPlayable.Component"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(UnityEngine.AnimationClip)">
            <summary>
            Stops all other animations, plays the `clip`, and returns its state.
            <para></para>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            To restart it from the beginning you can use <c>...Play(clip, layerIndex).Time = 0;</c>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState)">
            <summary>
            Stops all other animations, plays the `state`, and returns it.
            <para></para>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            If you wish to force it back to the start, you can simply set the `state`s time to 0.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)">
            <summary>
            Creates a state for the `transition` if it didn't already exist, then calls
            <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState)"/> or <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/>
            depending on <see cref="P:Animancer.IAnimancerTransition.CrossFadeFromStart"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(System.Object)">
            <summary>
            Stops all other animations, plays the animation registered with the `key`, and returns that
            state. If no state is registered with the `key`, this method does nothing and returns null.
            <para></para>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            If you wish to force it back to the start, you can simply set the returned state's time to 0.
            on the returned state.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(UnityEngine.AnimationClip,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the `clip` over the course of the `fadeDuration` while fading out all others in the same
            layer. Returns its state.
            <para></para>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the `state` over the course of the `fadeDuration` while fading out all others in the same
            layer. Returns the `state`.
            <para></para>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition,System.Single,Animancer.FadeMode)">
            <summary>
            Creates a state for the `transition` if it didn't already exist, then calls
            <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState)"/> or <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/>
            depending on <see cref="P:Animancer.IAnimancerTransition.CrossFadeFromStart"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(System.Object,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the animation registered with the `key` over the course of the `fadeDuration` while fading
            out all others in the same layer. Returns the animation's state (or null if none was registered).
            <para></para>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Stop(Animancer.IHasKey)">
            <summary>
            Gets the state registered with the <see cref="P:Animancer.IHasKey.Key"/>, stops and rewinds it to the start, then
            returns it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Stop(System.Object)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Stop"/> on the state registered with the `key` to stop it from playing and
            rewind it to the start.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Stop">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Stop"/> on all animations to stop them from playing and rewind them to the
            start.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlaying(Animancer.IHasKey)">
            <summary>
            Returns true if a state is registered with the <see cref="P:Animancer.IHasKey.Key"/> and it is currently playing.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlaying(System.Object)">
            <summary>
            Returns true if a state is registered with the `key` and it is currently playing.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlaying">
            <summary>
            Returns true if at least one animation is being played.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlayingClip(UnityEngine.AnimationClip)">
            <summary>
            Returns true if the `clip` is currently being played by at least one state in the specified layer.
            <para></para>
            This method is inefficient because it searches through every state to find any that are playing the `clip`,
            unlike <see cref="M:Animancer.AnimancerPlayable.IsPlaying(System.Object)"/> which only checks the state registered using the specified key.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetTotalWeight">
            <summary>
            Calculates the total <see cref="P:Animancer.AnimancerNode.Weight"/> of all states in this playable.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>]
            Gathers all the animations in all layers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.System#Collections#IEnumerator#MoveNext">
            <summary>
            Determines if any animations are still playing so this object can be used as a custom yield instruction.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.System#Collections#IEnumerator#Current">
            <summary>Returns null.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.System#Collections#IEnumerator#Reset">
            <summary>Does nothing.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.CurrentEndEvent">
            <summary>
            The <see cref="T:UnityEngine.AnimationEvent"/> called 'End' which is currently being triggered.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.OnEndEventReceived(UnityEngine.AnimationEvent)">
            <summary>
            Invokes the <see cref="P:Animancer.AnimancerEvent.Sequence.OnEnd"/> callback of the state that is playing the animation
            which triggered the event. Returns true if such a state exists (even if it doesn't have a callback).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.TryInvokeOnEndEvent(UnityEngine.AnimationEvent,Animancer.AnimancerState)">
            <summary>
            If the <see cref="P:Animancer.AnimancerState.Clip"/> and <see cref="P:Animancer.AnimancerNode.Weight"/> match the
            <see cref="T:UnityEngine.AnimationEvent"/>, this method invokes the <see cref="P:Animancer.AnimancerEvent.Sequence.OnEnd"/> callback
            and returns true.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetFadeOutDuration(System.Single)">
            <summary>
            If the <see cref="P:Animancer.AnimancerPlayable.CurrentEndEvent"/> has a float parameter above 0, this method returns that value.
            Otherwise this method calls <see cref="M:Animancer.AnimancerEvent.GetFadeOutDuration(System.Single)"/> so if you aren't using an
            Animation Event with the function name "End" you can just call that method directly.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Stop(Animancer.AnimancerState)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            Just call <see cref="M:Animancer.AnimancerState.Stop"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlaying(Animancer.AnimancerState)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            Just check <see cref="P:Animancer.AnimancerState.IsPlaying"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.RequireUpdate(Animancer.IAnimancerUpdatable)">
            <summary>
            Adds the `updatable` to the list of objects that need to be updated if it wasn't there already.
            <para></para>
            This method is safe to call at any time, even during an update.
            <para></para>
            The execution order of updatables is non-deterministic. Specifically, the most recently added will be
            updated first and <see cref="M:Animancer.AnimancerPlayable.CancelUpdate(Animancer.IAnimancerUpdatable)"/> will change the order by swapping the last one into the place
            of the removed element.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.CancelUpdate(Animancer.IAnimancerUpdatable)">
            <summary>
            Removes the `updatable` from the list of objects that need to be updated.
            <para></para>
            This method is safe to call at any time, even during an update.
            <para></para>
            The last element is swapped into the place of the one being removed so that the rest of them do not need to
            be moved down one place to fill the gap. This is more efficient, by means that the update order can change.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.RequireUpdate(Animancer.AnimancerNode)">
            <summary>
            Adds the `node` to the list that need to be updated if it wasn't there already.
            This method is safe to call at any time, even during an update.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Current">
            <summary>The object currently executing <see cref="M:Animancer.AnimancerPlayable.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.DeltaTime">
            <summary>
            The current (most recent) <see cref="P:UnityEngine.Playables.FrameData.deltaTime"/>.
            <para></para>
            After <see cref="M:Animancer.AnimancerPlayable.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)"/>, this property will be left at its most recent value.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.FrameID">
            <summary>
            The current (most recent) <see cref="P:UnityEngine.Playables.FrameData.frameId"/>.
            <para></para>
            <see cref="P:Animancer.AnimancerState.Time"/> uses this value to determine whether it has accessed the playable's time
            since it was last updated in order to cache its value.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._CurrentUpdatable">
            <summary>
            The index of the <see cref="T:Animancer.IAnimancerUpdatable"/> currently being updated.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)">
            <summary>[Internal]
            Called by the <see cref="T:UnityEngine.Playables.PlayableGraph"/> before the rest of the <see cref="T:UnityEngine.Playables.Playable"/>s are evaluated.
            Calls <see cref="M:Animancer.IAnimancerUpdatable.EarlyUpdate"/> and <see cref="M:Animancer.AnimancerNode.Update(System.Boolean@)"/> on everything
            that needs it.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerPlayable.LateUpdate">
            <summary>
            A <see cref="T:UnityEngine.Playables.PlayableBehaviour"/> which connects to a later port than the main layer mixer so that its
            <see cref="M:Animancer.AnimancerPlayable.LateUpdate.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)"/> method gets called after all other playables are updated in order to call
            <see cref="M:Animancer.IAnimancerUpdatable.LateUpdate"/> on the <see cref="F:Animancer.AnimancerPlayable._Updatables"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LateUpdate.Template">
            <summary>See <see cref="F:Animancer.AnimancerPlayable.Template"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LateUpdate._Root">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> this behaviour is connected to.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LateUpdate._Playable">
            <summary>The underlying <see cref="T:UnityEngine.Playables.Playable"/> of this behaviour.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LateUpdate.Create(Animancer.AnimancerPlayable)">
            <summary>Creates a new <see cref="T:Animancer.AnimancerPlayable.LateUpdate"/> for the `root`.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LateUpdate.OnPlayableCreate(UnityEngine.Playables.Playable)">
            <summary>Called by Unity as it creates this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LateUpdate.IsConnected">
            <summary>
            Indicates whether this behaviour is connected to the <see cref="T:UnityEngine.Playables.PlayableGraph"/> and thus, whether it
            will receive <see cref="M:Animancer.AnimancerPlayable.LateUpdate.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)"/> calls.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LateUpdate.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)">
            <summary>
            Called by the <see cref="T:UnityEngine.Playables.PlayableGraph"/> after the rest of the <see cref="T:UnityEngine.Playables.Playable"/>s are evaluated.
            Calls <see cref="M:Animancer.IAnimancerUpdatable.LateUpdate"/> on everything that needs it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.HasChangedToOrFromAnimatePhysics(System.Nullable{UnityEngine.AnimatorUpdateMode},UnityEngine.AnimatorUpdateMode)">
            <summary>[Editor-Only]
            Returns true if the `initial` mode was <see cref="F:UnityEngine.AnimatorUpdateMode.AnimatePhysics"/> and the `current`
            has changed to another mode or if the `initial` mode was something else and the `current` has changed to
            <see cref="F:UnityEngine.AnimatorUpdateMode.AnimatePhysics"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.DoUpdateListGUI">
            <summary>[Editor-Only]
            Draws the <see cref="F:Animancer.AnimancerPlayable._Updatables"/> and <see cref="F:Animancer.AnimancerPlayable._DirtyNodes"/> lists.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerPlayable.LayerList">
            <summary>[Pro-Only]
            A list of <see cref="T:Animancer.AnimancerLayer"/>s with methods to control their mixing and masking.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LayerList.Root">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> at the root of the graph.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LayerList._Layers">
            <summary>[Internal] The layers which each manage their own set of animations.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LayerList.LayerMixer">
            <summary>[Internal] The <see cref="T:UnityEngine.Animations.AnimationLayerMixerPlayable"/> which blends the layers.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LayerList._Count">
            <summary>The number of layers that have actually been created.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.#ctor(Animancer.AnimancerPlayable,UnityEngine.Playables.Playable@)">
            <summary>[Internal] Constructs a new <see cref="T:Animancer.AnimancerPlayable.LayerList"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LayerList.Count">
            <summary>[Pro-Only] The number of layers in this list.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if the value is set higher than the <see cref="F:Animancer.AnimancerPlayable.LayerList.defaultCapacity"/>. This is simply a safety measure,
            so if you do actually need more layers you can just increase the limit.
            </exception>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if the value is set to a negative number.</exception>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetMinCount(System.Int32)">
            <summary>[Pro-Only]
            If the <see cref="P:Animancer.AnimancerPlayable.LayerList.Count"/> is below the specified `min`, this method increases it to that value.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LayerList.defaultCapacity">
            <summary>[Pro-Only]
            The maximum number of layers that can be created before an <see cref="T:System.ArgumentOutOfRangeException"/> will
            be thrown (default 4).
            <para></para>
            Lowering this value will not affect layers that have already been created.
            </summary>
            <example>
            To set this value automatically when the application starts, place the following method in any class:
            <code>[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
            private static void SetMaxLayerCount()
            {
                Animancer.AnimancerPlayable.LayerList.defaultCapacity = 8;
            }</code>
            Otherwise you can set the <see cref="P:Animancer.AnimancerPlayable.LayerList.Capacity"/> of each individual list:
            <code>AnimancerComponent animancer;
            animancer.Layers.Capacity = 8;</code>
            </example>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetMinDefaultCapacity(System.Int32)">
            <summary>[Pro-Only]
            If the <see cref="F:Animancer.AnimancerPlayable.LayerList.defaultCapacity"/> is below the specified `min`, this method increases it to that value.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LayerList.Capacity">
            <summary>[Pro-Only]
            The maximum number of layers that can be created before an <see cref="T:System.ArgumentOutOfRangeException"/> will
            be thrown. The initial capacity is determined by <see cref="F:Animancer.AnimancerPlayable.LayerList.defaultCapacity"/>.
            <para></para>
            Lowering this value will destroy any layers beyond the specified value.
            <para></para>
            Any changes to this value after a layer has been created will cause the allocation of a new array and
            garbage collection of the old one, so you should generally set it during initialisation.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the value is not greater than 0.</exception>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.Add">
            <summary>[Pro-Only]
            Creates and returns a new <see cref="T:Animancer.AnimancerLayer"/>. New layers will override earlier layers by default.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if the value is set higher than the <see cref="P:Animancer.AnimancerPlayable.LayerList.Capacity"/>. This is simply a safety measure,
            so if you do actually need more layers you can just increase the limit.
            </exception>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LayerList.Item(System.Int32)">
            <summary>
            Returns the layer at the specified index. If it didn't already exist, this method creates it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.GetEnumerator">
            <summary>Returns an enumerator that will iterate through all layers.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that will iterate through all layers.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.GetAllStateEnumerable">
            <summary>
            Returns an enumerator that will iterate through all states in each layer (not states inside mixers).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>]
            Gathers all the animations in all layers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.IsAdditive(System.Int32)">
            <summary>[Pro-Only]
            Checks whether the layer at the specified index is set to additive blending. Otherwise it will override any
            earlier layers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetAdditive(System.Int32,System.Boolean)">
            <summary>[Pro-Only]
            Sets the layer at the specified index to blend additively with earlier layers (if true) or to override them
            (if false). Newly created layers will override by default.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetMask(System.Int32,UnityEngine.AvatarMask)">
            <summary>[Pro-Only]
            Sets an <see cref="T:UnityEngine.AvatarMask"/> to determine which bones the layer at the specified index will affect.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetName(System.Int32,System.String)">
            <summary>[Editor-Conditional]
            Sets the Inspector display name of the layer at the specified index. Note that layer names are Editor-Only
            so any calls to this method will automatically be compiled out of a runtime build.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LayerList.AverageVelocity">
            <summary>
            The average velocity of the root motion of all currently playing animations, taking their current
            <see cref="P:Animancer.AnimancerNode.Weight"/> into account.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetWeightlessChildrenConnected(System.Boolean)">
            <summary>[Internal]
            Connects or disconnects all children from their parent <see cref="T:UnityEngine.Playables.Playable"/>.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerPlayable.StateDictionary">
            <summary>
            A dictionary of <see cref="T:Animancer.AnimancerState"/>s mapped to their <see cref="P:Animancer.AnimancerState.Key"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.StateDictionary.Root">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> at the root of the graph.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.StateDictionary.States">
            <summary><see cref="P:Animancer.AnimancerState.Key"/> mapped to <see cref="T:Animancer.AnimancerState"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.#ctor(Animancer.AnimancerPlayable)">
            <summary>[Internal] Constructs a new <see cref="T:Animancer.AnimancerPlayable.StateDictionary"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Count">
            <summary>The number of states that have been registered with a <see cref="P:Animancer.AnimancerState.Key"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Create(UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Create(UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Create(UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Create(UnityEngine.AnimationClip[])">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Current">
            <summary>
            The <see cref="P:Animancer.AnimancerLayer.CurrentState"/> on layer 0.
            <para></para>
            Specifically, this is the state that was most recently started using any of the Play methods on that layer.
            States controlled individually via methods in the <see cref="T:Animancer.AnimancerState"/> itself will not register in
            this property.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Item(UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)"/> then returns the state registered with that key, or null if none exists.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Item(Animancer.IHasKey)">
            <summary>
            Returns the state registered with the <see cref="P:Animancer.IHasKey.Key"/>, or null if none exists.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Item(System.Object)">
            <summary>
            Returns the state registered with the `key`, or null if none exists.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(UnityEngine.AnimationClip,Animancer.AnimancerState@)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)"/> then passes the key to
            <see cref="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(System.Object,Animancer.AnimancerState@)"/> and returns the result.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(Animancer.IHasKey,Animancer.AnimancerState@)">
            <summary>
            Passes the <see cref="P:Animancer.IHasKey.Key"/> into <see cref="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(System.Object,Animancer.AnimancerState@)"/>
            and returns the result.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(System.Object,Animancer.AnimancerState@)">
            <summary>
            If a state is registered with the `key`, this method outputs it as the `state` and returns true. Otherwise
            `state` is set to null and this method returns false.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(UnityEngine.AnimationClip,System.Boolean)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)"/> and returns the state which registered with that key or
            creates one if it doesn't exist.
            <para></para>
            If the state already exists but has the wrong <see cref="P:Animancer.AnimancerState.Clip"/>, the `allowSetClip`
            parameter determines what will happen. False causes it to throw an <see cref="T:System.ArgumentException"/> while
            true allows it to change the <see cref="P:Animancer.AnimancerState.Clip"/>. Note that the change is somewhat costly to
            performance to use with caution.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(Animancer.IAnimancerTransition)">
            <summary>
            Returns the state registered with the `transition`s <see cref="P:Animancer.IHasKey.Key"/> if there is one. Otherwise
            this method uses <see cref="M:Animancer.IAnimancerTransition.CreateState(Animancer.AnimancerLayer)"/> to create a new one and registers it with
            that key before returning it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(System.Object,UnityEngine.AnimationClip,System.Boolean)">
            <summary>
            Returns the state which registered with the `key` or creates one if it doesn't exist.
            <para></para>
            If the state already exists but has the wrong <see cref="P:Animancer.AnimancerState.Clip"/>, the `allowSetClip`
            parameter determines what will happen. False causes it to throw an <see cref="T:System.ArgumentException"/> while
            true allows it to change the <see cref="P:Animancer.AnimancerState.Clip"/>. Note that the change is somewhat costly to
            performance to use with caution.
            </summary>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:System.ArgumentNullException">Thrown if the `key` is null.</exception>
            <remarks>See also: <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(System.Object,UnityEngine.AnimationClip,System.Boolean)"/></remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Register(System.Object,Animancer.AnimancerState)">
            <summary>[Internal]
            Registers the `state` in this dictionary so the `key` can be used to get it later on using
            <see cref="P:Animancer.AnimancerPlayable.StateDictionary.Item(System.Object)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Unregister(Animancer.AnimancerState)">
            <summary>[Internal]
            Removes the `state` from this dictionary.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetEnumerator">
            <summary>
            Returns an enumerator that will iterate through all states in each layer (not states inside mixers).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>]
            Gathers all the animations in all layers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Destroy"/> on the state associated with the `clip` (if any).
            Returns true if the state existed.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(Animancer.IHasKey)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Destroy"/> on the state associated with the <see cref="P:Animancer.IHasKey.Key"/>
            (if any). Returns true if the state existed.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(System.Object)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Destroy"/> on the state associated with the `key` (if any).
            Returns true if the state existed.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.DestroyAll(System.Collections.Generic.IList{UnityEngine.AnimationClip})">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(UnityEngine.AnimationClip)"/> on each of the `clips`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.DestroyAll(System.Collections.Generic.IEnumerable{UnityEngine.AnimationClip})">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(UnityEngine.AnimationClip)"/> on each of the `clips`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.DestroyAll(Animancer.IAnimationClipSource)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(UnityEngine.AnimationClip)"/> on all states gathered by
            <see cref="!:IAnimationClipSource.GetAnimationClips"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.DestroyAll(Animancer.IAnimationClipCollection)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(UnityEngine.AnimationClip)"/> on all states gathered by
            <see cref="M:Animancer.IAnimationClipCollection.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.DestroyAll">
            <summary>
            Destroys all states connected to all layers (regardless of whether they are actually registered in this
            dictionary).
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Item(Animancer.AnimancerState)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            The whole point of a key is to identify a state in the first place.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(Animancer.AnimancerState,Animancer.AnimancerState@)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            The whole point of a key is to identify a state in the first place.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(Animancer.AnimancerState,UnityEngine.AnimationClip)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            The whole point of a key is to identify a state in the first place.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(Animancer.AnimancerState)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            Just call <see cref="M:Animancer.AnimancerState.Destroy"/>.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerState">
            <summary>
            Base class for all states in an <see cref="T:Animancer.AnimancerPlayable"/> graph.
            Each state is a wrapper for a <see cref="T:UnityEngine.Playables.Playable"/> in the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            <para></para>
            This class can be used as a custom yield instruction to wait until the animation either stops playing or reaches its end.
            </summary>
            <remarks>
            There are various different ways of getting a state:
            <list type="bullet">
              <item>
              Use one of the state's constructors. Generally the first parameter is a layer or mixer which will be used as
              the state's parent. If not specified, you will need to call SetParent manually. Also note than an
              AnimancerComponent can be implicitly cast to its first layer.
              </item>
              <item>
              AnimancerController.CreateState creates a new ClipState. You can optionally specify a custom `key` to
              register it in the dictionary instead of the default (the `clip` itself).
              </item>
              <item>
              AnimancerController.GetOrCreateState looks for an existing state registered with the specified `key` and only
              creates a new one if it doesnt already exist.
              </item>
              <item>
              AnimancerController.GetState returns an existing state registered with the specified `key` if there is one.
              </item>
              <item>
              AnimancerController.TryGetState is similar but returns a bool to indicate success and returns the `state`
              as an out parameter.
              </item>
              <item>
              AnimancerController.Play and CrossFade also return the state they play.
              </item>
            </list>
            <para></para>
            Note that when inheriting from this class, the <see cref="F:Animancer.AnimancerNode._Playable"/> field must be assigned in the
            constructor to avoid throwing <see cref="T:System.ArgumentException"/>s throughout the system.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.Parent">
            <summary>The object which receives the output of the <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.SetParent(Animancer.AnimancerNode,System.Int32)">
            <summary>
            Connects this state to the `parent` mixer at the specified `index`.
            <para></para>
            See also <see cref="M:Animancer.AnimancerLayer.AddChild(Animancer.AnimancerState)"/> to connect a state to an available port on a
            layer.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.ClearParent">
            <summary>[Internal]
            Called by <see cref="M:Animancer.AnimancerNode.OnAddChild(System.Collections.Generic.IList{Animancer.AnimancerState},Animancer.AnimancerState)"/> if the specified
            port is already occupied so it can be cleared without triggering any other calls.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.EffectiveWeight">
            <summary>
            The <see cref="P:Animancer.AnimancerNode.Weight"/> of this state multiplied by the <see cref="P:Animancer.AnimancerNode.Weight"/> of each of
            its parents down the hierarchy to determine how much this state affects the final output.
            </summary>
            <exception cref="T:System.NullReferenceException">Thrown if this state has no <see cref="P:Animancer.AnimancerNode.Parent"/>.</exception>
        </member>
        <member name="P:Animancer.AnimancerState.Layer">
            <summary>The root <see cref="T:Animancer.AnimancerLayer"/> which this state is connected to.</summary>
        </member>
        <member name="P:Animancer.AnimancerState.LayerIndex">
            <summary>
            The index of the <see cref="T:Animancer.AnimancerLayer"/> this state is connected to (determined by the
            <see cref="P:Animancer.AnimancerState.Parent"/>).
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Key">
            <summary>
            The object used to identify this state in the root <see cref="P:Animancer.AnimancerPlayable.States"/> dictionary.
            Can be null.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Clip">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> which this state plays (if any).</summary>
            <exception cref="T:System.NotSupportedException">
            Thrown if this state type doesn't have a clip and you try to set it.
            </exception>
        </member>
        <member name="P:Animancer.AnimancerState.MainObject">
            <summary>The main object to show in the Inspector for this state (if any).</summary>
            <exception cref="T:System.NotSupportedException">
            Thrown if this state type doesn't have a main object and you try to set it.
            </exception>
            <exception cref="T:System.InvalidCastException">
            Thrown if you try to assign something this state can't use.
            </exception>
        </member>
        <member name="P:Animancer.AnimancerState.AverageVelocity">
            <summary>The average velocity of the root motion caused by this state.</summary>
        </member>
        <member name="F:Animancer.AnimancerState._IsPlaying">
            <summary>Is the <see cref="P:Animancer.AnimancerState.Time"/> automatically advancing?</summary>
        </member>
        <member name="F:Animancer.AnimancerState._IsPlayingDirty">
            <summary>
            Has <see cref="F:Animancer.AnimancerState._IsPlaying"/> changed since it was last applied to the <see cref="T:UnityEngine.Playables.Playable"/>.
            </summary>
            <remarks>
            Playables start playing by default so we start dirty to pause it during the first update (unless
            <see cref="P:Animancer.AnimancerState.IsPlaying"/> is set to true before that).
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.IsPlaying">
             <summary>Is the <see cref="P:Animancer.AnimancerState.Time"/> automatically advancing?</summary>
            
             <example>
             <code>
             void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.States.GetOrCreate(clip);
            
                 if (state.IsPlaying)
                     Debug.Log(clip + " is playing");
                 else
                     Debug.Log(clip + " is paused");
            
                 state.IsPlaying = false;// Pause the animation.
            
                 state.IsPlaying = true;// Unpause the animation.
             }
             </code>
             </example>
        </member>
        <member name="P:Animancer.AnimancerState.IsActive">
            <summary>
            Returns true if this state is playing and is at or fading towards a non-zero
            <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.IsStopped">
            <summary>
            Returns true if this state is not playing and is at 0 <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Update(System.Boolean@)">
            <summary>
            Updates the <see cref="P:Animancer.AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent
            mixer, and plays or pauses the <see cref="T:UnityEngine.Playables.Playable"/> if its state is dirty.
            <para></para>
            If the <see cref="P:Animancer.AnimancerState.Parent"/>'s <see cref="P:Animancer.AnimancerNode.KeepChildrenConnected"/> is set to false, this
            method will also connect/disconnect this node from the <see cref="P:Animancer.AnimancerState.Parent"/> in the playable graph.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerState._Time">
            <summary>
            The current time of the <see cref="T:UnityEngine.Playables.Playable"/>, retrieved by <see cref="P:Animancer.AnimancerState.Time"/> whenever the
            <see cref="F:Animancer.AnimancerState._TimeFrameID"/> is different from the <see cref="P:Animancer.AnimancerPlayable.FrameID"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerState._TimeFrameID">
            <summary>
            The <see cref="P:Animancer.AnimancerPlayable.FrameID"/> from when the <see cref="P:Animancer.AnimancerState.Time"/> was last retrieved from the
            <see cref="T:UnityEngine.Playables.Playable"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Time">
             <summary>
             The number of seconds that have passed since the start of this animation.
             <para></para>
             This value will continue increasing after the animation passes the end of its <see cref="P:Animancer.AnimancerState.Length"/> while
             the animated object either freezes in place or starts again from the beginning according to whether it is
             looping or not.
             <para></para>
             Animancer Lite does not allow this value to be changed in a runtime build (except resetting it to 0).
             </summary>
            
             <example>
             <code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 // Skip 0.5 seconds into the animation:
                 state.Time = 0.5f;
            
                 // Skip 50% of the way through the animation (0.5 in a range of 0 to 1):
                 state.NormalizedTime = 0.5f;
            
                 // Skip to the end of the animation and play backwards.
                 state.NormalizedTime = 1;
                 state.Speed = -1;
             }
             </code>
             </example>
            
             <remarks>
             This property internally uses <see cref="P:Animancer.AnimancerState.NewTime"/> whenever the value is out of date or gets changed.
             </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.NewTime">
            <summary>
            The internal implementation of <see cref="P:Animancer.AnimancerState.Time"/> which actually gets and sets the underlying value.
            </summary>
            <remarks>
            Setting this value actually calls <see cref="M:UnityEngine.Playables.PlayableExtensions.SetTime``1(``0,System.Double)"/> twice to ensure that animation
            events aren't triggered incorrectly. Calling it only once would trigger any animation events between the
            previous time and the new time. So if an animation plays to the end and you set the time back to 0 (such as
            by calling <see cref="M:Animancer.AnimancerState.Stop"/> or playing a different animation), the next time that animation played it
            would immediately trigger all of its events, then play through and trigger them normally as well.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.NormalizedTime">
             <summary>
             The <see cref="P:Animancer.AnimancerState.Time"/> of this state as a portion of the animation's <see cref="P:Animancer.AnimancerState.Length"/>, meaning the
             value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes.
             <para></para>
             This value will continue increasing after the animation passes the end of its <see cref="P:Animancer.AnimancerState.Length"/> while
             the animated object either freezes in place or starts again from the beginning according to whether it is
             looping or not.
             <para></para>
             The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the
             current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has
             been looped.
             <para></para>
             Animancer Lite does not allow this value to be changed to a value other than 0 in a runtime build.
             </summary>
            
             <example>
             <code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 // Skip 0.5 seconds into the animation:
                 state.Time = 0.5f;
            
                 // Skip 50% of the way through the animation (0.5 in a range of 0 to 1):
                 state.NormalizedTime = 0.5f;
            
                 // Skip to the end of the animation and play backwards.
                 state.NormalizedTime = 1;
                 state.Speed = -1;
             }
             </code>
             </example>
        </member>
        <member name="P:Animancer.AnimancerState.Duration">
             <summary>
             The number of seconds the animation will take to play fully at its current
             <see cref="P:Animancer.AnimancerNode.Speed"/>.
             <para></para>
             Setting this value modifies the <see cref="P:Animancer.AnimancerNode.Speed"/>, not the <see cref="P:Animancer.AnimancerState.Length"/>.
             Animancer Lite does not allow this value to be changed in a runtime build.
             <para></para>
             For the time remaining from now until it reaches the end, use <see cref="P:Animancer.AnimancerState.RemainingDuration"/> instead.
             </summary>
            
             <example>
             <code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 state.Duration = 1;// Play fully in 1 second.
                 state.Duration = 2;// Play fully in 2 seconds.
                 state.Duration = 0.5f;// Play fully in half a second.
                 state.Duration = -1;// Play backwards fully in 1 second.
                 state.NormalizedTime = 1; state.Duration = -1;// Play backwards from the end in 1 second.
             }
             </code>
             </example>
        </member>
        <member name="P:Animancer.AnimancerState.RemainingDuration">
             <summary>
             The number of seconds the animation will take to reach the end at its current <see cref="P:Animancer.AnimancerNode.Speed"/>.
             <para></para>
             Setting this value modifies the <see cref="P:Animancer.AnimancerNode.Speed"/>, not the <see cref="P:Animancer.AnimancerState.Length"/>.
             Animancer Lite does not allow this value to be changed in a runtime build.
             <para></para>
             For the time it would take to play fully from the start, use <see cref="P:Animancer.AnimancerState.Duration"/> instead.
             </summary>
            
             <example>
             <code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 state.RemainingDuration = 1;// Play from the current time to the end in 1 second.
                 state.RemainingDuration = 2;// Play from the current time to the end in 2 seconds.
                 state.RemainingDuration = 0.5f;// Play from the current time to the end in half a second.
                 state.RemainingDuration = -1;// Play backwards from the current time to the end in 1 second.
             }
             </code>
             </example>
        </member>
        <member name="P:Animancer.AnimancerState.Length">
            <summary>The total time this state takes to play in seconds (when <c>Speed = 1</c>).</summary>
        </member>
        <member name="P:Animancer.AnimancerState.IsLooping">
            <summary>
            Indicates whether this state will loop back to the start when it reaches the end.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.ApplyAnimatorIK">
            <summary>
            Determines whether <c>OnAnimatorIK(int layerIndex)</c> will be called on the animated object.
            The initial value is determined by <see cref="P:Animancer.AnimancerLayer.DefaultApplyAnimatorIK"/>.
            <para></para>
            This is equivalent to the "IK Pass" toggle in Animator Controller layers, except that due to limitations in
            the Playables API the <c>layerIndex</c> will always be zero.
            <para></para>
            It requires Unity 2018.1 or newer, however 2018.3 or newer is recommended because a bug in earlier versions
            of the Playables API caused this value to only take effect while a state was at
            <see cref="P:Animancer.AnimancerNode.Weight"/> == 1 which meant that IK would not work while fading between animations.
            <para></para>
            Returns false and does nothing if this state does not support IK.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.ApplyFootIK">
            <summary>
            Indicates whether this state is applying IK to the character's feet.
            The initial value is determined by <see cref="P:Animancer.AnimancerLayer.DefaultApplyFootIK"/>.
            <para></para>
            This is equivalent to the "Foot IK" toggle in Animator Controller states.
            <para></para>
            Returns false and does nothing if this state does not support IK.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.#ctor(Animancer.AnimancerPlayable)">
            <summary>Constructs a new <see cref="T:Animancer.AnimancerState"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.Play">
            <summary>
            Plays this animation immediately, without any blending.
            Sets <see cref="P:Animancer.AnimancerState.IsPlaying"/> = true, <see cref="P:Animancer.AnimancerNode.Weight"/> = 1, and clears the
            <see cref="P:Animancer.AnimancerState.Events"/>.
            <para></para>
            This method does not change the <see cref="P:Animancer.AnimancerState.Time"/> so it will continue from its current value.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Stop">
            <summary>
            Stops the animation and makes it inactive immediately so it no longer affects the output.
            Sets <see cref="P:Animancer.AnimancerNode.Weight"/> = 0, <see cref="P:Animancer.AnimancerState.IsPlaying"/> = false, <see cref="P:Animancer.AnimancerState.Time"/> = 0, and
            clears the <see cref="P:Animancer.AnimancerState.Events"/>.
            <para></para>
            If you only want to freeze the animation in place, you can set <see cref="P:Animancer.AnimancerState.IsPlaying"/> = false instead. Or
            to freeze all animations, you can call <see cref="M:Animancer.AnimancerPlayable.PauseGraph"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.OnStartFade">
            <summary>
            Called by <see cref="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)"/>. Clears the <see cref="P:Animancer.AnimancerState.Events"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Destroy">
            <summary>Destroys the <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>]
            Gathers all the animations in this state.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.IsPlayingAndNotEnding">
            <summary>
            Returns true if the animation is playing and has not yet passed the
            <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>.
            <para></para>
            This method is called by <see cref="M:System.Collections.IEnumerator.MoveNext"/> so this object can be used as a custom yield
            instruction to wait until it finishes.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.GetDrawer">
            <summary>[Editor-Only] Returns a custom drawer for this state.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.AppendDetails(System.Text.StringBuilder,System.String)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerNode.AppendDescription(System.Text.StringBuilder,System.Int32,System.String)"/> to append the details of this node.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.GetPath">
            <summary>Returns the hierarchy path of this state through its <see cref="P:Animancer.AnimancerState.Parent"/>s.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.AppendPath(System.Text.StringBuilder,Animancer.AnimancerNode)">
            <summary>Appends the hierarchy path of this state through its <see cref="P:Animancer.AnimancerState.Parent"/>s.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.AppendPortAndType(System.Text.StringBuilder)">
            <summary>Appends "[Index] -> GetType().Name".</summary>
        </member>
        <member name="T:Animancer.AnimancerState.Transition`1">
            <summary>
            Base class for serializable <see cref="T:Animancer.IAnimancerTransition"/>s which can create a particular type of
            <see cref="T:Animancer.AnimancerState"/> when passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            <para></para>
            Even though it has the <see cref="T:System.SerializableAttribute"/>, this class won't actually get serialized
            by Unity because it's generic and abstract. Each child class still needs to include the attribute.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.FadeDuration">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The amount of time the transition will take (in seconds).</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.NormalizedStartTime">
            <summary>[<see cref="T:Animancer.IAnimancerTransitionDetailed"/>]
            Determines what <see cref="P:Animancer.AnimancerState.NormalizedTime"/> to start the animation at.
            Returns <see cref="F:System.Single.NaN"/> unless overridden.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.Speed">
            <summary>[<see cref="T:Animancer.IAnimancerTransitionDetailed"/>]
            Determines how fast the animation plays (1x = normal speed).
            Returns 1 unless overridden.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.MaximumDuration">
            <summary>[<see cref="T:Animancer.IAnimancerTransitionDetailed"/>]
            The maximum amount of time the animation is expected to take (in seconds).
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.Events">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] Events which will be triggered as the animation plays.</summary>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.BaseState">
            <summary>
            The state that was created by this object. Specifically, this is the state that was most recently
            passed into <see cref="M:Animancer.AnimancerState.Transition`1.Apply(Animancer.AnimancerState)"/> (usually by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>).
            <para></para>
            <see cref="P:Animancer.AnimancerState.Transition`1.State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.State">
            <summary>
            The state that was created by this object. Specifically, this is the state that was most recently
            passed into <see cref="M:Animancer.AnimancerState.Transition`1.Apply(Animancer.AnimancerState)"/> (usually by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>).
            <para></para>
            This property is shorthand for casting the <see cref="P:Animancer.AnimancerState.Transition`1.BaseState"/> to <typeparamref name="TState"/>.
            </summary>
            <exception cref="T:System.InvalidCastException">
            Thrown if the <see cref="P:Animancer.AnimancerState.Transition`1.BaseState"/> is not actually a <typeparamref name="TState"/>. This should only
            happen if a different type of state was created by something else and registered using the
            <see cref="P:Animancer.AnimancerState.Transition`1.Key"/>, causing this <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/> to pass that
            state into <see cref="M:Animancer.AnimancerState.Transition`1.Apply(Animancer.AnimancerState)"/> instead of calling <see cref="M:Animancer.AnimancerState.Transition`1.CreateState(Animancer.AnimancerLayer)"/> to make the correct type of
            state.
            </exception>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.Key">
            <summary>
            The <see cref="P:Animancer.AnimancerState.Key"/> which the created state will be registered with.
            <para></para>
            By default, a transition is used as its own <see cref="P:Animancer.AnimancerState.Transition`1.Key"/>, but this property can be overridden.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.CrossFadeFromStart">
            <summary>
            When a transition is passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>, this
            property indicates whether it needs to use <see cref="F:Animancer.FadeMode.FromStart"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Transition`1.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <typeparamref name="TState"/> connected to the `layer`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Transition`1.Animancer#IAnimancerTransition#CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <typeparamref name="TState"/> connected to the `layer`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Transition`1.Apply(Animancer.AnimancerState)">
            <summary>[<see cref="T:Animancer.IAnimancerTransition"/>]
            Called by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/> to set the <see cref="P:Animancer.AnimancerState.Transition`1.BaseState"/>
            and apply any other modifications to the `state`.
            </summary>
            <remarks>
            This method also clears the <see cref="P:Animancer.AnimancerState.Transition`1.State"/> if necessary, so it will re-cast the
            <see cref="P:Animancer.AnimancerState.Transition`1.BaseState"/> when it gets accessed again.
            </remarks>
        </member>
        <member name="F:Animancer.AnimancerState.Transition`1.NestedObjectDrawers">
            <summary>[Editor-Only] Don't use Inspector Gadgets Nested Object Drawers.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.Transition`1.Animancer#IAnimancerTransitionDetailed#AddItemsToContextMenu(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,Animancer.Editor.Serialization.PropertyAccessor)">
            <summary>[Editor-Only] Adds context menu functions for this transition.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.Transition`1.AddItemsToContextMenu(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,Animancer.Editor.Serialization.PropertyAccessor)">
            <summary>[Editor-Only] Adds context menu functions for this transition.</summary>
        </member>
        <member name="F:Animancer.AnimancerState._EventUpdatable">
            <summary>
            The <see cref="T:Animancer.IAnimancerUpdatable"/> that manages the events of this state.
            <para></para>
            This field is null by default, acquires its reference from an <see cref="T:Animancer.ObjectPool"/> when accessed, and
            if it contains no events at the end of an update it releases the reference back to the pool.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Events">
            <summary>
            A list of <see cref="T:Animancer.AnimancerEvent"/>s that will occur while this state plays as well as one that
            specifically defines when this state ends.
            <para></para>
            Animancer Lite does not allow the use of events in a runtime build, except for
            <see cref="P:Animancer.AnimancerEvent.Sequence.OnEnd"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.HasEvents">
            <summary>
            Indicates whether this state currently has an <see cref="T:Animancer.AnimancerEvent.Sequence"/> (since accessing the
            <see cref="P:Animancer.AnimancerState.Events"/> would automatically get one from the <see cref="T:Animancer.ObjectPool"/>).
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.EventUpdatablePoolCapacity">
            <summary>The <see cref="P:System.Collections.Generic.List`1.Capacity"/> of the internal list of spare <see cref="T:Animancer.AnimancerState.EventUpdatable"/>s.</summary>
        </member>
        <member name="F:Animancer.AnimancerState.EventUpdatable.SequenceVersionException">
            <summary>
            This system accounts for external modifications to the sequence, but modifying it while checking which
            of its events to update is not allowed because it would be impossible to efficiently keep track of
            which events have been checked/invoked and which still need to be checked.
            </summary>
        </member>
        <member name="T:Animancer.ClipState">
            <summary>
            An <see cref="T:Animancer.AnimancerState"/> which plays an <see cref="T:UnityEngine.AnimationClip"/>.
            </summary>
        </member>
        <member name="F:Animancer.ClipState._Clip">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ClipState.Clip">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ClipState.MainObject">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ClipState.Length">
            <summary>The <see cref="P:UnityEngine.AnimationClip.length"/>.</summary>
        </member>
        <member name="P:Animancer.ClipState.IsLooping">
            <summary>The <see cref="P:UnityEngine.Motion.isLooping"/>.</summary>
        </member>
        <member name="P:Animancer.ClipState.AverageVelocity">
            <summary>The average velocity of the root motion caused by this state.</summary>
        </member>
        <member name="P:Animancer.ClipState.ApplyAnimatorIK">
            <summary>
            Determines whether <c>OnAnimatorIK(int layerIndex)</c> will be called on the animated object.
            The initial value is determined by <see cref="P:Animancer.AnimancerLayer.DefaultApplyAnimatorIK"/>.
            <para></para>
            This is equivalent to the "IK Pass" toggle in Animator Controller layers.
            <para></para>
            It requires Unity 2018.1 or newer, however 2018.3 or newer is recommended because a bug in earlier versions
            of the Playables API caused this value to only take effect while a state was at
            <see cref="P:Animancer.AnimancerNode.Weight"/> == 1 which meant that IK would not work while fading between animations.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.ApplyFootIK">
            <summary>
            Indicates whether this state is applying IK to the character's feet.
            The initial value is determined by <see cref="P:Animancer.AnimancerLayer.DefaultApplyFootIK"/>.
            <para></para>
            This is equivalent to the "Foot IK" toggle in Animator Controller states.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.InitialiseIKDefaults(Animancer.AnimancerLayer)">
            <summary>
            Applies the default IK flags from the specified `layer`.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.#ctor(Animancer.AnimancerPlayable,UnityEngine.AnimationClip)">
            <summary>
            Constructs a new <see cref="T:Animancer.ClipState"/> to play the `clip` without connecting it to the
            <see cref="T:UnityEngine.Playables.PlayableGraph"/>. You must call <see cref="M:Animancer.AnimancerState.SetParent(Animancer.AnimancerNode,System.Int32)"/> or it
            will not actually do anything.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.#ctor(Animancer.AnimancerLayer,UnityEngine.AnimationClip)">
            <summary>
            Constructs a new <see cref="T:Animancer.ClipState"/> to play the `clip` and connects it to a new port on the `layer`s
            <see cref="T:UnityEngine.Playables.Playable"/>.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.#ctor(Animancer.AnimancerNode,System.Int32,UnityEngine.AnimationClip)">
            <summary>
            Constructs a new <see cref="T:Animancer.ClipState"/> to play the `clip` and connects it to the `parent`s
            <see cref="T:UnityEngine.Playables.Playable"/> at the specified `index`.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.ToString">
            <summary>
            Returns a string describing the type of this state and the name of the <see cref="P:Animancer.ClipState.Clip"/>.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.Destroy">
            <summary>Destroys the <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="M:Animancer.ClipState.GetDrawer">
            <summary>[Editor-Only] Returns a <see cref="T:Animancer.ClipState.Drawer"/> for this state.</summary>
        </member>
        <member name="T:Animancer.ClipState.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.ClipState"/>.</summary>
        </member>
        <member name="F:Animancer.ClipState.Drawer._HasEndEvent">
            <summary>Indicates whether the animation has an event called "End".</summary>
        </member>
        <member name="M:Animancer.ClipState.Drawer.#ctor(Animancer.ClipState)">
            <summary>
            Constructs a new <see cref="T:Animancer.ClipState.Drawer"/> to manage the Inspector GUI for the `state`.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.Drawer.DoDetailsGUI(Animancer.IAnimancerComponent)">
            <summary> Draws the details of the target state in the GUI.</summary>
        </member>
        <member name="M:Animancer.ClipState.Drawer.DoAnimationTypeWarningGUI(Animancer.IAnimancerComponent)">
            <summary>
            Validates the <see cref="P:Animancer.ClipState.Clip"/> type compared to the owner's <see cref="T:UnityEngine.Animator"/> type.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.Drawer.AddContextMenuFunctions(UnityEditor.GenericMenu)">
            <summary>Adds the details of this state to the menu.</summary>
        </member>
        <member name="T:Animancer.ClipState.Transition">
            <summary>
            A serializable <see cref="T:Animancer.IAnimancerTransition"/> which can create a <see cref="T:Animancer.ClipState"/> when passed
            into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            </remarks>
        </member>
        <member name="P:Animancer.ClipState.Transition.Clip">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The animation to play.</summary>
        </member>
        <member name="P:Animancer.ClipState.Transition.Key">
            <summary>
            The <see cref="P:Animancer.ClipState.Transition.Clip"/> will be used as the <see cref="P:Animancer.AnimancerState.Key"/> for the created state to be
            registered with.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.Transition.Speed">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            Determines how fast the animation plays (1x = normal speed, 2x = double speed).
            </summary>
        </member>
        <member name="P:Animancer.ClipState.Transition.NormalizedStartTime">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            Determines what <see cref="P:Animancer.AnimancerState.NormalizedTime"/> to start the animation at.
            <para></para>
            The default value is <see cref="F:System.Single.NaN"/> which indicates that this value isn't used so the
            animation will continue from its current time.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.Transition.CrossFadeFromStart">
            <summary>
            If this transition will set the <see cref="P:Animancer.AnimancerState.NormalizedTime"/>, then it needs to use
            <see cref="F:Animancer.FadeMode.FromStart"/>.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.Transition.MaximumDuration">
            <summary>[<see cref="T:Animancer.IAnimancerTransitionDetailed"/>]
            The maximum amount of time the animation is expected to take (in seconds).
            </summary>
        </member>
        <member name="M:Animancer.ClipState.Transition.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> connected to the `layer`.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.Transition.Apply(Animancer.AnimancerState)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/> to apply the <see cref="P:Animancer.ClipState.Transition.Speed"/>
            and <see cref="P:Animancer.ClipState.Transition.NormalizedStartTime"/>.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.Transition.Animancer#IAnimationClipCollection#GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>Adds the <see cref="P:Animancer.ClipState.Transition.Clip"/> to the collection.</summary>
        </member>
        <member name="T:Animancer.FadeMode">
            <summary>
            Determines how <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/> works.
            </summary>
        </member>
        <member name="F:Animancer.FadeMode.FixedSpeed">
             <summary>
             Calculate the fade speed to bring the <see cref="P:Animancer.AnimancerNode.Weight"/> from 0 to 1 over the specified
             fade duration (in seconds), regardless of the actual starting weight.
             </summary>
            
             <example>
             A fade duration of 0.5 would make the fade last for 0.5 seconds, regardless of how long the animation is.
             <para></para>
             This is generally the same as <see cref="F:Animancer.FadeMode.FixedDuration"/> but differs when starting the fade from a
             non-zero <see cref="P:Animancer.AnimancerNode.Weight"/>, for example:
             <list type="bullet">
             <item>Fade Duration: 0.25</item>
             <item>To fade from 0 to 1 with either mode would get a speed of 4 and take 0.25 seconds</item>
             <item>To fade from 0.5 to 1 with <see cref="F:Animancer.FadeMode.FixedDuration"/> would get a speed of 2 and take 0.25 seconds.
             It has half the distance to cover so it goes half as fast to maintain the expected duration.</item>
             <item>To fade from 0.5 to 1 with <see cref="F:Animancer.FadeMode.FixedSpeed"/> would get a speed of 4 and take 0.125 seconds.
             It gets the same speed regardless of the distance to cover, so with less distance it completes faster.</item>
             </list>
             </example>
            
             <exception cref="T:System.InvalidOperationException">
             Thrown if the <see cref="P:Animancer.AnimancerState.Clip"/> is null.
             </exception>
            
             <exception cref="T:System.ArgumentOutOfRangeException">
             Thrown if more states have been created for the <see cref="P:Animancer.AnimancerState.Clip"/> than the
             <see cref="F:Animancer.AnimancerLayer.maxStateDepth"/> allows.
             </exception>
        </member>
        <member name="F:Animancer.FadeMode.FixedDuration">
             <summary>
             Calculate the fade speed to bring the <see cref="P:Animancer.AnimancerNode.Weight"/> to the target value over the
             specified fade duration (in seconds).
             </summary>
            
             <example>
             A fade duration of 0.5 would make the fade last for 0.5 seconds, regardless of how long the animation is.
             <para></para>
             This is generally the same as <see cref="F:Animancer.FadeMode.FixedDuration"/>, but differs when starting the fade from a
             non-zero <see cref="P:Animancer.AnimancerNode.Weight"/>:
             <list type="bullet">
             <item>Fade Duration: 0.25</item>
             <item>To fade from 0 to 1 with either mode would get a speed of 4 and take 0.25 seconds</item>
             <item>To fade from 0.5 to 1 with <see cref="F:Animancer.FadeMode.FixedDuration"/> would get a speed of 2 and take 0.25 seconds.
             It has half the distance to cover so it goes half as fast to maintain the expected duration.</item>
             <item>To fade from 0.5 to 1 with <see cref="F:Animancer.FadeMode.FixedSpeed"/> would get a speed of 4 and take 0.125 seconds.
             It gets the same speed regardless of the distance to cover, so with less distance it completes faster.</item>
             </list>
             </example>
            
             <remarks>
             This was how fading worked prior to the introduction of <see cref="T:Animancer.FadeMode"/>s in Animancer v4.0.
             </remarks>
        </member>
        <member name="F:Animancer.FadeMode.FromStart">
             <summary>
             If the state isn't currently at 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this mode will use
             <see cref="M:Animancer.AnimancerLayer.GetOrCreateWeightlessState(Animancer.AnimancerState)"/> to get a copy of it that is at 0 weight so it can
             fade the copy in while the original fades out with all other states.
             <para></para>
             Using this mode repeatedly on subsequent frames will probably have undesirable effects because it will
             create a new state each time. In such a situation you most likely want <see cref="F:Animancer.FadeMode.FixedSpeed"/> instead.
             </summary>
            
             <example>
             This can be useful when you want to repeat an action while the previous animation is still fading out.
             For example, if you play an 'Attack' animation, it ends and starts fading back to 'Idle', and while it is
             doing so you want to start another 'Attack'. The previous 'Attack' can't simply snap back to the start, so
             you can use this method to create a second 'Attack' state to fade in while the old one fades out.
             </example>
        </member>
        <member name="F:Animancer.FadeMode.NormalizedSpeed">
            <summary>
            Like <see cref="F:Animancer.FadeMode.FixedSpeed"/>, except that the fade duration is multiplied by the animation length.
            </summary>
        </member>
        <member name="F:Animancer.FadeMode.NormalizedDuration">
            <summary>
            Like <see cref="F:Animancer.FadeMode.FixedDuration"/>, except that the fade duration is multiplied by the animation length.
            </summary>
        </member>
        <member name="F:Animancer.FadeMode.NormalizedFromStart">
            <summary>
            Like <see cref="F:Animancer.FadeMode.FromStart"/>, except that the fade duration is multiplied by the animation length.
            </summary>
        </member>
        <member name="T:Animancer.PlayableAssetState">
            <summary>
            An <see cref="T:Animancer.AnimancerState"/> which plays a <see cref="T:UnityEngine.Playables.PlayableAsset"/>.
            </summary>
        </member>
        <member name="F:Animancer.PlayableAssetState._Asset">
            <summary>The <see cref="T:UnityEngine.Playables.PlayableAsset"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Asset">
            <summary>The <see cref="T:UnityEngine.Playables.PlayableAsset"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.MainObject">
            <summary>The <see cref="T:UnityEngine.Playables.PlayableAsset"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Length">
            <summary>The <see cref="P:UnityEngine.Playables.PlayableAsset.duration"/>.</summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.#ctor(Animancer.AnimancerPlayable,UnityEngine.Playables.PlayableAsset)">
            <summary>
            Constructs a new <see cref="T:Animancer.PlayableAssetState"/> to play the `asset` without connecting it to the
            <see cref="T:UnityEngine.Playables.PlayableGraph"/>. You must call <see cref="M:Animancer.AnimancerState.SetParent(Animancer.AnimancerNode,System.Int32)"/> or it
            will not actually do anything.
            </summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.#ctor(Animancer.AnimancerLayer,UnityEngine.Playables.PlayableAsset)">
            <summary>
            Constructs a new <see cref="T:Animancer.PlayableAssetState"/> to play the `asset` and connects it to a new port on the
            `layer`s <see cref="T:UnityEngine.Playables.Playable"/>.
            </summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.#ctor(Animancer.AnimancerNode,System.Int32,UnityEngine.Playables.PlayableAsset)">
            <summary>
            Constructs a new <see cref="T:Animancer.PlayableAssetState"/> to play the `asset` and connects it to the `parent`s
            <see cref="T:UnityEngine.Playables.Playable"/> at the specified `index`.
            </summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.ToString">
            <summary>
            Returns a string describing the type of this state and the name of the <see cref="P:Animancer.PlayableAssetState.Asset"/>.
            </summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.Destroy">
            <summary>Destroys the <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="T:Animancer.PlayableAssetState.Transition">
            <summary>
            A serializable <see cref="T:Animancer.IAnimancerTransition"/> which can create a <see cref="T:Animancer.PlayableAssetState"/> when
            passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            </remarks>
        </member>
        <member name="P:Animancer.PlayableAssetState.Transition.Asset">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The animation to play.</summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Transition.Key">
            <summary>
            The <see cref="P:Animancer.PlayableAssetState.Transition.Asset"/> will be used as the <see cref="P:Animancer.AnimancerState.Key"/> for the created state to
            be registered with.
            </summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Transition.Speed">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            Determines how fast the animation plays (1x = normal speed, 2x = double speed).
            </summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Transition.NormalizedStartTime">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            Determines what <see cref="P:Animancer.AnimancerState.NormalizedTime"/> to start the animation at.
            <para></para>
            The default value is <see cref="F:System.Single.NaN"/> which indicates that this value isn't used so the
            animation will continue from its current time.
            </summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Transition.CrossFadeFromStart">
            <summary>
            If this transition will set the <see cref="P:Animancer.AnimancerState.NormalizedTime"/>, then it needs to use
            <see cref="F:Animancer.FadeMode.FromStart"/>.
            </summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Transition.MaximumDuration">
            <summary>[<see cref="T:Animancer.IAnimancerTransitionDetailed"/>]
            The maximum amount of time the animation is expected to take (in seconds).
            </summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.Transition.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.PlayableAssetState"/> connected to the `layer`.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.Transition.Apply(Animancer.AnimancerState)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/> to apply the <see cref="P:Animancer.PlayableAssetState.Transition.Speed"/>
            and <see cref="P:Animancer.PlayableAssetState.Transition.NormalizedStartTime"/>.
            </summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.Transition.Animancer#IAnimationClipCollection#GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>Gathers all the animations associated with this object.</summary>
        </member>
        <member name="T:Animancer.PlayableAssetState.Transition.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.PlayableAssetState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.Transition.Drawer.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.PlayableAssetState.Transition.Drawer"/>.</summary>
        </member>
        <member name="T:Animancer.Strings">
            <summary>
            Various string constants used throughout <see cref="N:Animancer"/>.
            </summary>
        </member>
        <member name="F:Animancer.Strings.DocumentationURL">
            <summary>The URL of the website where the Animancer documentation is hosted.</summary>
        </member>
        <member name="F:Animancer.Strings.APIDocumentationURL">
            <summary>The URL of the website where the Animancer API documentation is hosted.</summary>
        </member>
        <member name="F:Animancer.Strings.DeveloperEmail">
            <summary>The email address which handles support for Animancer.</summary>
        </member>
        <member name="F:Animancer.Strings.EditorOnly">
            <summary>The conditional compilation symbol for editor-only code.</summary>
        </member>
        <member name="F:Animancer.Strings.Assert">
            <summary>The conditional compilation symbol for assertions.</summary>
        </member>
        <member name="F:Animancer.Strings.ProOnlyTag">
            <summary>[Internal]
            A prefix for tooltips on Pro-Only features.
            <para></para>
            "[Pro-Only] " in Animancer Lite or "" in Animancer Pro.
            </summary>
        </member>
        <member name="F:Animancer.Strings.NoRename">
            <summary>[Internal] [Lite-Only]
            Disables member renaming in a [<see cref="T:System.Reflection.ObfuscationAttribute"/>].
            </summary>
        </member>
        <member name="T:Animancer.Strings.DocsURLs">
            <summary>[Editor-Only] URLs of various documentation pages.</summary>
        </member>
        <member name="T:Animancer.Validate">
            <summary>
            Enforces various rules throughout the system, most of which are compiled out if UNITY_ASSERTIONS is not defined
            (by default, it is defined in the Unity Editor and in Development Builds).
            </summary>
        </member>
        <member name="M:Animancer.Validate.NotLegacy(UnityEngine.AnimationClip)">
            <summary>[Assert]
            Throws if the `clip` is marked as <see cref="P:UnityEngine.AnimationClip.legacy"/>.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.Validate.Root(Animancer.AnimancerNode,Animancer.AnimancerPlayable)">
            <summary>[Assert]
            Throws if the <see cref="F:Animancer.AnimancerNode.Root"/> is not the `root`.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.Validate.Parent(Animancer.AnimancerState,Animancer.AnimancerNode)">
            <summary>[Assert]
            Throws if the <see cref="P:Animancer.AnimancerState.Parent"/> is not the `parent`.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.Validate.RemoveChild(Animancer.AnimancerState,System.Collections.Generic.IList{Animancer.AnimancerState})">
            <summary>[Assert]
            Throws if the `state` was not actually assigned to its specified <see cref="P:Animancer.AnimancerNode.Index"/> in
            the `states`.
            </summary>
            <exception cref="T:System.InvalidOperationException"/>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown if the <see cref="P:Animancer.AnimancerNode.Index"/> is larger than the number of `states`.
            </exception>
        </member>
        <member name="M:Animancer.Validate.FadeDuration(System.Single@,System.String)">
            <summary>[Internal] [Lite-Only]
            Ensures that only the <see cref="F:Animancer.AnimancerPlayable.DefaultFadeDuration"/> can be used (warn in Editor,
            enforce at Runtime).
            </summary>
        </member>
        <member name="M:Animancer.Validate.Weight(System.Single@,System.String,System.String)">
            <summary>[Internal] [Lite-Only]
            Ensures that only 0 or 1 weight can be used (warn in Editor, enforce at Runtime).
            </summary>
        </member>
        <member name="M:Animancer.Validate.Speed(System.Single@)">
            <summary>[Internal] [Lite-Only]
            Ensures that only 1 speed can be used (warn in Editor, enforce at Runtime).
            </summary>
        </member>
        <member name="M:Animancer.Validate.Time(System.Single@)">
            <summary>[Internal] [Lite-Only]
            Ensures that only 0 time can be used (warn in Editor, enforce at Runtime).
            </summary>
        </member>
        <member name="M:Animancer.Validate.NodeType(Animancer.AnimancerNode)">
            <summary>[Internal] [Lite-Only]
            Ensures that only inbuilt <see cref="T:Animancer.AnimancerNode"/> types can be used (warn in Editor, enforce at
            Runtime).
            </summary>
        </member>
        <member name="M:Animancer.Validate.UpdatableType(Animancer.IAnimancerUpdatable)">
            <summary>[Internal] [Lite-Only]
            Ensures that only inbuilt <see cref="T:Animancer.AnimancerNode"/> types can be used (warn in Editor, enforce at
            Runtime).
            </summary>
        </member>
        <member name="F:Animancer.Validate.ProOnlyMessage">
            <summary>[Lite-Only]
            A message which explains that some features are only available in the Unity Editor for trial purposes in
            Animancer Lite, but not at runtime.
            </summary>
        </member>
        <member name="P:Animancer.Validate.KeepLoggingProOnlyFeatures">
            <summary>[Lite-Only]
            When a Pro-Only feature is used it will log a message and decrement this value (default 0). Once it becomes
            negative, no more messages will be logged.
            </summary>
        </member>
        <member name="M:Animancer.Validate.LogProOnlyFeature(System.String)">
            <summary>[Internal] [Lite-Only]
            Logs a message the first time a Pro-Only feature is used, then does nothing on subsequent calls.
            </summary>
        </member>
        <member name="T:Animancer.IAnimancerComponent">
            <summary>
            Interface for components that manage an <see cref="T:Animancer.AnimancerPlayable"/>.
            </summary>
            <remarks>
            Despite the name, this interface is not necessarily limited to only components.
            <para></para>
            This interface allows Animancer Lite to reference an <see cref="!:AnimancerComponent"/> inside the pre-compiled
            DLL while allowing that component to remain outside as a regular script. Otherwise everything would need to be
            in the DLL which would cause Unity to lose all the script references when upgrading from Animancer Lite to Pro.
            </remarks>
        </member>
        <member name="P:Animancer.IAnimancerComponent.enabled">
            <summary>Indicates whether this component will be updated.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.gameObject">
            <summary>The <see cref="T:UnityEngine.GameObject"/> this component is attached to.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.Animator">
            <summary>The <see cref="T:UnityEngine.Animator"/> component which this script controls.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.Playable">
            <summary>The internal system which manages the playing animations.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.IsPlayableInitialised">
            <summary>Indicates whether the <see cref="P:Animancer.IAnimancerComponent.Playable"/> has been initialised (is not null).</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.ResetOnDisable">
            <summary>Determines whether the object will be reset to its original values when disabled.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.UpdateMode">
            <summary>
            Determines when animations are updated and which time source is used. This property is mainly a wrapper
            around the <see cref="P:UnityEngine.Animator.updateMode"/>.
            </summary>
        </member>
        <member name="M:Animancer.IAnimancerComponent.GetKey(UnityEngine.AnimationClip)">
            <summary>
            Returns the dictionary key to use for the `clip`.
            </summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.AnimatorFieldName">
            <summary>[Editor-Only] The name of the serialized backing field for the <see cref="P:Animancer.IAnimancerComponent.Animator"/> property.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.InitialUpdateMode">
            <summary>[Editor-Only] The <see cref="P:Animancer.IAnimancerComponent.UpdateMode"/> what was first used when this script initialised.</summary>
        </member>
        <member name="T:Animancer.IAnimancerRoot">
            <summary>
            Interface for components to indicate which <see cref="T:UnityEngine.GameObject"/> is the root of a character when
            <see cref="M:Animancer.Editor.AnimancerEditorUtilities.FindRoot(UnityEngine.GameObject)"/> is called.
            </summary>
        </member>
        <member name="P:Animancer.IAnimancerRoot.transform">
             <summary>
             The <see cref="T:UnityEngine.Transform"/> to search for <see cref="T:UnityEngine.AnimationClip"/>s beneath.
             </summary>
            
             <example>
             Implementing this interface in a <see cref="T:UnityEngine.MonoBehaviour"/> will automatically inherit this property so
             you do not need to do anything else:
             <code>public class MyComponent : MonoBehaviour, IAnimancerRoot
             {
             }</code>
             But if you want to have your script point to a different object as the root, you can explicitly implement
             this property:
             <code>public class MyComponent : MonoBehaviour, IAnimancerRoot
             {
                 Transform IAnimancerRoot.transform { get { return ???; } }
             }</code>
             </example>
        </member>
        <member name="T:Animancer.IAnimancerTransition">
            <summary>
            An object that can create an <see cref="T:Animancer.AnimancerState"/> and manage the details of how it should be played.
            <para></para>
            Transitions are generally used as arguments for <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>.
            </summary>
        </member>
        <member name="M:Animancer.IAnimancerTransition.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.AnimancerState"/> connected to the `layer`.
            </summary>
            <remarks>
            The first time a transition is used on an object, this method is called to create the state and register it
            in the internal dictionary using the <see cref="P:Animancer.IHasKey.Key"/> so that it can be reused later on.
            </remarks>
        </member>
        <member name="P:Animancer.IAnimancerTransition.CrossFadeFromStart">
            <summary>
            When a transition is passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>, this property
            determines whether it needs to fade in from the start of the animation.
            </summary>
            <remarks>
            Essentially, this property should be true if <see cref="M:Animancer.IAnimancerTransition.Apply(Animancer.AnimancerState)"/> is going to set the
            <see cref="P:Animancer.AnimancerState.Time"/> to ensure a smooth transition.
            </remarks>
        </member>
        <member name="P:Animancer.IAnimancerTransition.FadeDuration">
            <summary>The amount of time the transition should take (in seconds).</summary>
        </member>
        <member name="M:Animancer.IAnimancerTransition.Apply(Animancer.AnimancerState)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/> to apply any modifications to the `state`.
            </summary>
            <remarks>
            Unlike <see cref="M:Animancer.IAnimancerTransition.CreateState(Animancer.AnimancerLayer)"/>, this method is called every time the transition is used so it can do
            things like set the <see cref="P:Animancer.AnimancerState.Events"/> or <see cref="P:Animancer.AnimancerState.Time"/>.
            <para></para>
            Note that if it is going to set the <see cref="P:Animancer.AnimancerState.Time"/> then <see cref="P:Animancer.IAnimancerTransition.CrossFadeFromStart"/>
            should return true to ensure a smooth transition.
            </remarks>
        </member>
        <member name="T:Animancer.IAnimancerTransitionDetailed">
            <summary>
            An <see cref="T:Animancer.IAnimancerTransition"/> with some additional details for the Unity Editor GUI.
            </summary>
        </member>
        <member name="P:Animancer.IAnimancerTransitionDetailed.NormalizedStartTime">
            <summary>Determines what <see cref="P:Animancer.AnimancerState.NormalizedTime"/> to start the animation at.</summary>
        </member>
        <member name="P:Animancer.IAnimancerTransitionDetailed.Speed">
            <summary>Determines how fast the animation plays (1x = normal speed).</summary>
        </member>
        <member name="P:Animancer.IAnimancerTransitionDetailed.MaximumDuration">
            <summary>The maximum amount of time the animation is expected to take (in seconds).</summary>
        </member>
        <member name="M:Animancer.IAnimancerTransitionDetailed.AddItemsToContextMenu(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,Animancer.Editor.Serialization.PropertyAccessor)">
            <summary>[Editor-Only] Adds context menu functions for this transition.</summary>
        </member>
        <member name="T:Animancer.IAnimancerUpdatable">
            <summary>
            An object that can be updated during <see cref="M:UnityEngine.Playables.PlayableBehaviour.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)"/>.
            </summary>
        </member>
        <member name="M:Animancer.IAnimancerUpdatable.EarlyUpdate">
            <summary>Called at the start of every update.</summary>
        </member>
        <member name="M:Animancer.IAnimancerUpdatable.LateUpdate">
            <summary>Called at the end of every update.</summary>
        </member>
        <member name="M:Animancer.IAnimancerUpdatable.OnDestroy">
            <summary>Called by <see cref="M:Animancer.AnimancerPlayable.Destroy"/> if this object is currently being updated.</summary>
        </member>
        <member name="T:Animancer.IAnimationClipSource">
            <summary>
            Proxy for an identical interface introduced in Unity 2018.3 to have a class provide its own list of
            <see cref="T:UnityEngine.AnimationClip"/>s to the Animation Window without an Animator Controller.
            </summary>
        </member>
        <member name="T:Animancer.IAnimationClipCollection">
            <summary>
            A variant of <see cref="T:Animancer.IAnimationClipSource"/> which uses a <see cref="T:System.Collections.Generic.ICollection`1"/> instead of a
            <see cref="T:System.Collections.Generic.List`1"/> so that it can take a <see cref="T:System.Collections.Generic.HashSet`1"/> to efficiently avoid adding duplicates.
            <see cref="T:Animancer.AnimancerUtilities"/> contains various extension methods for this purpose.
            <para></para>
            <see cref="T:Animancer.IAnimationClipSource"/> still needs to be the main point of entry for the Animation Window, so this
            interface is only used internally.
            </summary>
        </member>
        <member name="M:Animancer.IAnimationClipCollection.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>Gathers all the animations associated with this object.</summary>
        </member>
        <member name="T:Animancer.IHasKey">
            <summary>
            Exposes a <see cref="P:Animancer.IHasKey.Key"/> object that can be used for dictionaries and hash sets.
            </summary>
        </member>
        <member name="P:Animancer.IHasKey.Key">
            <summary>
            An identifier object that can be used for dictionaries and hash sets.
            </summary>
        </member>
        <member name="T:Animancer.IPlayableWrapper">
            <summary>
            Interface for objects that manage a <see cref="T:UnityEngine.Playables.Playable"/>.
            </summary>
        </member>
        <member name="P:Animancer.IPlayableWrapper.Parent">
            <summary>The object which receives the output of the <see cref="P:Animancer.IPlayableWrapper.Playable"/>.</summary>
        </member>
        <member name="P:Animancer.IPlayableWrapper.Playable">
            <summary>The <see cref="T:UnityEngine.Playables.Playable"/> managed by this object.</summary>
        </member>
        <member name="P:Animancer.IPlayableWrapper.KeepChildrenConnected">
            <summary>
            Indicates whether child playables should stay connected to the graph at all times.
            <para></para>
            If false, playables will be disconnected from the graph while they are at 0 weight to stop it from
            evaluating them every frame which is generally more efficient.
            </summary>
        </member>
        <member name="P:Animancer.IPlayableWrapper.Speed">
             <summary>
             How fast the <see cref="T:UnityEngine.Time"/> is advancing every frame.
             <para></para>
             1 is the normal speed.
             <para></para>
             A negative value will play the animation backwards.
             <para></para>
             Animancer Lite does not allow this value to be changed in a runtime build.
             </summary>
            
             <example>
             <code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 state.Speed = 1;// Normal speed.
                 state.Speed = 2;// Double speed.
                 state.Speed = 0.5f;// Half speed.
                 state.Speed = -1;// Normal speed playing backwards.
             }
             </code>
             </example>
        </member>
        <member name="T:Animancer.CartesianMixerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which blends an array of other states together based on a two dimensional
            parameter and thresholds using Gradient Band Interpolation.
            <para></para>
            This mixer type is similar to the 2D Freeform Cartesian Blend Type in Mecanim Blend Trees.
            </summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.#ctor(Animancer.AnimancerPlayable)">
            <summary>
            Constructs a new <see cref="T:Animancer.CartesianMixerState"/> without connecting it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            </summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.#ctor(Animancer.AnimancerLayer)">
            <summary>
            Constructs a new <see cref="T:Animancer.CartesianMixerState"/> and connects it to the `layer`.
            </summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.#ctor(Animancer.AnimancerNode,System.Int32)">
            <summary>
            Constructs a new <see cref="T:Animancer.CartesianMixerState"/> and connects it to the `parent` at the specified
            `index`.
            </summary>
        </member>
        <member name="F:Animancer.CartesianMixerState._BlendFactors">
            <summary>Precalculated values to speed up the recalculation of weights.</summary>
        </member>
        <member name="F:Animancer.CartesianMixerState._BlendFactorsDirty">
            <summary>Indicates whether the <see cref="F:Animancer.CartesianMixerState._BlendFactors"/> need to be recalculated.</summary>
        </member>
        <member name="P:Animancer.CartesianMixerState.ParameterX">
            <summary>Gets or sets Parameter.x.</summary>
        </member>
        <member name="P:Animancer.CartesianMixerState.ParameterY">
            <summary>Gets or sets Parameter.y.</summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.OnThresholdsChanged">
            <summary>
            Called whenever the thresholds are changed. Indicates that the internal blend factors need to be
            recalculated and calls <see cref="M:Animancer.CartesianMixerState.RecalculateWeights"/>.
            </summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.RecalculateWeights">
            <summary>
            Recalculates the weights of all <see cref="P:Animancer.ManualMixerState.States"/> based on the current value of the
            <see cref="P:Animancer.MixerState`1.Parameter"/> and the <see cref="F:Animancer.MixerState`1._Thresholds"/>.
            </summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.AppendParameter(System.Text.StringBuilder)">
            <summary>Appends the current parameter values of this mixer.</summary>
        </member>
        <member name="P:Animancer.CartesianMixerState.ParameterCount">
            <summary>The number of parameters being managed by this state.</summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.CartesianMixerState.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.CartesianMixerState.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.CartesianMixerState.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="T:Animancer.DirectionalMixerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which blends an array of other states together based on a two dimensional
            parameter and thresholds using Polar Gradient Band Interpolation.
            <para></para>
            This mixer type is similar to the 2D Freeform Directional Blend Type in Mecanim Blend Trees.
            </summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.#ctor(Animancer.AnimancerPlayable)">
            <summary>
            Constructs a new <see cref="T:Animancer.DirectionalMixerState"/> without connecting it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            </summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.#ctor(Animancer.AnimancerLayer)">
            <summary>
            Constructs a new <see cref="T:Animancer.DirectionalMixerState"/> and connects it to the `layer`.
            </summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.#ctor(Animancer.AnimancerNode,System.Int32)">
            <summary>
            Constructs a new <see cref="T:Animancer.DirectionalMixerState"/> and connects it to the `parent` at the specified
            `index`.
            </summary>
        </member>
        <member name="F:Animancer.DirectionalMixerState._ThresholdMagnitudes">
            <summary>Precalculated magnitudes of all thresholds to speed up the recalculation of weights.</summary>
        </member>
        <member name="F:Animancer.DirectionalMixerState._BlendFactors">
            <summary>Precalculated values to speed up the recalculation of weights.</summary>
        </member>
        <member name="F:Animancer.DirectionalMixerState._BlendFactorsDirty">
            <summary>Indicates whether the <see cref="F:Animancer.DirectionalMixerState._BlendFactors"/> need to be recalculated.</summary>
        </member>
        <member name="F:Animancer.DirectionalMixerState.AngleFactor">
            <summary>The multiplier that controls how much an angle (in radians) is worth compared to normalized distance.</summary>
        </member>
        <member name="P:Animancer.DirectionalMixerState.ParameterX">
            <summary>Gets or sets Parameter.x.</summary>
        </member>
        <member name="P:Animancer.DirectionalMixerState.ParameterY">
            <summary>Gets or sets Parameter.y.</summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.OnThresholdsChanged">
            <summary>
            Called whenever the thresholds are changed. Indicates that the internal blend factors need to be
            recalculated and calls <see cref="M:Animancer.DirectionalMixerState.RecalculateWeights"/>.
            </summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.RecalculateWeights">
            <summary>
            Recalculates the weights of all <see cref="P:Animancer.ManualMixerState.States"/> based on the current value of the
            <see cref="P:Animancer.MixerState`1.Parameter"/> and the thresholds.
            </summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.AppendParameter(System.Text.StringBuilder)">
            <summary>Appends the current parameter values of this mixer.</summary>
        </member>
        <member name="P:Animancer.DirectionalMixerState.ParameterCount">
            <summary>The number of parameters being managed by this state.</summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.DirectionalMixerState.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.DirectionalMixerState.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.DirectionalMixerState.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="T:Animancer.LinearMixerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which blends an array of other states together using linear interpolation
            between the specified thresholds.
            <para></para>
            This mixer type is similar to the 1D Blend Type in Mecanim Blend Trees.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.#ctor(Animancer.AnimancerPlayable)">
            <summary>
            Constructs a new <see cref="T:Animancer.LinearMixerState"/> without connecting it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.#ctor(Animancer.AnimancerLayer)">
            <summary>
            Constructs a new <see cref="T:Animancer.LinearMixerState"/> and connects it to the `layer`.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.#ctor(Animancer.AnimancerNode,System.Int32)">
            <summary>
            Constructs a new <see cref="T:Animancer.LinearMixerState"/> and connects it to the `parent` at the specified
            `index`.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Initialise(UnityEngine.AnimationClip[],System.Single,System.Single)">
            <summary>
            Initialises the <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/> and <see cref="P:Animancer.ManualMixerState.States"/> with one
            state per clip and assigns thresholds evenly spaced between the specified min and max (inclusive).
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Initialise(UnityEngine.AnimationClip,UnityEngine.AnimationClip,System.Single,System.Single)">
            <summary>
            Initialises the <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/> with two ports and connects two states to them for
            the specified clips at the specified thresholds (default 0 and 1).
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Initialise(UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip,System.Single,System.Single,System.Single)">
            <summary>
            Initialises the <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/> with three ports and connects three states to them for
            the specified clips at the specified thresholds (default -1, 0, and 1).
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.OnThresholdsChanged">
            <summary>
            Called whenever the thresholds are changed. In the Unity Editor this method calls
            <see cref="M:Animancer.LinearMixerState.AssertThresholdsSorted"/> then <see cref="M:Animancer.LinearMixerState.RecalculateWeights"/> while at runtime it only calls
            the latter.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.AssertThresholdsSorted">
            <summary>
            Throws an <see cref="T:System.ArgumentException"/> unless the thresholds are sorted from lowest to highest.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.LinearMixerState.RecalculateWeights">
            <summary>
            Recalculates the weights of all <see cref="P:Animancer.ManualMixerState.States"/> based on the current value of the
            <see cref="P:Animancer.MixerState`1.Parameter"/> and the thresholds.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.AssignLinearThresholds(System.Single,System.Single)">
            <summary>
            Assigns the thresholds to be evenly spaced between the specified min and max (inclusive).
            </summary>
        </member>
        <member name="P:Animancer.LinearMixerState.ParameterCount">
            <summary>The number of parameters being managed by this state.</summary>
        </member>
        <member name="M:Animancer.LinearMixerState.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.LinearMixerState.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.LinearMixerState.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.LinearMixerState.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="T:Animancer.LinearMixerState.Transition">
            <summary>
            A serializable <see cref="T:Animancer.IAnimancerTransition"/> which can create a <see cref="T:Animancer.LinearMixerState"/> when
            passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            </remarks>
        </member>
        <member name="M:Animancer.LinearMixerState.Transition.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.LinearMixerState"/> connected to the `layer`.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Transition.AddItemsToContextMenu(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,Animancer.Editor.Serialization.PropertyAccessor)">
            <summary>[Editor-Only] Adds context menu functions for this transition.</summary>
        </member>
        <member name="T:Animancer.LinearMixerState.Transition.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.LinearMixerState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Transition.Drawer.AddItemsToContextMenu(UnityEditor.GenericMenu)">
            <summary>
            Fills the `menu` with functions relevant to the `rootProperty`.
            </summary>
        </member>
        <member name="T:Animancer.ManualMixerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which blends multiple child states. Unlike other mixers, this class does not
            perform any automatic weight calculations, it simple allows you to control the weight of all states manually.
            <para></para>
            This mixer type is similar to the Direct Blend Type in Mecanim Blend Trees.
            </summary>
        </member>
        <member name="P:Animancer.ManualMixerState.States">
            <summary>The states managed by this mixer.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.PortCount">
            <summary>The number of input ports in the <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/>.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.ChildStates">
            <summary>Returns the <see cref="P:Animancer.ManualMixerState.States"/> array.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.NewTime">
            <summary>
            The weighted average <see cref="P:Animancer.AnimancerState.Time"/> of each child state according to their
            <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Length">
            <summary>
            The weighted average <see cref="P:Animancer.AnimancerState.Length"/> of each child state according to their
            <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.#ctor(Animancer.AnimancerPlayable)">
            <summary>
            Constructs a new <see cref="T:Animancer.LinearMixerState"/> without connecting it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.#ctor(Animancer.AnimancerLayer)">
            <summary>
            Constructs a new <see cref="T:Animancer.LinearMixerState"/> and connects it to the `layer`.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.#ctor(Animancer.AnimancerNode,System.Int32)">
            <summary>
            Constructs a new <see cref="T:Animancer.LinearMixerState"/> and connects it to the `parent` at the specified
            `index`.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Initialise(System.Int32)">
            <summary>
            Initialises this mixer with the specified number of ports which can be filled individually by <see cref="M:Animancer.ManualMixerState.CreateState(System.Int32,UnityEngine.AnimationClip)"/>.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Initialise(UnityEngine.AnimationClip[])">
            <summary>
            Initialises this mixer with one state per clip.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.CreateState(System.Int32,UnityEngine.AnimationClip)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip` with this
            <see cref="T:Animancer.MixerState"/> as its parent.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.OnAddChild(Animancer.AnimancerState)">
            <summary>Connects the `state` to this mixer at its <see cref="P:Animancer.AnimancerNode.Index"/>.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.OnRemoveChild(Animancer.AnimancerState)">
            <summary>Disconnects the `state` from this mixer at its <see cref="P:Animancer.AnimancerNode.Index"/>.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Destroy">
            <summary>
            Destroys the <see cref="T:UnityEngine.Playables.Playable"/> of this mixer and its <see cref="P:Animancer.ManualMixerState.States"/>.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.CalculateTotalChildWeight">
            <summary>
            Calculates the sum of the <see cref="P:Animancer.AnimancerNode.Weight"/> of all child states.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.DestroyChildren">
            <summary>
            Destroys all <see cref="P:Animancer.ManualMixerState.States"/> connected to this mixer. This operation cannot be undone.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.RecalculateWeights">
            <summary>
            Does nothing. Manual mixers don't automatically recalculate their weights.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.DisableRemainingStates(System.Int32)">
            <summary>
            Sets the weight of all states after the `previousIndex` to 0.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.GetNextState(System.Int32@)">
            <summary>
            Returns the state at the specified `index` if it isn't null, otherwise increments the index and checks
            again. Returns null if no state is found by the end of the <see cref="P:Animancer.ManualMixerState.States"/> array.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.NormalizeWeights(System.Single)">
            <summary>
            Divides the weight of all states by the `totalWeight` so that they all add up to 1.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.GetDisplayKey(Animancer.AnimancerState)">
            <summary>Gets a user-friendly key to identify the `state` in the Inspector.</summary>
        </member>
        <member name="T:Animancer.ManualMixerState.Transition`1">
            <summary>
            Base class for serializable <see cref="T:Animancer.IAnimancerTransition"/>s which can create a particular type of
            <see cref="T:Animancer.ManualMixerState"/> when passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            <para></para>
            Even though it has the <see cref="T:System.SerializableAttribute"/>, this class won't actually get serialized
            by Unity because it's generic and abstract. Each child class still needs to include the attribute.
            </remarks>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition`1.Clips">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.ClipState.Clip"/> to use for each state in the mixer.
            </summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition`1.Speeds">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.AnimancerNode.Speed"/> to use for each state in the mixer.
            <para></para>
            If the size of this array doesn't match the <see cref="P:Animancer.ManualMixerState.Transition`1.Clips"/>, it will be ignored.
            </summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition`1.SynchroniseChildren">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.MixerState.SynchroniseChildren"/> flags for each state in the mixer.
            <para></para>
            The array can be null or empty. Any elements not in the array will be treated as true.
            </summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition`1.MaximumDuration">
            <summary>[<see cref="T:Animancer.IAnimancerTransitionDetailed"/>]
            The maximum amount of time the animation is expected to take (in seconds).
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition`1.InitialiseState">
            <summary>
            Initialises the <see cref="P:Animancer.AnimancerState.Transition`1.State"/> immediately after it is created.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition`1.Animancer#IAnimationClipCollection#GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>Adds the <see cref="P:Animancer.ManualMixerState.Transition`1.Clips"/> to the collection.</summary>
        </member>
        <member name="T:Animancer.ManualMixerState.Transition">
            <summary>
            A serializable <see cref="T:Animancer.IAnimancerTransition"/> which can create a <see cref="T:Animancer.ManualMixerState"/> when
            passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            </remarks>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ManualMixerState"/> connected to the `layer`.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.AddItemsToContextMenu(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,Animancer.Editor.Serialization.PropertyAccessor)">
            <summary>[Editor-Only] Adds context menu functions for this transition.</summary>
        </member>
        <member name="T:Animancer.ManualMixerState.Transition.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.ManualMixerState.Transition"/>.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition.Drawer.CurrentProperty">
            <summary>
            The property this drawer is currently drawing.
            <para></para>
            Normally each property has its own drawer, but arrays share a single drawer for all elements.
            </summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition.Drawer.CurrentClips">
            <summary>The <see cref="P:Animancer.ManualMixerState.Transition`1.Clips"/> field.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition.Drawer.CurrentSpeeds">
            <summary>The <see cref="P:Animancer.ManualMixerState.Transition`1.Speeds"/> field.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition.Drawer.CurrentSynchroniseChildren">
            <summary>The <see cref="P:Animancer.ManualMixerState.Transition`1.SynchroniseChildren"/> field.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.GatherDetails(UnityEditor.SerializedProperty)">
            <summary>
            Gather the details of the `property`.
            <para></para>
            This method gets called by every <see cref="M:Animancer.ManualMixerState.Transition.Drawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/> and <see cref="M:Animancer.ManualMixerState.Transition.Drawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/> call since
            Unity uses the same <see cref="T:UnityEditor.PropertyDrawer"/> instance for each element in a collection, so it
            needs to gather the details associated with the current property.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.GatherSubProperties(UnityEditor.SerializedProperty)">
            <summary>
            Called every time a `property` is drawn to find the relevant child properties and store them to be
            used in <see cref="M:Animancer.ManualMixerState.Transition.Drawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/> and <see cref="M:Animancer.ManualMixerState.Transition.Drawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/>.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.GatherSubPropertiesStatic(UnityEditor.SerializedProperty)">
            <summary>
            Called every time a `property` is drawn to find the relevant child properties and store them to be
            used in <see cref="M:Animancer.ManualMixerState.Transition.Drawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/> and <see cref="M:Animancer.ManualMixerState.Transition.Drawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/>.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            Calculates the number of vertical pixels the `property` will occupy when it is drawn.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            Draws the root `property` GUI and calls
            <see cref="M:Animancer.Editor.TransitionDrawer.DoPropertyGUI(UnityEngine.Rect@,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/> for each of its children.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.SplitListRect(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@)">
            <summary>Splits the specified `area` into separate sections.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoStateListHeaderGUI(UnityEngine.Rect)">
            <summary>Draws the headdings of the state list.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoAnimationLabelGUI(UnityEngine.Rect)">
            <summary>Draws an "Animation" label.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoSpeedLabelGUI(UnityEngine.Rect)">
            <summary>Draws a "Speed" label.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoSyncLabelGUI(UnityEngine.Rect)">
            <summary>Draws a "Sync" label.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.GetElementHeight(System.Int32)">
            <summary>Calculates the height of the state at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoElementGUI(UnityEngine.Rect,System.Int32,System.Boolean,System.Boolean)">
            <summary>Draws the GUI of the state at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoElementGUI(UnityEngine.Rect,System.Int32,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty)">
            <summary>Draws the GUI of the state at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoElementGUI(UnityEngine.Rect,UnityEngine.Rect,UnityEngine.Rect,System.Int32,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty)">
            <summary>Draws the GUI of the state at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoSyncToggleGUI(UnityEngine.Rect,System.Int32)">
            <summary>
            Draws a toggle to enable or disable <see cref="P:Animancer.MixerState.SynchroniseChildren"/> for the child at
            the specified `index`.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.OnAddElement(UnityEditorInternal.ReorderableList)">
            <summary>
            Called when adding a new state to the list to ensure that any other relevant arrays have new
            elements added as well.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.OnRemoveElement(UnityEditorInternal.ReorderableList)">
            <summary>
            Called when removing a state from the list to ensure that any other relevant arrays have elements
            removed as well.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.RemoveArrayElement(UnityEditor.SerializedProperty,System.Int32)">
            <summary>
            Removes the specified array element from the `property`.
            <para></para>
            If the element isn't at its default value, the first call to
            <see cref="M:UnityEditor.SerializedProperty.DeleteArrayElementAtIndex(System.Int32)"/> will only reset it, so this method will
            call it again if necessary to ensure that it actually gets removed.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.OnReorderList(UnityEditorInternal.ReorderableList,System.Int32,System.Int32)">
            <summary>
            Called when reordering states in the list to ensure that any other relevant arrays have their
            corresponding elements reordered as well.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.InitialiseSpeeds(System.Int32)">
            <summary>
            Initialises every element in the <see cref="P:Animancer.ManualMixerState.Transition.Drawer.CurrentSpeeds"/> array from the `start` to the end of
            the array to contain a value of 1.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.TryCollapseSpeeds">
            <summary>
            If every element in the <see cref="P:Animancer.ManualMixerState.Transition.Drawer.CurrentSpeeds"/> array is 1, this method sets the array size to 0.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.AddItemsToContextMenu(UnityEditor.GenericMenu,UnityEditor.SerializedProperty)">
            <summary>[Editor-Only] Adds context menu functions for this transition.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.NormalizeDurations(UnityEditor.SerializedProperty)">
            <summary>
            Recalculates the <see cref="P:Animancer.ManualMixerState.Transition.Drawer.CurrentSpeeds"/> depending on the <see cref="P:UnityEngine.AnimationClip.length"/> of
            their animations so that they all take the same amount of time to play fully.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.AddPropertyModifierFunction(UnityEditor.GenericMenu,System.String,System.Action{UnityEditor.SerializedProperty})">
            <summary>
            Adds a menu function that will call <see cref="M:Animancer.ManualMixerState.Transition.Drawer.GatherSubPropertiesStatic(UnityEditor.SerializedProperty)"/> then perform the specified
            `action`.
            </summary>
        </member>
        <member name="T:Animancer.MixerState">
            <summary>[Pro-Only]
            Base class for <see cref="T:Animancer.AnimancerState"/>s which blend other states together.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.PortCount">
            <summary>The number of input ports in the <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="P:Animancer.MixerState.KeepChildrenConnected">
            <summary>Mixers should keep child playables connected to the graph at all times.</summary>
        </member>
        <member name="P:Animancer.MixerState.Clip">
            <summary>An <see cref="T:Animancer.MixerState"/> has no <see cref="T:UnityEngine.AnimationClip"/>.</summary>
        </member>
        <member name="P:Animancer.MixerState.ChildStates">
            <summary>
            Returns the collection of states connected to this mixer. Note that some elements may be null.
            <para></para>
            Getting an enumerator that automatically skips over null states is slower and creates garbage, so
            internally we use this property and perform null checks manually even though it increases the code
            complexity a bit.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.GetEnumerator">
            <summary>
            Returns an enumerator through each state connected to this mixer.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.AreWeightsDirty">
            <summary>Indicates whether the weights of all child states should be recalculated.</summary>
        </member>
        <member name="P:Animancer.MixerState.IsPlaying">
            <summary>
            Determines whether the states in this mixer are playing.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.IsLooping">
            <summary>Returns true if any child state is looping.</summary>
        </member>
        <member name="P:Animancer.MixerState.SynchroniseChildren">
            <summary>
            Indicates which children should have their <see cref="P:Animancer.AnimancerNode.Speed"/> modified in order to keep
            their <see cref="P:Animancer.AnimancerState.NormalizedTime"/> at approximately the same value.
            <para></para>
            The array can be null or empty. Any elements not in the array will be treated as true.
            </summary>
            <remarks>
            The <see cref="P:Animancer.AnimancerNode.Speed"/> is modified to allow each state to trigger its events properly
            where setting the <see cref="P:Animancer.AnimancerState.NormalizedTime"/> directly would prevent any events.
            </remarks>
        </member>
        <member name="M:Animancer.MixerState.#ctor(Animancer.AnimancerPlayable)">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState"/> without connecting it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.#ctor(Animancer.AnimancerLayer)">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState"/> and connects it to the `layer`.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.#ctor(Animancer.AnimancerNode,System.Int32)">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState"/> and connects it to the `parent` at the specified
            `index`.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.CreateState(System.Int32,UnityEngine.AnimationClip)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip` with this
            <see cref="T:Animancer.MixerState"/> as its parent.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.ChildCount">
            <summary>The number of states using this mixer as their <see cref="P:Animancer.AnimancerState.Parent"/>.</summary>
        </member>
        <member name="M:Animancer.MixerState.GetChild(System.Int32)">
            <summary>
            Returns the state connected to the specified `index` as a child of this mixer.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.Update(System.Boolean@)">
            <summary>
            Updates the time of this mixer and all of its child states.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.ApplySynchroniseChildren(System.Boolean@)">
            <summary>Applies the effects of <see cref="P:Animancer.MixerState.SynchroniseChildren"/>.</summary>
        </member>
        <member name="M:Animancer.MixerState.RecalculateWeights">
            <summary>
            Recalculates the weights of all <see cref="P:Animancer.ManualMixerState.States"/> based on the current value of the
            <see cref="P:Animancer.MixerState`1.Parameter"/> and the thresholds.
            <para></para>
            Overrides of this method must set <see cref="P:Animancer.MixerState.AreWeightsDirty"/> = false.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.ApplyAnimatorIK">
            <summary>
            Determines whether <c>OnAnimatorIK(int layerIndex)</c> will be called on the animated object for any
            <see cref="P:Animancer.MixerState.ChildStates"/>.
            The initial value is determined by <see cref="P:Animancer.AnimancerLayer.DefaultApplyAnimatorIK"/>.
            <para></para>
            This is equivalent to the "IK Pass" toggle in Animator Controller layers.
            <para></para>
            It requires Unity 2018.1 or newer, however 2018.3 or newer is recommended because a bug in earlier versions
            of the Playables API caused this value to only take effect while a state was at
            <see cref="P:Animancer.AnimancerNode.Weight"/> == 1 which meant that IK would not work while fading between animations.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.ApplyFootIK">
            <summary>
            Indicates whether any of the <see cref="P:Animancer.MixerState.ChildStates"/> in this mixer are applying IK to the character's feet.
            The initial value is determined by <see cref="P:Animancer.AnimancerLayer.DefaultApplyFootIK"/>.
            <para></para>
            This is equivalent to the "Foot IK" toggle in Animator Controller states.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.SetChildrenTime(System.Single,System.Boolean)">
            <summary>
            Sets <see cref="P:Animancer.AnimancerState.Time"/> for all <see cref="P:Animancer.MixerState.ChildStates"/>.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.AverageVelocity">
            <summary>The average velocity of the root motion caused by this state.</summary>
        </member>
        <member name="M:Animancer.MixerState.NormalizeDurations">
            <summary>
            Recalculates the <see cref="P:Animancer.AnimancerState.Duration"/> of all child states so that they add up to 1.
            </summary>
            <exception cref="T:System.NullReferenceException">Thrown if there are any states with no <see cref="P:Animancer.MixerState.Clip"/>.</exception>
        </member>
        <member name="M:Animancer.MixerState.GetDisplayKey(Animancer.AnimancerState)">
            <summary>Gets a user-friendly key to identify the `state` in the Inspector.</summary>
        </member>
        <member name="M:Animancer.MixerState.ToString">
            <summary>
            Returns a string describing the type of this mixer and the name of <see cref="P:Animancer.MixerState.Clip"/>s connected to it.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>]
            Gathers all the animations in this state.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.ParameterCount">
            <summary>The number of parameters being managed by this state.</summary>
        </member>
        <member name="M:Animancer.MixerState.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.GetDrawer">
            <summary>[Editor-Only] Returns a <see cref="T:Animancer.MixerState.Drawer"/> for this state.</summary>
        </member>
        <member name="T:Animancer.MixerState.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.ControllerState"/>.</summary>
        </member>
        <member name="M:Animancer.MixerState.Drawer.#ctor(Animancer.MixerState)">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState.Drawer"/> to manage the Inspector GUI for the `state`.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.Drawer.ParameterCount">
            <summary>The number of parameters being managed by the target state.</summary>
        </member>
        <member name="M:Animancer.MixerState.Drawer.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if the target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.Drawer.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if the target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.Drawer.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if the target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.Drawer.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if the target state doesn't manage any parameters.</exception>
        </member>
        <member name="T:Animancer.MixerState.Transition`2">
            <summary>
            Base class for serializable <see cref="T:Animancer.IAnimancerTransition"/>s which can create a particular type of
            <see cref="T:Animancer.MixerState`1"/> when passed into
            <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            <para></para>
            Even though it has the <see cref="T:System.SerializableAttribute"/>, this class won't actually get serialized
            by Unity because it's generic and abstract. Each child class still needs to include the attribute.
            </remarks>
        </member>
        <member name="P:Animancer.MixerState.Transition`2.Thresholds">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The parameter values at which each of the states are used and blended.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.Transition`2.DefaultParameter">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The initial parameter value to give the mixer when it is first created.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.Transition`2.InitialiseState">
            <summary>
            Initialises the <see cref="P:Animancer.AnimancerState.Transition`1.State"/> immediately after it is created.
            </summary>
        </member>
        <member name="T:Animancer.MixerState.Transition2D">
            <summary>
            A serializable <see cref="T:Animancer.IAnimancerTransition"/> which can create a <see cref="T:Animancer.CartesianMixerState"/> or
            <see cref="T:Animancer.DirectionalMixerState"/> when passed into
            <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.IAnimancerTransition)"/>.
            </summary>
        </member>
        <member name="T:Animancer.MixerState.Transition2D.MixerType">
            <summary>
            A type of <see cref="T:Animancer.MixerState"/> that can be created by a <see cref="T:Animancer.MixerState.Transition2D"/>.
            </summary>
        </member>
        <member name="F:Animancer.MixerState.Transition2D.MixerType.Cartesian">
            <summary><see cref="T:Animancer.CartesianMixerState"/></summary>
        </member>
        <member name="F:Animancer.MixerState.Transition2D.MixerType.Directional">
            <summary><see cref="T:Animancer.DirectionalMixerState"/></summary>
        </member>
        <member name="P:Animancer.MixerState.Transition2D.Type">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The type of <see cref="T:Animancer.MixerState"/> that this transition will create.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.Transition2D.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.CartesianMixerState"/> or <see cref="T:Animancer.DirectionalMixerState"/>
            depending on the <see cref="P:Animancer.MixerState.Transition2D.Type"/> connected to the `layer`.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.Transition2D.AddItemsToContextMenu(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,Animancer.Editor.Serialization.PropertyAccessor)">
            <summary>[Editor-Only] Adds context menu functions for this transition.</summary>
        </member>
        <member name="T:Animancer.MixerState.Transition2D.Drawer">
            <summary>[Editor-Only]
            Draws the Inspector GUI for a <see cref="T:UnityEngine.Vector2"/> <see cref="T:Animancer.MixerState.Transition`2"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.Transition2D.Drawer.#ctor">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState.Transition2D.Drawer"/> using the a wider `thresholdWidth` than usual to accomodate
            both the X and Y values.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.Transition2D.Drawer.AddItemsToContextMenu(UnityEditor.GenericMenu)">
            <summary>
            Fills the `menu` with functions relevant to the `rootProperty`.
            </summary>
        </member>
        <member name="T:Animancer.MixerState.TransitionDrawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.MixerState.Transition`2"/>.</summary>
            <remarks>
            This class would be nested inside <see cref="T:Animancer.MixerState.Transition`2"/>, but the generic parameters
            cause problems in Unity 2019.3.
            </remarks>
        </member>
        <member name="F:Animancer.MixerState.TransitionDrawer.ThresholdWidth">
            <summary>
            The number of horizontal pixels the "Threshold" label occupies.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.TransitionDrawer.ThresholdLabelWidth">
            <summary>
            The number of horizontal pixels the word "Threshold" label occupies when drawn with the standard
            <see cref="P:UnityEngine.GUISkin.label"/> style.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.#ctor">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState.TransitionDrawer"/> using the default <see cref="P:Animancer.MixerState.TransitionDrawer.ThresholdLabelWidth"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.#ctor(System.Single)">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState.TransitionDrawer"/> using a custom width for its threshold labels.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.TransitionDrawer.CurrentThresholds">
            <summary>
            The serialized <see cref="P:Animancer.MixerState.Transition`2.Thresholds"/> of the
            <see cref="P:Animancer.ManualMixerState.Transition.Drawer.CurrentProperty"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.GatherSubProperties(UnityEditor.SerializedProperty)">
            <summary>
            Called every time a `property` is drawn to find the relevant child properties and store them to be
            used in <see cref="M:Animancer.ManualMixerState.Transition.Drawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/> and
            <see cref="M:Animancer.ManualMixerState.Transition.Drawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.SplitListRect(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@)">
            <summary>Splits the specified `area` into separate sections.</summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.DoStateListHeaderGUI(UnityEngine.Rect)">
            <summary>Draws the headdings of the state list.</summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.DoElementGUI(UnityEngine.Rect,System.Int32,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty)">
            <summary>Draws the GUI of the state at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.OnAddElement(UnityEditorInternal.ReorderableList)">
            <summary>
            Called when adding a new state to the list to ensure that any other relevant arrays have new
            elements added as well.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.OnRemoveElement(UnityEditorInternal.ReorderableList)">
            <summary>
            Called when removing a state from the list to ensure that any other relevant arrays have elements
            removed as well.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.OnReorderList(UnityEditorInternal.ReorderableList,System.Int32,System.Int32)">
            <summary>
            Called when reordering states in the list to ensure that any other relevant arrays have their
            corresponding elements reordered as well.
            </summary>
        </member>
        <member name="T:Animancer.MixerState`1">
            <summary>[Pro-Only]
            Base class for <see cref="T:Animancer.MixerState"/>s which blend an array of <see cref="P:Animancer.ManualMixerState.States"/> together
            based on a <see cref="P:Animancer.MixerState`1.Parameter"/>.
            </summary>
        </member>
        <member name="F:Animancer.MixerState`1._Thresholds">
            <summary>
            The parameter values at which each of the <see cref="P:Animancer.ManualMixerState.States"/> are used and blended.
            </summary>
        </member>
        <member name="P:Animancer.MixerState`1.Parameter">
            <summary>The value used to calculate the weights of the <see cref="P:Animancer.ManualMixerState.States"/>.</summary>
        </member>
        <member name="M:Animancer.MixerState`1.HasThresholds">
            <summary>
            Returns true if the thresholds array is not null.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.GetThreshold(System.Int32)">
            <summary>
            Returns the value of the threshold associated with the specified index.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.SetThreshold(System.Int32,`0)">
            <summary>
            Sets the value of the threshold associated with the specified index.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.SetThresholds(`0[])">
            <summary>
            Assigns the specified array as the thresholds to use for blending.
            <para></para>
            WARNING: if you keep a reference to the `thresholds` array you must call <see cref="M:Animancer.MixerState`1.OnThresholdsChanged"/>
            whenever any changes are made to it, otherwise this mixer may not blend correctly.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.ValidateThresholdCount">
            <summary>
            If the <see cref="F:Animancer.MixerState`1._Thresholds"/> don't have the same <see cref="P:System.Array.Length"/> as the
            <see cref="P:Animancer.ManualMixerState.States"/>, this method allocates and assigns a new array of that size.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.OnThresholdsChanged">
            <summary>
            Called whenever the thresholds are changed. By default this method simply indicates that the blend weights
            need recalculating but it can be overridden by child classes to perform validation checks or optimisations.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.CalculateThresholds(System.Func{Animancer.AnimancerState,`0})">
            <summary>
            Calls `calculate` for each of the <see cref="P:Animancer.ManualMixerState.States"/> and stores the returned value as
            the threshold for that state.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.#ctor(Animancer.AnimancerPlayable)">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState`1"/> without connecting it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.#ctor(Animancer.AnimancerLayer)">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState`1"/> and connects it to the `layer`.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.#ctor(Animancer.AnimancerNode,System.Int32)">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState`1"/> and connects it to the `parent` at the specified
            `index`.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.Initialise(System.Int32)">
            <summary>
            Initialises this mixer with the specified number of ports which can be filled individually by <see cref="M:Animancer.MixerState`1.CreateState(System.Int32,UnityEngine.AnimationClip,`0)"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.Initialise(UnityEngine.AnimationClip[],`0[])">
            <summary>
            Initialises the <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/> and <see cref="P:Animancer.ManualMixerState.States"/> with one
            state per clip and assigns the `thresholds`.
            <para></para>
            WARNING: if you keep a reference to the `thresholds` array, you must call
            <see cref="M:Animancer.MixerState`1.OnThresholdsChanged"/> whenever any changes are made to it, otherwise this mixer may not blend
            correctly.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.Initialise(UnityEngine.AnimationClip[],System.Func{Animancer.AnimancerState,`0})">
            <summary>
            Initialises the <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/> and <see cref="P:Animancer.ManualMixerState.States"/> with one
            state per clip and assigns the thresholds by calling `calculateThreshold` for each state.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.CreateState(System.Int32,UnityEngine.AnimationClip,`0)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip` with this
            <see cref="T:Animancer.MixerState"/> as its parent, connects it to the specified `index`, and assigns the
            `threshold` for it.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.GetDisplayKey(Animancer.AnimancerState)">
            <summary>Gets a user-friendly key to identify the `state` in the Inspector.</summary>
        </member>
        <member name="M:Animancer.MixerState`1.AppendDetails(System.Text.StringBuilder,System.String)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerNode.AppendDescription(System.Text.StringBuilder,System.Int32,System.String)"/> to append the details of this node.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.AppendParameter(System.Text.StringBuilder)">
            <summary>Appends the current parameter value of this mixer.</summary>
        </member>
        <member name="T:Animancer.SoloAnimationInternal">
            <summary>Plays a single <see cref="T:UnityEngine.AnimationClip"/> on startup.</summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.Animator">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="T:UnityEngine.Animator"/> component which this script controls.
            <para></para>
            If you need to set this value at runtime you are likely better off using a proper
            <see cref="!:AnimancerComponent"/>.
            </summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.Clip">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="T:UnityEngine.AnimationClip"/> which will be played by <see cref="M:Animancer.SoloAnimationInternal.OnEnable"/>.
            <para></para>
            If you need to set this value at runtime you are likely better off using a proper
            <see cref="!:AnimancerComponent"/>.
            </summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.StopOnDisable">
            <summary>
            If true, disabling this object will stop and rewind the animation. Otherwise it will simply be paused
            and will resume from its current state when it is re-enabled.
            <para></para>
            The default value is true.
            <para></para>
            This property wraps <see cref="P:UnityEngine.Animator.keepAnimatorControllerStateOnDisable"/> and inverts its value.
            The value is serialized by the <see cref="T:UnityEngine.Animator"/>.
            <para></para>
            It requires Unity 2018.1 or newer.
            </summary>
        </member>
        <member name="F:Animancer.SoloAnimationInternal._Graph">
            <summary>
            The <see cref="T:UnityEngine.Playables.PlayableGraph"/> being used to play the <see cref="P:Animancer.SoloAnimationInternal.Clip"/>.
            </summary>
        </member>
        <member name="F:Animancer.SoloAnimationInternal._Playable">
            <summary>
            The <see cref="T:UnityEngine.Animations.AnimationClipPlayable"/> being used to play the <see cref="P:Animancer.SoloAnimationInternal.Clip"/>.
            </summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.IsPlaying">
            <summary>
            Indicates whether the animation is playing (true) or paused (false).
            </summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.Speed">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The speed at which the animation is playing (default 1).
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if this component is not yet <see cref="M:Animancer.SoloAnimationInternal.Awake"/>.</exception>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.FootIK">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            Determines whether Foot IK will be applied to the model (if it is Humanoid).
            <para></para>
            The developers of Unity have states that they believe it looks better with this enabled, but more often
            than not it just makes the legs end up in a slightly different pose to what the animator intended.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if this component is not yet <see cref="M:Animancer.SoloAnimationInternal.Awake"/>.</exception>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.Time">
            <summary>
            The number of seconds that have passed since the start of the animation.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if this component is not yet <see cref="M:Animancer.SoloAnimationInternal.Awake"/>.</exception>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.NormalizedTime">
            <summary>
            The <see cref="P:Animancer.SoloAnimationInternal.Time"/> of this state as a portion of the <see cref="P:UnityEngine.AnimationClip.length"/>, meaning the
            value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes.
            <para></para>
            This value will continue increasing after the animation passes the end of its length and it will either
            freeze in place or start again from the beginning according to whether it is looping or not.
            <para></para>
            The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the
            current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has
            been looped.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if this component is not yet <see cref="M:Animancer.SoloAnimationInternal.Awake"/>.</exception>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.IsInitialised">
            <summary>Indicates whether the <see cref="T:UnityEngine.Playables.PlayableGraph"/> is valid.</summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.Reset">
            <summary>[Editor-Only]
            Called by the Unity Editor when this component is first added (in Edit Mode) and whenever the Reset command
            is executed from its context menu.
            <para></para>
            Tries to find an <see cref="T:UnityEngine.Animator"/> component on this <see cref="T:UnityEngine.GameObject"/> or its
            children or parents (in that order).
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.OnValidate">
            <summary>[Editor-Only]
            Called by the Unity Editor in Edit Mode whenever an instance of this script is loaded or a value is changed
            in the Inspector.
            <para></para>
            Tries to find an <see cref="T:UnityEngine.Animator"/> component on this <see cref="T:UnityEngine.GameObject"/> or its
            parents or children (in that order).
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.Awake">
            <summary>
            Called by Unity when this component is first created.
            <para></para>
            Initialises everything needed to play the <see cref="P:Animancer.SoloAnimationInternal.Clip"/>.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.OnEnable">
            <summary>
            Called by Unity when this component becomes enabled and active.
            <para></para>
            Plays the <see cref="P:Animancer.SoloAnimationInternal.Clip"/> on the target <see cref="P:Animancer.SoloAnimationInternal.Animator"/>.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.Update">
            <summary>
            Called by Unity every frame while this component is enabled and active.
            <para></para>
            Checks if the animation is done so it can pause the <see cref="T:UnityEngine.Playables.PlayableGraph"/> to improve performance.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.OnDisable">
            <summary>
            Called by Unity when this component becomes disabled or inactive.
            <para></para>
            Ensures that the <see cref="F:Animancer.SoloAnimationInternal._Graph"/> is properly cleaned up.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.OnDestroy">
            <summary>
            Called by Unity when this component is destroyed.
            <para></para>
            Ensures that the <see cref="T:UnityEngine.Playables.PlayableGraph"/> is properly cleaned up.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.Finalize">
            <summary>[Editor-Only]
            Ensures that the <see cref="T:UnityEngine.Playables.PlayableGraph"/> is destroyed.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.GetAnimationClips(System.Collections.Generic.List{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipSource"/>]
            Adds the <see cref="P:Animancer.SoloAnimationInternal.Clip"/> to the list.
            </summary>
        </member>
    </members>
</doc>
