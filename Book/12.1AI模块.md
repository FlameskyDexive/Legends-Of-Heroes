# AI模块

## 概述

ET框架提供完整的AI系统，包括行为树、状态机、寻路等AI功能，支持NPC智能行为、敌人AI、队友AI等多种AI类型。

## AI架构

### AI组件结构

```
AI
├── AIComponent           # AI主组件
├── AIConfig              # AI配置
├── BehaviorTree         # 行为树
├── AIHandler            # AI处理器
└── AIDispatcher         # AI调度器
```

## AIComponent

### 核心组件

```csharp
// AI组件
public class AIComponent : Entity, IAwake
{
    // AI配置
    public AIConfig Config;
    
    // 当前行为
    public string CurrentBehavior;
    
    // 目标单位
    public long TargetId;
    
    // AI状态
    public AIState State;
}
```

### AI初始化

```csharp
// 初始化AI
[EntitySystemOf(typeof(AIComponent))]
public static partial class AIComponentSystem
{
    [EntitySystem]
    private static void Awake(this AIComponent self)
    {
        // 加载AI配置
        self.Config = ConfigComponent.Instance.Get<AIConfigCategory>().Get(self.GetParent<Unit>().ConfigId);
        
        // 初始化AI状态
        self.State = AIState.Idle;
    }
}
```

## 行为树

### 行为树结构

```
BehaviorTree
├── Composite Nodes      # 组合节点
│   ├── Sequence        # 顺序节点
│   ├── Selector        # 选择节点
│   └── Parallel        # 并行节点
├── Decorator Nodes     # 装饰节点
│   ├── Inverter        # 反转节点
│   ├── Repeater        # 重复节点
│   └── UntilSuccess    # 直到成功
└── Leaf Nodes         # 叶子节点
    ├── Condition       # 条件节点
    └── Action          # 行为节点
```

### 行为树配置

```json
{
  "name": "GuardAI",
  "root": {
    "type": "Selector",
    "children": [
      {
        "type": "Sequence",
        "children": [
          {
            "type": "Condition",
            "name": "HasEnemy"
          },
          {
            "type": "Action",
            "name": "Attack"
          }
        ]
      },
      {
        "type": "Action",
        "name": "Patrol"
      }
    ]
  }
}
```

### 行为树执行

```csharp
// 行为树执行器
public class BehaviorTreeComponent : Entity, IAwake
{
    // 行为树配置
    private BehaviorTreeConfig config;
    
    // 执行行为树
    public async ETTask Execute()
    {
        BTNode rootNode = CreateNode(config.Root);
        await rootNode.Execute();
    }
    
    // 创建节点
    private BTNode CreateNode(NodeConfig config)
    {
        switch (config.Type)
        {
            case "Sequence":
                return new SequenceNode(config);
            case "Selector":
                return new SelectorNode(config);
            case "Action":
                return new ActionNode(config);
            default:
                return null;
        }
    }
}
```

### 组合节点

#### Sequence (顺序节点)

```csharp
// 顺序节点：依次执行子节点，全部成功才返回成功
public class SequenceNode : BTNode
{
    public override async ETTask<BTStatus> Execute()
    {
        foreach (BTNode child in Children)
        {
            BTStatus status = await child.Execute();
            if (status != BTStatus.Success)
            {
                return status;
            }
        }
        return BTStatus.Success;
    }
}
```

#### Selector (选择节点)

```csharp
// 选择节点：依次执行子节点，任一成功就返回成功
public class SelectorNode : BTNode
{
    public override async ETTask<BTStatus> Execute()
    {
        foreach (BTNode child in Children)
        {
            BTStatus status = await child.Execute();
            if (status == BTStatus.Success)
            {
                return BTStatus.Success;
            }
        }
        return BTStatus.Failure;
    }
}
```

### 装饰节点

#### Inverter (反转节点)

```csharp
// 反转节点：反转子节点的执行结果
public class InverterNode : BTNode
{
    public override async ETTask<BTStatus> Execute()
    {
        BTStatus status = await Child.Execute();
        return status == BTStatus.Success ? BTStatus.Failure : BTStatus.Success;
    }
}
```

#### Repeater (重复节点)

```csharp
// 重复节点：重复执行子节点
public class RepeaterNode : BTNode
{
    public int RepeatCount { get; set; }
    
    public override async ETTask<BTStatus> Execute()
    {
        for (int i = 0; i < RepeatCount; i++)
        {
            await Child.Execute();
        }
        return BTStatus.Success;
    }
}
```

### 叶子节点

#### Condition (条件节点)

```csharp
// 条件节点：检查条件是否满足
public class ConditionNode : BTNode
{
    public string ConditionName { get; set; }
    
    public override async ETTask<BTStatus> Execute()
    {
        bool result = await CheckCondition(ConditionName);
        return result ? BTStatus.Success : BTStatus.Failure;
    }
    
    private async ETTask<bool> CheckCondition(string conditionName)
    {
        switch (conditionName)
        {
            case "HasEnemy":
                return HasEnemy();
            case "InAttackRange":
                return InAttackRange();
            case "HasTarget":
                return HasTarget();
            default:
                return false;
        }
    }
}
```

#### Action (行为节点)

```csharp
// 行为节点：执行具体行为
public class ActionNode : BTNode
{
    public string ActionName { get; set; }
    
    public override async ETTask<BTStatus> Execute()
    {
        switch (ActionName)
        {
            case "Patrol":
                await Patrol();
                break;
            case "Chase":
                await Chase();
                break;
            case "Attack":
                await Attack();
                break;
            case "Flee":
                await Flee();
                break;
        }
        return BTStatus.Success;
    }
    
    private async ETTask Patrol()
    {
        // 巡逻逻辑
        AIComponent ai = GetParent<AIComponent>();
        MoveComponent move = ai.GetParent<Unit>().GetComponent<MoveComponent>();
        
        // 随机选择巡逻点
        Vector3 patrolPoint = GetRandomPatrolPoint();
        await move.MoveTo(patrolPoint);
    }
    
    private async ETTask Chase()
    {
        // 追逐逻辑
        AIComponent ai = GetParent<AIComponent>();
        Unit unit = ai.GetParent<Unit>();
        MoveComponent move = unit.GetComponent<MoveComponent>();
        
        // 获取目标位置
        Unit target = GetTarget(ai.TargetId);
        if (target != null)
        {
            await move.MoveTo(target.Position);
        }
    }
    
    private async ETTask Attack()
    {
        // 攻击逻辑
        AIComponent ai = GetParent<AIComponent>();
        Unit unit = ai.GetParent<Unit>();
        
        // 执行攻击
        await unit.GetComponent<AttackComponent>().Attack();
    }
    
    private async ETTask Flee()
    {
        // 逃跑逻辑
        AIComponent ai = GetParent<AIComponent>();
        Unit unit = ai.GetParent<Unit>();
        MoveComponent move = unit.GetComponent<MoveComponent>();
        
        // 远离目标
        Vector3 fleeDirection = GetFleeDirection();
        await move.MoveTo(unit.Position + fleeDirection);
    }
}
```

## AI配置

### AIConfig

```csharp
// AI配置
public partial class AIConfig : IConfig
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string BehaviorTree { get; set; }
    public float PatrolRange { get; set; }
    public float ChaseRange { get; set; }
    public float AttackRange { get; set; }
    public float FleeRange { get; set; }
    public float AttackSpeed { get; set; }
    public float MoveSpeed { get; set; }
}
```

### AI示例配置

```
AIConfig.xlsx:
Id  Name           BehaviorTree    PatrolRange  ChaseRange  AttackRange  FleeRange  AttackSpeed  MoveSpeed
1   GuardAI        GuardTree       10.0         20.0        5.0          3.0        1.0          3.0
2   ChaseAI        ChaseTree       5.0          30.0        8.0          5.0        1.5          4.0
3   AttackAI       AttackTree      3.0          15.0        10.0         2.0        2.0          5.0
```

## AI状态机

### AIState

```csharp
// AI状态
public enum AIState
{
    Idle,       # 闲置
    Patrol,     # 巡逻
    Chase,      # 追逐
    Attack,     # 攻击
    Flee,       # 逃跑
    Dead        # 死亡
}
```

### 状态机组件

```csharp
// 状态机组件
public class StateMachineComponent : Entity, IAwake
{
    // 当前状态
    public AIState CurrentState { get; private set; }
    
    // 状态处理器
    private Dictionary<AIState, IAIStateHandler> handlers = new();
    
    // 切换状态
    public void ChangeState(AIState newState)
    {
        // 退出当前状态
        handlers[CurrentState]?.Exit();
        
        // 切换状态
        CurrentState = newState;
        
        // 进入新状态
        handlers[CurrentState]?.Enter();
    }
    
    // 更新状态
    public void Update()
    {
        handlers[CurrentState]?.Update();
    }
}
```

### 状态处理器

```csharp
// 状态处理器接口
public interface IAIStateHandler
{
    void Enter();
    void Update();
    void Exit();
}

// 巡逻状态处理器
public class PatrolStateHandler : IAIStateHandler
{
    private AIComponent ai;
    
    public void Enter()
    {
        // 进入巡逻状态
        Log.Debug("Enter Patrol State");
    }
    
    public void Update()
    {
        // 更新巡逻逻辑
        AIComponent ai = GetParent<AIComponent>();
        
        // 检查是否有敌人
        if (HasEnemy(ai))
        {
            ai.GetComponent<StateMachineComponent>().ChangeState(AIState.Chase);
        }
    }
    
    public void Exit()
    {
        // 退出巡逻状态
        Log.Debug("Exit Patrol State");
    }
}
```

## AI更新

### AI更新系统

```csharp
// AI更新系统
[EntitySystemOf(typeof(AIComponent))]
public static partial class AIComponentSystem
{
    [EntitySystem]
    private static void Update(this AIComponent self)
    {
        // 根据AI状态执行不同行为
        switch (self.State)
        {
            case AIState.Idle:
                self.IdleUpdate();
                break;
            case AIState.Patrol:
                self.PatrolUpdate();
                break;
            case AIState.Chase:
                self.ChaseUpdate();
                break;
            case AIState.Attack:
                self.AttackUpdate();
                break;
            case AIState.Flee:
                self.FleeUpdate();
                break;
        }
    }
    
    // 闲置更新
    private static void IdleUpdate(this AIComponent self)
    {
        // 随机开始巡逻
        if (RandomHelper.RandomBool(0.01f))
        {
            self.State = AIState.Patrol;
        }
    }
    
    // 巡逻更新
    private static void PatrolUpdate(this AIComponent self)
    {
        // 检查是否有敌人
        if (HasEnemy(self))
        {
            self.State = AIState.Chase;
        }
    }
    
    // 追逐更新
    private static void ChaseUpdate(this AIComponent self)
    {
        // 检查是否在攻击范围
        if (InAttackRange(self))
        {
            self.State = AIState.Attack;
        }
        
        // 检查是否需要逃跑
        if (ShouldFlee(self))
        {
            self.State = AIState.Flee;
        }
    }
    
    // 攻击更新
    private static void AttackUpdate(this AIComponent self)
    {
        // 执行攻击
        Attack(self);
    }
    
    // 逃跑更新
    private static void FleeUpdate(this AIComponent self)
    {
        // 检查是否安全
        if (IsSafe(self))
        {
            self.State = AIState.Patrol;
        }
    }
}
```

## AI辅助功能

### 感知系统

```csharp
// 感知组件
public class PerceptionComponent : Entity, IAwake
{
    // 感知范围
    public float PerceptionRange;
    
    // 感知到的实体
    public HashSet<long> PerceivedEntities = new();
    
    // 检查是否感知到实体
    public bool CanPerceive(long entityId)
    {
        return PerceivedEntities.Contains(entityId);
    }
    
    // 感知周围的实体
    public void Perceive()
    {
        Unit unit = GetParent<Unit>();
        Scene scene = unit.Scene();
        
        // 获取附近的单位
        List<Unit> nearbyUnits = scene.GetComponent<AOIComponent>()
            .GetNearbyUnits(unit.Position, PerceptionRange);
        
        // 更新感知到的实体
        PerceivedEntities.Clear();
        foreach (Unit nearbyUnit in nearbyUnits)
        {
            PerceivedEntities.Add(nearbyUnit.Id);
        }
    }
}
```

### 寻路系统

```csharp
// 寻路组件
public class PathfindingComponent : Entity, IAwake
{
    // 导航网格
    private NavMesh navMesh;
    
    // 查找路径
    public async ETTask<List<Vector3>> FindPath(Vector3 start, Vector3 end)
    {
        // 使用Recast查找路径
        return await navMesh.FindPath(start, end);
    }
}
```

## 最佳实践

### 1. AI设计
- 行为简单清晰
- 状态转换合理
- 配置化AI参数

### 2. 性能优化
- 减少AI计算频率
- 使用空间分区
- AI LOD系统

### 3. 可扩展性
- 模块化AI组件
- 配置驱动
- 脚本化AI行为

### 4. 调试工具
- AI状态可视化
- 行为树调试
- 性能监控

## 常见问题

### Q: 如何优化AI性能?
A: 
1. 降低AI更新频率
2. 使用空间分区
3. 简化行为树
4. AI LOD系统

### Q: 如何调试AI?
A: 
1. 使用可视化工具
2. 记录AI状态
3. 行为树调试
4. 性能分析

### Q: 如何实现团队AI?
A: 
1. 使用指挥官系统
2. 队伍状态同步
3. 协作行为
4. 消息通信

## 相关文档

- [ECS架构](ECS架构.md)
- [Fiber模块](Fiber模块.md)
- [服务端模块](服务端模块.md)
- [数值系统](数值系统.md)
