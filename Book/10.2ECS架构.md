# ECS架构

## 概述

ET框架采用Entity-Component-System (ECS) 架构，这是一种将数据与逻辑严格分离的设计模式。ECS架构能够提供更好的性能、更清晰的代码结构和更灵活的组合方式。

## 核心概念

### Entity (实体)
- **定义**: 所有游戏对象的基类
- **职责**: 纯数据容器，不包含业务逻辑方法
- **特点**:
  - 支持对象池优化
  - 可以包含多个Component
  - 具有层级关系（父子关系）
  - 支持生命周期管理

### Component (组件)
- **定义**: Entity的组成部分，包含特定数据
- **职责**: 纯数据，不包含逻辑
- **特点**:
  - 实现组合优于继承
  - 每个Component专注单一职责
  - 可以动态添加和移除

### System (系统)
- **定义**: 处理Entity和Component的逻辑
- **职责**: 纯逻辑，不包含数据
- **特点**:
  - 静态类
  - 使用扩展方法
  - 支持热更新

## 代码规范

### Entity类定义

```csharp
// 位置：Assets/Scripts/Model/ 或 Assets/Scripts/ModelView/
namespace ET  // 或 ET.Client, ET.Server
{
    /// <summary>
    /// 组件的详细中文描述
    /// </summary>
    [ComponentOf(typeof(ParentEntityType))]  // 指定父实体类型
    public class ExampleComponent : Entity, IAwake, IDestroy
    {
        // 只包含数据字段，不包含方法
        public int SomeValue;
        public string SomeName;
        public List<int> SomeList;
        
        // Entity只能管理Entity跟struct，不允许管理非Entity class
    }
}
```

### Entity类要求

1. **必须**继承 `Entity` 基类
2. **必须**实现 `IAwake` 接口
3. **根据需要**实现其他接口：`IDestroy`、`IUpdate`、`ISerialize` 等
4. **严禁**在Entity类中定义任何方法
5. **必须**添加 `[ComponentOf]` 或 `[ChildOf]` 特性指定父级约束
6. **Entity只能管理Entity跟struct，不允许管理非Entity class**

### System类定义

```csharp
// 位置：Assets/Scripts/Hotfix/ 或 Assets/Scripts/HotfixView/
namespace ET  // 或 ET.Client, ET.Server
{
    /// <summary>
    /// 系统的详细中文描述
    /// </summary>
    [EntitySystemOf(typeof(ExampleComponent))]     // 指定对应的Entity类型
    public static partial class ExampleComponentSystem
    {
        #region 生命周期方法

        [EntitySystem]
        private static void Awake(this ExampleComponent self)
        {
            // 初始化逻辑
        }

        [EntitySystem]
        private static void Destroy(this ExampleComponent self)
        {
            // 销毁清理逻辑
        }

        #endregion

        #region 业务方法

        /// <summary>
        /// 业务方法的中文描述
        /// </summary>
        public static void DoSomething(this ExampleComponent self, int param)
        {
            // 业务逻辑实现
        }

        #endregion
    }
}
```

### System类要求

1. **必须**是静态类（`static`）
2. **必须**包含 `partial` 关键字
3. **必须**添加 `[EntitySystemOf(typeof(对应Entity类))]` 特性
4. **必须**实现对应Entity的 `Awake` 生命周期函数
5. **所有方法**必须是静态扩展方法
6. **生命周期方法**必须添加 `[EntitySystem]` 特性并声明为 `private static`

## 生命周期接口

### IAwake
初始化接口，在Entity创建时调用。

### IDestroy
销毁接口，在Entity销毁时调用。

### IUpdate
更新接口，每帧调用。

### ILateUpdate
延迟更新接口，在Update之后调用。

### IFixedUpdate
固定更新接口，固定时间间隔调用。

### ISerialize
序列化接口，用于数据持久化。

## EntityRef引用管理

### 为什么需要EntityRef

在async/await环境下，await后Entity可能已经失效，直接访问会导致错误。EntityRef提供了安全的引用方式。

### 基本使用方法

```csharp
// Entity字段中使用EntityRef
public Dictionary<int, EntityRef<ProcessInfo>> ProcessDict { get; set; }

// 创建EntityRef引用
EntityRef<ProcessInfo> processRef = processInfo;

// 正确的Entity对象访问和检查方式
ProcessInfo entity = processRef;  // 直接赋值，不用.Entity
if (entity != null)
{
    // 安全使用Entity
}
```

### async/await环境下的使用规范

```csharp
// 正确：await后使用Entity需要通过EntityRef重新获取
public static async ETTask ProcessUpdate(this UpdateCoordinatorComponent self, UpdateTask task)
{
    // 1. 在await前创建EntityRef引用
    EntityRef<UpdateCoordinatorComponent> selfRef = self;
    EntityRef<UpdateTask> taskRef = task;
  
    foreach (int processId in task.TargetProcessIds)
    {
        // 2. 在每次使用前通过EntityRef重新获取Entity
        task = taskRef;
        task.UpdateProgress(processId, "开始处理");
      
        // 3. await后需要重新获取所有Entity
        await SomeAsyncOperation();
      
        // 4. await后必须重新获取才能安全使用
        self = selfRef;
        task = taskRef;
      
        // 现在可以安全使用Entity
        task.UpdateProgress(processId, "处理完成");
    }
}
```

## 重要分析器规范

### Entity Await 安全规范

- 在 async/await 环境下，任何 Entity 及其子类对象，await 之后**禁止直接访问** await 前的 Entity 变量
- 必须在 await 前创建 EntityRef，await 后通过 EntityRef 重新获取 Entity
- 只要存在执行路径可能在 await 后访问 Entity，均视为违规

### Entity 成员引用规范

- 任何类/结构体**禁止直接声明 Entity 或其子类类型的字段或属性**
- 允许声明 `EntityRef<T>` 类型字段或属性

## 常见错误

1. ❌ Entity中定义方法
2. ❌ System忘记加特性
3. ❌ 生命周期方法不是private static
4. ❌ 忘记实现IAwake接口
5. ❌ 将EntityRef当作Entity直接使用
6. ❌ await后直接使用Entity（违反ET分析器规则）

## 最佳实践

1. **单一职责**: 每个Component只负责一个方面的数据
2. **组合优于继承**: 通过组合多个Component实现复杂功能
3. **数据与逻辑分离**: Entity只存数据，System只写逻辑
4. **生命周期管理**: 正确实现IAwake和IDestroy接口
5. **引用安全**: 在async/await环境中使用EntityRef管理引用

## 相关文档

- [Fiber模块](Fiber模块.md)
- [热更新机制](热更新机制.md)
- [网络通信模块](网络通信模块.md)
