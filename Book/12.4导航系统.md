# 导航系统

## 概述

ET框架集成Recast导航系统，提供强大的寻路功能，支持动态导航网格、多平台导航、路径优化等功能。导航系统是游戏中角色移动、AI寻路的基础。

## 导航架构

### 导航组件

```
Navigation
├── NavmeshComponent       # 导航网格组件
├── PathfindingComponent   # 寻路组件
├── Navmesh               # 导航网格
└── RecastFileReader      # Recast文件读取器
```

## NavmeshComponent

### NavmeshComponent

```csharp
// 导航网格组件
public class NavmeshComponent : Entity, IAwake
{
    // 导航网格
    private Navmesh navmesh;
    
    // 地图名称
    public string MapName { get; set; }
    
    // 初始化导航网格
    public async ETTask Init(string mapName);
    
    // 查找路径
    public async ETTask<List<Vector3>> FindPath(Vector3 start, Vector3 end);
    
    // 随机位置
    public Vector3 GetRandomPosition();
    
    // 最近的可行走点
    public Vector3 GetClosestWalkablePosition(Vector3 position);
}
```

### NavmeshComponent实现

```csharp
// 初始化导航网格
public static async ETTask Init(this NavmeshComponent self, string mapName)
{
    self.MapName = mapName;
    
    // 1. 读取导航数据
    byte[] navmeshData = await RecastFileReader.ReadAsync(mapName);
    
    // 2. 创建导航网格
    self.navmesh = new Navmesh(navmeshData);
    
    Log.Debug($"Navmesh initialized: {mapName}");
}

// 查找路径
public static async ETTask<List<Vector3>> FindPath(this NavmeshComponent self, Vector3 start, Vector3 end)
{
    // 1. 查找最近的可行走点
    Vector3 walkableStart = self.GetClosestWalkablePosition(start);
    Vector3 walkableEnd = self.GetClosestWalkablePosition(end);
    
    // 2. 使用导航网格查找路径
    List<Vector3> path = self.navmesh.FindPath(walkableStart, walkableEnd);
    
    // 3. 平滑路径
    path = self.SmoothPath(path);
    
    return path;
}

// 随机位置
public static Vector3 GetRandomPosition(this NavmeshComponent self)
{
    return self.navmesh.GetRandomPosition();
}

// 最近的可行走点
public static Vector3 GetClosestWalkablePosition(this NavmeshComponent self, Vector3 position)
{
    return self.navmesh.GetClosestPoint(position);
}

// 平滑路径
private static List<Vector3> SmoothPath(this NavmeshComponent self, List<Vector3> path)
{
    if (path.Count < 3)
    {
        return path;
    }
    
    List<Vector3> smoothedPath = new List<Vector3>();
    smoothedPath.Add(path[0]);
    
    int current = 0;
    int next = 2;
    
    while (next < path.Count)
    {
        // 检查是否可以直接到达
        if (self.navmesh.CanReach(path[current], path[next]))
        {
            next++;
        }
        else
        {
            current = next - 1;
            smoothedPath.Add(path[current]);
            next = current + 2;
        }
    }
    
    smoothedPath.Add(path[path.Count - 1]);
    return smoothedPath;
}
```

## PathfindingComponent

### PathfindingComponent

```csharp
// 寻路组件
public class PathfindingComponent : Entity, IAwake
{
    // 当前路径
    public List<Vector3> CurrentPath { get; set; } = new List<Vector3>();
    
    // 当前路径点索引
    public int CurrentPathIndex { get; set; }
    
    // 移动速度
    public float MoveSpeed { get; set; } = 5f;
    
    // 是否正在移动
    public bool IsMoving { get; set; }
    
    // 移动到目标点
    public async ETTask MoveTo(Vector3 target);
    
    // 沿路径移动
    public async ETTask FollowPath();
    
    // 停止移动
    public void Stop();
}
```

### PathfindingComponent实现

```csharp
// 移动到目标点
public static async ETTask MoveTo(this PathfindingComponent self, Vector3 target)
{
    Unit unit = self.GetParent<Unit>();
    NavmeshComponent navmesh = unit.Scene().GetComponent<NavmeshComponent>();
    
    // 1. 查找路径
    List<Vector3> path = await navmesh.FindPath(unit.Position, target);
    
    // 2. 设置当前路径
    self.CurrentPath = path;
    self.CurrentPathIndex = 0;
    
    // 3. 开始沿路径移动
    await self.FollowPath();
}

// 沿路径移动
public static async ETTask FollowPath(this PathfindingComponent self)
{
    if (self.CurrentPath == null || self.CurrentPath.Count == 0)
    {
        self.IsMoving = false;
        return;
    }
    
    self.IsMoving = true;
    Unit unit = self.GetParent<Unit>();
    
    while (self.CurrentPathIndex < self.CurrentPath.Count)
    {
        // 1. 获取当前目标点
        Vector3 target = self.CurrentPath[self.CurrentPathIndex];
        
        // 2. 移动到目标点
        await self.MoveToTarget(unit, target);
        
        // 3. 移动到下一个路径点
        self.CurrentPathIndex++;
    }
    
    self.IsMoving = false;
}

// 移动到目标点
private static async ETTask MoveToTarget(this PathfindingComponent self, Unit unit, Vector3 target)
{
    Vector3 direction = (target - unit.Position).normalized;
    
    while (Vector3.Distance(unit.Position, target) > 0.1f)
    {
        // 1. 计算移动距离
        float deltaTime = TimeHelper.ServerNow();
        float moveDistance = self.MoveSpeed * deltaTime;
        
        // 2. 移动角色
        Vector3 newPosition = unit.Position + direction * moveDistance;
        unit.Position = newPosition;
        
        // 3. 等待下一帧
        await TimerComponent.Instance.WaitAsync(16);  # 约60fps
    }
}

// 停止移动
public static void Stop(this PathfindingComponent self)
{
    self.IsMoving = false;
    self.CurrentPath.Clear();
    self.CurrentPathIndex = 0;
}
```

## RecastFileReader

### RecastFileReader

```csharp
// Recast文件读取器
public static class RecastFileReader
{
    // 读取导航数据
    public static async ETTask<byte[]> ReadAsync(string mapName)
    {
        // 1. 构建文件路径
        string filePath = $"Config/Recast/{mapName}/navmesh.bin";
        
        // 2. 检查文件是否存在
        if (!File.Exists(filePath))
        {
            Log.Error($"Navmesh file not found: {filePath}");
            return null;
        }
        
        // 3. 读取文件
        return await File.ReadAllBytesAsync(filePath);
    }
    
    // 保存导航数据
    public static async ETTask WriteAsync(string mapName, byte[] data)
    {
        // 1. 构建文件路径
        string filePath = $"Config/Recast/{mapName}/navmesh.bin";
        
        // 2. 确保目录存在
        Directory.CreateDirectory(Path.GetDirectoryName(filePath));
        
        // 3. 写入文件
        await File.WriteAllBytesAsync(filePath, data);
    }
}
```

## Navmesh

### Navmesh

```csharp
// 导航网格
public class Navmesh
{
    // 导航网格数据
    private byte[] navmeshData;
    
    // 初始化导航网格
    public Navmesh(byte[] data)
    {
        this.navmeshData = data;
        // 初始化Recast导航网格
        InitRecastNavmesh(data);
    }
    
    // 查找路径
    public List<Vector3> FindPath(Vector3 start, Vector3 end);
    
    // 随机位置
    public Vector3 GetRandomPosition();
    
    // 最近的可行走点
    public Vector3 GetClosestPoint(Vector3 position);
    
    // 检查是否可以到达
    public bool CanReach(Vector3 start, Vector3 end);
    
    // 射线检测
    public bool Raycast(Vector3 start, Vector3 end);
}
```

## 导航配置

### NavmeshConfig

```csharp
// 导航配置
public class NavmeshConfig
{
    // 单元格大小
    public float CellSize = 0.3f;
    
    // 单元格高度
    public float CellHeight = 0.2f;
    
    // 角色高度
    public float AgentHeight = 2.0f;
    
    // 角色半径
    public float AgentRadius = 0.5f;
    
    // 最大爬坡高度
    public float MaxClimb = 0.5f;
    
    // 最大坡度
    public float MaxSlope = 45.0f;
    
    // 区域类型
    public int WalkableArea = 0;
    public int UnwalkableArea = 1;
}
```

## 导航导出

### RecastNavExportor

```csharp
// 导航导出工具
public class RecastNavExportor
{
    // 导出导航网格
    public static void ExportNavmesh(string scenePath, string outputPath)
    {
        // 1. 加载场景
        Scene scene = EditorSceneManager.OpenScene(scenePath);
        
        // 2. 收集导航网格数据
        NavMeshTriangulation navMeshData = NavMesh.CalculateTriangulation();
        
        // 3. 构建Recast导航网格
        byte[] recastNavmesh = BuildRecastNavmesh(navMeshData);
        
        // 4. 保存导航数据
        string navmeshPath = Path.Combine(outputPath, "navmesh.bin");
        File.WriteAllBytes(navmeshPath, recastNavmesh);
        
        Log.Debug($"Navmesh exported: {navmeshPath}");
    }
    
    // 构建Recast导航网格
    private static byte[] BuildRecastNavmesh(NavMeshTriangulation navMeshData)
    {
        // 使用Recast库构建导航网格
        // 这里需要调用Recast的原生库
        // 返回二进制导航数据
        return new byte[0];
    }
}
```

## 动态导航

### 动态障碍物

```csharp
// 动态障碍物组件
public class DynamicObstacleComponent : Entity, IAwake
{
    // 障碍物范围
    public Bounds Bounds { get; set; }
    
    // 是否阻挡导航
    public bool BlocksNavigation { get; set; } = true;
    
    // 更新导航网格
    public void UpdateNavmesh()
    {
        NavmeshComponent navmesh = Scene().GetComponent<NavmeshComponent>();
        if (navmesh != null)
        {
            // 更新导航网格以包含障碍物
            navmesh.AddObstacle(Bounds);
        }
    }
    
    // 移除障碍物
    public void RemoveObstacle()
    {
        NavmeshComponent navmesh = Scene().GetComponent<NavmeshComponent>();
        if (navmesh != null)
        {
            // 从导航网格中移除障碍物
            navmesh.RemoveObstacle(Bounds);
        }
    }
}
```

## 性能优化

### 路径缓存

```csharp
// 路径缓存
public class PathCache
{
    // 路径字典
    private Dictionary<string, List<Vector3>> pathCache = new Dictionary<string, List<Vector3>>();
    
    // 缓存路径
    public void CachePath(Vector3 start, Vector3 end, List<Vector3> path)
    {
        string key = GetCacheKey(start, end);
        pathCache[key] = path;
    }
    
    // 获取缓存路径
    public List<Vector3> GetCachedPath(Vector3 start, Vector3 end)
    {
        string key = GetCacheKey(start, end);
        if (pathCache.TryGetValue(key, out List<Vector3> path))
        {
            return new List<Vector3>(path);
        }
        return null;
    }
    
    // 生成缓存键
    private string GetCacheKey(Vector3 start, Vector3 end)
    {
        return $"{start.x:F2},{start.y:F2},{start.z:F2}-{end.x:F2},{end.y:F2},{end.z:F2}";
    }
}
```

## 最佳实践

### 1. 导航设计
- 合理设置参数
- 优化导航网格
- 使用路径缓存
- 动态障碍物

### 2. 性能优化
- 路径缓存
- 分层导航
- 异步寻路
- 区域分割

### 3. 动态导航
- 障碍物管理
- 实时更新
- 局部重计算
- 预测更新

### 4. 调试工具
- 导航可视化
- 路径显示
- 性能监控
- 错误检测

## 常见问题

### Q: 如何优化导航网格?
A: 
1. 调整单元格大小
2. 减少三角形数量
3. 使用分层导航
4. 优化场景几何体

### Q: 如何处理动态障碍物?
A: 
1. 使用动态障碍物组件
2. 实时更新导航网格
3. 局部重计算
4. 预测更新

### Q: 如何优化寻路性能?
A: 
1. 使用路径缓存
2. 异步寻路
3. 分层导航
4. 区域分割

## 相关文档

- [ECS架构](ECS架构.md)
- [AI模块](AI模块.md)
- [AOI系统](AOI系统.md)
- [服务端模块](服务端模块.md)
