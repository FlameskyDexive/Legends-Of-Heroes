# Fiber模块

## 概述

Fiber是ET框架的核心架构之一，实现了Actor模型和单线程异步编程。每个Fiber是一个独立的执行单元，拥有自己的消息队列和执行上下文，通过消息传递进行通信。

## 核心概念

### Actor模型
- **定义**: 并发计算模型，通过消息传递进行通信
- **特点**: 
  - 每个Actor独立执行
  - 通过消息队列通信
  - 避免锁和共享状态
  - 天然支持分布式

### Fiber
- **定义**: Actor的具体实现，对应一个独立的执行线程
- **职责**: 
  - 管理消息队列
  - 调度消息处理
  - 维护执行上下文
- **特点**:
  - 单线程执行，无锁设计
  - 消息驱动
  - 支持跨Fiber调用

## 架构设计

### Fiber结构

```
Fiber
├── Id                    # Fiber唯一标识
├── Process               # 所属进程
├── Root                  # 根Entity
├── MailboxType           # 邮箱类型
├── Scheduler             # 调度器
└── MessageQueue          # 消息队列
```

### Mailbox (邮箱)

Mailbox是Fiber的消息接收端，负责消息的排队和投递。

#### 邮箱类型

```csharp
public enum MailBoxType
{
    UnOrderedMessage,      # 无序消息邮箱
    OrderedMessage,        # 有序消息邮箱
    NoSender               # 无发送者消息邮箱
}
```

#### MailboxComponent

```csharp
// 邮箱组件，管理Fiber之间的消息传递
public class MailboxComponent : Entity, IAwake
{
    // 消息队列
    private readonly Queue<SessionMessage> messageQueue = new();
    
    // 接收消息
    public void Add(SessionMessage message);
    
    // 处理消息
    public void Process();
}
```

## 消息传递机制

### ActorId
ActorId是Fiber的唯一标识，用于跨Fiber定位和通信。

```csharp
public struct ActorId : IComparable<ActorId>
{
    public readonly long ProcessId;    // 进程ID
    public readonly long FiberId;      // Fiber ID
    
    // 创建ActorId
    public static ActorId Create(long processId, long fiberId);
}
```

### 消息发送

#### Send (单向发送)
```csharp
// 发送消息，不等待响应
fiber.Root.GetComponent<ClientSenderComponent>().Send(message);
```

#### Call (调用等待)
```csharp
// 发送消息并等待响应
C2M_TestRobotCase2 message = C2M_TestRobotCase2.Create();
var response = await fiber.Root.GetComponent<ClientSenderComponent>().Call(message);
```

### 消息处理

```csharp
// 在Fiber中处理消息
[MessageHandler(SceneType.Map)]
public class C2M_TestRobotCase2Handler : MessageHandler<Scene, C2M_TestRobotCase2, M2C_TestRobotCase2>
{
    protected override async ETTask Run(Scene scene, C2M_TestRobotCase2 request, M2C_TestRobotCase2 response)
    {
        // 处理消息逻辑
    }
}
```

## Fiber调度

### 调度器接口

```csharp
public interface IScheduler
{
    // 添加Fiber
    void Add(Fiber fiber);
    
    // 移除Fiber
    void Remove(Fiber fiber);
    
    // 调度Fiber
    void Schedule();
}
```

### 单线程调度

```csharp
// 单线程调度器，按顺序处理所有Fiber
public class SingleThreadScheduler : IScheduler
{
    private readonly List<Fiber> fibers = new();
    
    public void Schedule()
    {
        foreach (var fiber in fibers)
        {
            fiber.Update();
        }
    }
}
```

## Fiber管理

### Fiber创建

```csharp
// 创建Fiber
Fiber fiber = new(process, id, runtime, sceneType, mailBoxType);

// 添加到调度器
process.Scheduler.Add(fiber);
```

### Fiber获取

```csharp
// 从进程获取Fiber
Fiber fiber = process.GetFiber(fiberId);

// 从场景获取Fiber
Fiber fiber = scene.Fiber();
```

### Fiber销毁

```csharp
// 销毁Fiber
fiber.Dispose();
```

## EntitySystem

EntitySystem是Fiber的核心系统，负责管理Entity的生命周期和事件系统。

### 系统类型

```csharp
// Entity系统类型
public enum EntitySystemType
{
    Awake,          // 唤醒
    Destroy,        // 销毁
    Load,           // 加载
    Deserialize,    // 反序列化
    Update,         // 更新
    LateUpdate,     // 延迟更新
    FixedUpdate     // 固定更新
}
```

### 事件系统

```csharp
// 事件发布
EventSystem.Instance.Publish(scene, new EventType.EnterMap()
{
    Unit = unit
});

// 事件订阅
[Event(SceneType.Map)]
public class EnterMapEvent : AEvent<Scene, EventType.EnterMap>
{
    protected override async ETTask Run(Scene scene, EventType.EnterMap args)
    {
        // 处理事件
    }
}
```

## Module系统

Module是Fiber的功能模块，提供可复用的组件。

### 内置Module

#### ActorModule
- Actor消息处理
- Actor位置管理

#### TimerModule
- 定时器管理
- 延迟任务

#### CoroutineLockModule
- 协程锁
- 异步同步

#### NavmeshModule
- 导航网格
- 路径查找

### Module使用

```csharp
// 获取Module
var timerModule = fiber.Root.GetComponent<TimerModule>();

// 使用Module功能
timerComponent = fiber.Root.GetComponent<TimerComponent>();
await timerComponent.WaitAsync(1000);
```

## 最佳实践

### 1. 消息设计
- 消息应该简单轻量
- 避免在消息中传递大对象
- 使用Proto定义消息结构

### 2. 异步处理
- 大量使用async/await
- 避免阻塞Fiber线程
- 合理使用Timer

### 3. 状态管理
- 避免跨Fiber共享状态
- 通过消息传递数据
- 使用EntityRef安全引用

### 4. 错误处理
- 使用try-catch捕获异常
- 记录详细的错误日志
- 提供合理的错误恢复机制

## 常见问题

### Q: 如何选择MailboxType?
A: 
- `UnOrderedMessage`: 消息无序处理，性能最优
- `OrderedMessage`: 消息按顺序处理，保证顺序
- `NoSender`: 不需要发送者信息，性能最优

### Q: 如何在Fiber间共享数据?
A: 不应该直接共享数据，应该通过消息传递。如果必须共享，使用MongoDB等持久化存储。

### Q: 如何调试Fiber?
A: 
1. 开启ENABLE_VIEW宏查看Entity
2. 使用日志系统记录消息流
3. 使用Unity Profiler监控性能

## 相关文档

- [ECS架构](ECS架构.md)
- [网络通信模块](网络通信模块.md)
- [热更新机制](热更新机制.md)
- [服务端模块](服务端模块.md)
