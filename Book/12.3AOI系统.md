# AOI系统

## 概述

AOI（Area of Interest，兴趣区域）系统用于管理游戏场景中实体的感知范围，优化实体间的交互检测。AOI系统是MMORPG等多人在线游戏的核心功能，用于处理视野同步、战斗检测、NPC感知等场景。

## AOI架构

### AOI组件

```
AOI
├── AOIComponent          # AOI组件
├── AOIEntity            # AOI实体
├── Cell                 # AOI网格单元
└── AOIHelper            # AOI辅助类
```

## AOIComponent

### AOIComponent

```csharp
// AOI组件
public class AOIComponent : Entity, IAwake
{
    // AOI实体列表
    public Dictionary<long, AOIEntity> Entities { get; private set; } = new Dictionary<long, AOIEntity>();
    
    // 网格单元列表
    public Dictionary<long, Cell> Cells { get; private set; } = new Dictionary<long, Cell>();
    
    // 网格大小
    public float CellSize { get; set; } = 10f;
    
    // 地图大小
    public float MapWidth { get; set; } = 1000f;
    public float MapHeight { get; set; } = 1000f;
    
    // 添加实体
    public void Add(AOIEntity entity);
    
    // 移除实体
    public void Remove(long entityId);
    
    // 更新实体位置
    public void UpdatePosition(long entityId, Vector3 newPosition);
    
    // 获取附近的实体
    public List<AOIEntity> GetNearbyEntities(AOIEntity entity, float radius);
}
```

### AOIComponent实现

```csharp
// 添加实体
public static void Add(this AOIComponent self, AOIEntity entity)
{
    // 1. 添加到实体列表
    self.Entities[entity.Id] = entity;
    
    // 2. 计算所在的网格
    long cellKey = self.GetCellKey(entity.Position);
    Cell cell = self.GetOrCreateCell(cellKey);
    
    // 3. 添加到网格
    cell.AddEntity(entity);
    
    // 4. 计算观察者
    self.UpdateWatchers(entity);
}

// 移除实体
public static void Remove(this AOIComponent self, long entityId)
{
    if (!self.Entities.TryGetValue(entityId, out AOIEntity entity))
    {
        return;
    }
    
    // 1. 从网格中移除
    long cellKey = self.GetCellKey(entity.Position);
    if (self.Cells.TryGetValue(cellKey, out Cell cell))
    {
        cell.RemoveEntity(entityId);
    }
    
    // 2. 通知观察者
    foreach (long watcherId in entity.Watchers)
    {
        if (self.Entities.TryGetValue(watcherId, out AOIEntity watcher))
        {
            watcher.Watched.Remove(entityId);
            watcher.OnEntityLeave?.Invoke(entity);
        }
    }
    
    // 3. 从实体列表中移除
    self.Entities.Remove(entityId);
}

// 更新实体位置
public static void UpdatePosition(this AOIComponent self, long entityId, Vector3 newPosition)
{
    if (!self.Entities.TryGetValue(entityId, out AOIEntity entity))
    {
        return;
    }
    
    // 1. 获取旧网格
    long oldCellKey = self.GetCellKey(entity.Position);
    
    // 2. 更新位置
    entity.Position = newPosition;
    
    // 3. 获取新网格
    long newCellKey = self.GetCellKey(newPosition);
    
    // 4. 如果网格发生变化
    if (oldCellKey != newCellKey)
    {
        // 从旧网格移除
        if (self.Cells.TryGetValue(oldCellKey, out Cell oldCell))
        {
            oldCell.RemoveEntity(entityId);
        }
        
        // 添加到新网格
        Cell newCell = self.GetOrCreateCell(newCellKey);
        newCell.AddEntity(entity);
        
        // 更新观察者
        self.UpdateWatchers(entity);
    }
}
```

## AOIEntity

### AOIEntity

```csharp
// AOI实体
public class AOIEntity : Entity, IAwake
{
    // 实体ID
    public long Id { get; set; }
    
    // 位置
    public Vector3 Position { get; set; }
    
    // 感知范围
    public float ViewRange { get; set; } = 50f;
    
    // 观察者列表
    public HashSet<long> Watchers { get; set; } = new HashSet<long>();
    
    // 被观察者列表
    public HashSet<long> Watched { get; set; } = new HashSet<long>();
    
    // 事件回调
    public Action<AOIEntity> OnEntityEnter { get; set; }
    public Action<AOIEntity> OnEntityLeave { get; set; }
}
```

## Cell

### Cell

```csharp
// AOI网格单元
public class Cell : Entity, IAwake
{
    // 网格坐标
    public int GridX { get; set; }
    public int GridZ { get; set; }
    
    // 实体列表
    public HashSet<long> EntityIds { get; set; } = new HashSet<long>();
    
    // 添加实体
    public void AddEntity(AOIEntity entity);
    
    // 移除实体
    public void RemoveEntity(long entityId);
    
    // 获取实体列表
    public List<long> GetEntityIds();
}
```

### Cell实现

```csharp
// 添加实体
public static void AddEntity(this Cell self, AOIEntity entity)
{
    self.EntityIds.Add(entity.Id);
}

// 移除实体
public static void RemoveEntity(this Cell self, long entityId)
{
    self.EntityIds.Remove(entityId);
}

// 获取实体列表
public static List<long> GetEntityIds(this Cell self)
{
    return self.EntityIds.ToList();
}
```

## AOIHelper

### AOIHelper

```csharp
// AOI辅助类
public static class AOIHelper
{
    // 计算网格坐标
    public static Vector2Int GetGridPos(Vector3 position, float cellSize)
    {
        int gridX = (int)(position.x / cellSize);
        int gridZ = (int)(position.z / cellSize);
        return new Vector2Int(gridX, gridZ);
    }
    
    // 计算网格键
    public static long GetCellKey(int gridX, int gridZ)
    {
        return ((long)gridX << 32) | (uint)gridZ;
    }
    
    // 计算距离
    public static float GetDistance(Vector3 pos1, Vector3 pos2)
    {
        return Vector3.Distance(pos1, pos2);
    }
    
    // 检查是否在范围内
    public static bool IsInRange(Vector3 pos1, Vector3 pos2, float range)
    {
        return GetDistance(pos1, pos2) <= range;
    }
    
    // 获取周围的网格
    public static List<long> GetNearbyCells(long cellKey, int range)
    {
        List<long> cells = new List<long>();
        
        int gridX = (int)(cellKey >> 32);
        int gridZ = (int)((uint)cellKey);
        
        for (int x = -range; x <= range; x++)
        {
            for (int z = -range; z <= range; z++)
            {
                cells.Add(GetCellKey(gridX + x, gridZ + z));
            }
        }
        
        return cells;
    }
}
```

## 视野同步

### 视野更新

```csharp
// 更新观察者
public static void UpdateWatchers(this AOIComponent self, AOIEntity entity)
{
    // 1. 清除旧的观察者
    HashSet<long> oldWatchers = new HashSet<long>(entity.Watchers);
    entity.Watchers.Clear();
    
    // 2. 获取周围的网格
    long cellKey = self.GetCellKey(entity.Position);
    int viewRangeCells = (int)(entity.ViewRange / self.CellSize);
    List<long> nearbyCells = AOIHelper.GetNearbyCells(cellKey, viewRangeCells);
    
    // 3. 遍历周围的网格
    foreach (long nearbyCellKey in nearbyCells)
    {
        if (self.Cells.TryGetValue(nearbyCellKey, out Cell cell))
        {
            // 遍历网格中的实体
            foreach (long entityId in cell.GetEntityIds())
            {
                if (entityId == entity.Id)
                {
                    continue;
                }
                
                if (!self.Entities.TryGetValue(entityId, out AOIEntity other))
                {
                    continue;
                }
                
                // 检查是否在感知范围内
                if (AOIHelper.IsInRange(entity.Position, other.Position, entity.ViewRange))
                {
                    // 添加观察者
                    entity.Watchers.Add(entityId);
                    other.Watched.Add(entity.Id);
                    
                    // 如果是新观察者
                    if (!oldWatchers.Contains(entityId))
                    {
                        entity.OnEntityEnter?.Invoke(other);
                    }
                }
            }
        }
    }
    
    // 4. 处理离开的实体
    foreach (long oldWatcherId in oldWatchers)
    {
        if (!entity.Watchers.Contains(oldWatcherId))
        {
            if (self.Entities.TryGetValue(oldWatcherId, out AOIEntity oldWatcher))
            {
                oldWatcher.Watched.Remove(entity.Id);
                entity.OnEntityLeave?.Invoke(oldWatcher);
            }
        }
    }
}
```

### 视野消息

```csharp
// 实体进入视野
[MessageHandler(SceneType.Map)]
public class EntityEnterViewHandler : MessageHandler<Scene, M2C_EntityEnterView>
{
    protected override async ETTask Run(Scene scene, M2C_EntityEnterView message)
    {
        // 1. 创建实体
        Unit unit = EntityFactory.Create<Unit>(scene, true);
        unit.Id = message.EntityId;
        unit.Position = message.Position;
        
        // 2. 添加到场景
        scene.GetComponent<UnitComponent>().Add(unit);
        
        // 3. 创建显示对象
        await CreateViewObject(unit);
    }
}

// 实体离开视野
[MessageHandler(SceneType.Client)]
public class EntityLeaveViewHandler : MessageHandler<Scene, M2C_EntityLeaveView>
{
    protected override async ETTask Run(Scene scene, M2C_EntityLeaveView message)
    {
        // 1. 获取实体
        Unit unit = scene.GetComponent<UnitComponent>().Get(message.EntityId);
        
        // 2. 销毁显示对象
        await DestroyViewObject(unit);
        
        // 3. 从场景中移除
        scene.GetComponent<UnitComponent>().Remove(message.EntityId);
        unit.Dispose();
    }
}
```

## 战斗检测

### 攻击范围检测

```csharp
// 获取攻击范围内的实体
public static List<AOIEntity> GetEntitiesInRange(this AOIComponent self, Vector3 position, float range)
{
    List<AOIEntity> entities = new List<AOIEntity>();
    
    // 1. 获取周围的网格
    long cellKey = self.GetCellKey(position);
    int rangeCells = (int)(range / self.CellSize);
    List<long> nearbyCells = AOIHelper.GetNearbyCells(cellKey, rangeCells);
    
    // 2. 遍历周围的网格
    foreach (long nearbyCellKey in nearbyCells)
    {
        if (self.Cells.TryGetValue(nearbyCellKey, out Cell cell))
        {
            // 遍历网格中的实体
            foreach (long entityId in cell.GetEntityIds())
            {
                if (self.Entities.TryGetValue(entityId, out AOIEntity entity))
                {
                    // 检查是否在攻击范围内
                    if (AOIHelper.IsInRange(position, entity.Position, range))
                    {
                        entities.Add(entity);
                    }
                }
            }
        }
    }
    
    return entities;
}
```

## NPC感知

### 感知系统

```csharp
// 感知组件
public class PerceptionComponent : Entity, IAwake
{
    // 感知范围
    public float PerceptionRange { get; set; } = 20f;
    
    // 感知到的实体
    public HashSet<long> PerceivedEntities { get; set; } = new HashSet<long>();
    
    // 检查是否感知到实体
    public bool CanPerceive(long entityId)
    {
        return PerceivedEntities.Contains(entityId);
    }
    
    // 更新感知
    public void UpdatePerception()
    {
        Unit unit = GetParent<Unit>();
        AOIComponent aoi = unit.Scene().GetComponent<AOIComponent>();
        
        // 获取附近的实体
        List<AOIEntity> nearbyEntities = aoi.GetEntitiesInRange(unit.Position, PerceptionRange);
        
        // 更新感知列表
        PerceivedEntities.Clear();
        foreach (AOIEntity entity in nearbyEntities)
        {
            PerceivedEntities.Add(entity.Id);
        }
    }
}
```

## 性能优化

### 网格优化

```csharp
// 动态网格大小
public static void OptimizeCellSize(this AOIComponent self, int entityCount)
{
    // 根据实体数量调整网格大小
    if (entityCount < 100)
    {
        self.CellSize = 10f;
    }
    else if (entityCount < 1000)
    {
        self.CellSize = 20f;
    }
    else
    {
        self.CellSize = 30f;
    }
}

// 空网格清理
public static void CleanupEmptyCells(this AOIComponent self)
{
    List<long> emptyCells = new List<long>();
    
    foreach (var kv in self.Cells)
    {
        if (kv.Value.EntityIds.Count == 0)
        {
            emptyCells.Add(kv.Key);
        }
    }
    
    foreach (long cellKey in emptyCells)
    {
        self.Cells.Remove(cellKey);
        self.Cells[cellKey].Dispose();
    }
}
```

## 最佳实践

### 1. AOI设计
- 合理设置网格大小
- 优化感知范围
- 减少更新频率
- 分层感知

### 2. 性能优化
- 动态网格大小
- 空网格清理
- 分区管理
- 延迟更新

### 3. 视野同步
- 增量更新
- 批量发送
- 压缩数据
- 优先级处理

### 4. 调试工具
- AOI可视化
- 实体追踪
- 性能监控
- 统计分析

## 常见问题

### Q: 如何设置网格大小?
A: 
1. 分析实体密度
2. 考虑感知范围
3. 动态调整大小
4. 测试性能

### Q: 如何优化AOI性能?
A: 
1. 减少更新频率
2. 动态网格大小
3. 分区管理
4. 空网格清理

### Q: 如何处理大量实体?
A: 
1. 分区管理
2. 动态加载
3. LOD系统
4. 视野裁剪

## 相关文档

- [ECS架构](ECS架构.md)
- [Fiber模块](Fiber模块.md)
- [AI模块](AI模块.md)
- [导航系统](导航系统.md)
