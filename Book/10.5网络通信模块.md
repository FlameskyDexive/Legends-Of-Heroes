# 网络通信模块

## 概述

ET框架提供完整的网络通信解决方案，支持TCP、KCP、WebSocket多种协议，统一的消息系统和自动序列化机制。网络模块基于Fiber/Actor模型，天然支持分布式架构。

## 网络架构

### 协议支持

```csharp
public enum NetworkProtocol
{
    TCP,      # TCP协议
    KCP,      # KCP协议（可靠UDP）
    WebSocket # WebSocket协议
}
```

### 网络组件

```
Network
├── AService           # 网络服务基类
├── KService           # KCP网络服务
├── TService           # TCP网络服务
├── WService           # WebSocket网络服务
├── AChannel           # 网络通道基类
├── KChannel           # KCP网络通道
├── TChannel           # TCP网络通道
└── WChannel           # WebSocket网络通道
```

## 网络服务

### AService (抽象服务)

```csharp
// 网络服务基类
public abstract class AService : Entity
{
    // 创建网络通道
    public abstract AChannel CreateChannel(IPEndPoint ipEndPoint);
    
    // 更新服务
    public abstract void Update();
    
    // 销毁服务
    public override void Dispose();
}
```

### KService (KCP服务)

```csharp
// KCP网络服务
public class KService : AService
{
    // KCP配置
    private readonly IKcpTransport kcpTransport;
    
    // 创建KCP通道
    public override AChannel CreateChannel(IPEndPoint ipEndPoint)
    {
        return new KChannel(this, ipEndPoint);
    }
}
```

### TService (TCP服务)

```csharp
// TCP网络服务
public class TService : AService
{
    // 创建TCP通道
    public override AChannel CreateChannel(IPEndPoint ipEndPoint)
    {
        return new TChannel(this, ipEndPoint);
    }
}
```

### WService (WebSocket服务)

```csharp
// WebSocket网络服务
public class WService : AService
{
    // 创建WebSocket通道
    public override AChannel CreateChannel(IPEndPoint ipEndPoint)
    {
        return new WChannel(this, ipEndPoint);
    }
}
```

## 网络通道

### AChannel (抽象通道)

```csharp
// 网络通道基类
public abstract class AChannel : Entity
{
    // 连接状态
    public bool IsConnected { get; protected set; }
    
    // 发送消息
    public abstract void Send(MemoryBuffer buffer);
    
    // 接收消息
    public abstract void Receive();
    
    // 关闭连接
    public abstract void Close();
}
```

### 消息发送

```csharp
// 发送消息
public void Send(IMessage message)
{
    // 序列化消息
    MemoryBuffer buffer = MemoryPackHelper.Serialize(message);
    
    // 发送到网络
    this.channel.Send(buffer);
}
```

### 消息接收

```csharp
// 接收消息循环
private void Receive()
{
    while (this.IsConnected)
    {
        // 从网络读取数据
        MemoryBuffer buffer = this.channel.Receive();
        
        // 反序列化消息
        IMessage message = MemoryPackHelper.Deserialize(buffer);
        
        // 投递到Fiber
        this.fiber.Root.GetComponent<MailboxComponent>().Add(message);
    }
}
```

## 消息系统

### 消息定义

```protobuf
// Proto消息定义
syntax = "proto3";

package ET;

// C2M: 客户端到Map服务器
message C2M_TestRobotCase1
{
    int32 RpcId = 1;        // RPC ID
    string Name = 2;        // 名称
}

// M2C: Map服务器到客户端
message M2C_TestRobotCase1
{
    int32 RpcId = 1;        // RPC ID
    int32 Error = 2;        // 错误码
    string Message = 3;     // 消息
}
```

### 消息特性

```csharp
// 消息特性
[Message]
public partial class C2M_TestRobotCase1 : MessageObject, IActorLocationRequest
{
    public int RpcId { get; set; }
    public string Name { get; set; }
}

// 响应消息
[Response]
public partial class M2C_TestRobotCase1 : MessageObject, IActorLocationResponse
{
    public int RpcId { get; set; }
    public int Error { get; set; }
    public string Message { get; set; }
}
```

### 消息类型

```csharp
// 消息接口
public interface IMessage
{
    int RpcId { get; set; }
}

// 请求消息
public interface IRequest : IMessage
{
}

// 响应消息
public interface IResponse : IMessage
{
    int Error { get; set; }
    string Message { get; set; }
}

// Actor位置请求
public interface IActorLocationRequest : IRequest
{
}

// Actor位置响应
public interface IActorLocationResponse : IResponse
{
}
```

## 消息处理

### MessageHandler

```csharp
// 消息处理器基类
public abstract class MessageHandler<T> : IMessageHandler
    where T : struct, IMessage
{
    protected abstract ETTask Run(Scene scene, T message);
}
```

### 消息处理示例

```csharp
// 处理C2M消息
[MessageHandler(SceneType.Map)]
public class C2M_TestRobotCase1Handler : MessageHandler<Scene, C2M_TestRobotCase1, M2C_TestRobotCase1>
{
    protected override async ETTask Run(Scene scene, C2M_TestRobotCase1 request, M2C_TestRobotCase1 response)
    {
        // 处理消息逻辑
        Log.Debug($"Received message: {request.Name}");
        
        // 设置响应
        response.Message = "Success";
    }
}
```

## RPC调用

### Send (单向发送)

```csharp
// 发送消息，不等待响应
C2M_TestRobotCase1 message = C2M_TestRobotCase1.Create();
message.Name = "Test";

fiber.Root.GetComponent<ClientSenderComponent>().Send(message);
```

### Call (调用等待)

```csharp
// 发送消息并等待响应
C2M_TestRobotCase2 message = C2M_TestRobotCase2.Create();
message.Name = "Test";

var response = await fiber.Root.GetComponent<ClientSenderComponent>().Call(message);
Log.Debug($"Response: {response.Message}");
```

## 网络组件

### NetServices

```csharp
// 网络服务管理
public class NetServices : Singleton<NetServices>
{
    // 创建网络服务
    public AService CreateService(NetworkProtocol protocol, AddressFamily addressFamily);
    
    // 连接到服务器
    public async ETTask<AChannel> Connect(string address, int port);
}
```

### ClientSenderComponent

```csharp
// 客户端发送组件
public class ClientSenderComponent : Entity, IAwake
{
    // 发送消息
    public void Send(IMessage message);
    
    // 调用消息
    public async ETTask<TResponse> Call<TResponse>(IRequest request)
        where TResponse : IResponse, new();
}
```

## 序列化

### MemoryPack

```csharp
// MemoryPack序列化助手
public static class MemoryPackHelper
{
    // 序列化
    public static MemoryBuffer Serialize<T>(T obj);
    
    // 反序列化
    public static T Deserialize<T>(MemoryBuffer buffer);
}
```

### MongoBson

```csharp
// MongoBson序列化助手
public static class MongoHelper
{
    // 序列化
    public static string ToJson(object obj);
    
    // 反序列化
    public static T FromJson<T>(string json);
}
```

## 网络配置

### Opcode定义

```csharp
// 消息操作码定义
public static class OpcodeType
{
    public const ushort C2M_TestRobotCase1 = 10001;
    public const ushort M2C_TestRobotCase1 = 10002;
    
    // 获取消息类型
    public static Type GetType(ushort opcode);
    
    // 获取操作码
    public static ushort GetOpcode(Type type);
}
```

### 网络超时

```csharp
// 网络超时配置
public static class NetworkConfig
{
    // 连接超时（毫秒）
    public const int ConnectTimeout = 10000;
    
    // 发送超时（毫秒）
    public const int SendTimeout = 5000;
    
    // 接收超时（毫秒）
    public const int ReceiveTimeout = 30000;
}
```

## 最佳实践

### 1. 协议选择
- TCP: 可靠性要求高的场景
- KCP: 实时性要求高的场景
- WebSocket: Web平台支持

### 2. 消息设计
- 消息应该简单轻量
- 避免在消息中传递大对象
- 使用Proto定义清晰的结构

### 3. 错误处理
- 检查网络连接状态
- 处理超时和断线
- 提供重连机制

### 4. 性能优化
- 使用对象池减少GC
- 批量发送小消息
- 压缩大数据包

## 常见问题

### Q: 如何选择网络协议?
A: 
- TCP: 需要可靠传输，如登录、聊天
- KCP: 需要实时传输，如战斗、移动
- WebSocket: 需要Web支持，如H5游戏

### Q: 如何处理网络断开?
A: 
1. 监听连接状态
2. 实现自动重连
3. 保存本地状态
4. 同步服务器数据

### Q: 如何优化网络性能?
A: 
1. 使用对象池
2. 批量发送消息
3. 压缩数据
4. 优化协议设计

## 相关文档

- [ECS架构](ECS架构.md)
- [Fiber模块](Fiber模块.md)
- [热更新机制](热更新机制.md)
- [服务端模块](服务端模块.md)
