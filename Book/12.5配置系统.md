# 配置系统

## 概述

ET框架提供强大的配置系统，支持Excel配置、JSON配置、ScriptableObject配置等多种配置格式，支持热更新和实时加载。

## 配置架构

### 配置组件

```
Config
├── ConfigComponent          # 配置组件
├── ConfigCategory           # 配置类别
├── ConfigSingleton          # 配置单例
└── IConfig                  # 配置接口
```

## 配置接口

### IConfig

```csharp
// 配置接口
public interface IConfig
{
    int Id { get; set; }
}
```

### IMerge

```csharp
// 配置合并接口
public interface IMerge
{
    void Merge(object obj);
}
```

## 配置组件

### ConfigComponent

```csharp
// 配置组件
public class ConfigComponent : Entity, IAwake
{
    // 配置类别字典
    private Dictionary<Type, object> allConfig = new();
    
    // 加载配置
    public async ETTask LoadConfigAsync();
    
    // 获取配置类别
    public T GetConfig<T>() where T : ConfigSingleton, new();
    
    // 获取配置项
    public T Get<T>(int id) where T : IConfig;
}
```

### 配置加载

```csharp
// 加载配置
public static async ETTask LoadConfigAsync(this ConfigComponent self)
{
    // 1. 加载Excel配置
    await self.LoadExcelConfigAsync();
    
    // 2. 加载JSON配置
    await self.LoadJsonConfigAsync();
    
    // 3. 加载ScriptableObject配置
    await self.LoadScriptableObjectConfigAsync();
}

// 加载Excel配置
private static async ETTask LoadExcelConfigAsync(this ConfigComponent self)
{
    // 1. 读取配置文件
    byte[] configBytes = await ResourcesComponent.Instance.LoadAssetAsync<byte[]>("Config/Excel/c/AllConfig.bytes");
    
    // 2. 反序列化配置
    List<object> configs = MemoryPackHelper.Deserialize<List<object>>(configBytes);
    
    // 3. 分类配置
    foreach (object config in configs)
    {
        Type type = config.GetType();
        self.allConfig[type] = config;
    }
}
```

## 配置类别

### ConfigCategory

```csharp
// 配置类别基类
public abstract class ConfigCategory : IMerge
{
    // 配置字典
    protected Dictionary<int, IConfig> dict = new();
    
    // 获取配置项
    public T Get<T>(int id) where T : IConfig
    {
        return (T)dict[id];
    }
    
    // 获取所有配置项
    public Dictionary<int, T> GetAll<T>() where T : IConfig
    {
        return (Dictionary<int, T>)dict;
    }
    
    // 合并配置
    public virtual void Merge(object obj)
    {
        ConfigCategory other = (ConfigCategory)obj;
        foreach (var kv in other.dict)
        {
            dict[kv.Key] = kv.Value;
        }
    }
}
```

### ConfigSingleton

```csharp
// 配置单例基类
public abstract class ConfigSingleton : IMerge
{
    // 单例实例
    public static T Instance { get; private set; }
    
    // 初始化单例
    public void Init()
    {
        Instance = (T)this;
    }
    
    // 合并配置
    public abstract void Merge(object obj);
}
```

## Excel配置

### Excel配置结构

```
Config/Excel/
├── Datas/
│   ├── AIConfig.xlsx        # AI配置
│   ├── BuffConfig.xlsx      # Buff配置
│   ├── ItemConfig.xlsx      # 物品配置
│   ├── SkillConfig.xlsx     # 技能配置
│   ├── UnitConfig.xlsx      # 单位配置
│   ├── QuestConfig.xlsx     # 任务配置
│   └── __beans__.xlsx       # 配置定义
└── Defines/
    └── __root__.xml         # 根配置
```

### 配置定义

```xml
<!-- __root__.xml -->
<?xml version="1.0" encoding="utf-8"?>
<root>
    <bean name="AIConfig">
        <var name="Id" type="int"/>
        <var name="Name" type="string"/>
        <var name="BehaviorTree" type="string"/>
        <var name="AttackRange" type="float"/>
        <var name="ChaseRange" type="float"/>
        <var name="PatrolRange" type="float"/>
    </bean>
    
    <bean name="BuffConfig">
        <var name="Id" type="int"/>
        <var name="Name" type="string"/>
        <var name="Duration" type="int"/>
        <var name="Effects" type="list,BuffEffect"/>
    </bean>
    
    <bean name="BuffEffect">
        <var name="Type" type="int"/>
        <var name="Value" type="int"/>
    </bean>
</root>
```

### AI配置示例

```
AIConfig.xlsx:
Id  Name           BehaviorTree    AttackRange  ChaseRange  PatrolRange
1   GuardAI        GuardTree       5.0          10.0        20.0
2   ChaseAI        ChaseTree       3.0          15.0        10.0
3   AttackAI       AttackTree      8.0          12.0        5.0
```

### 生成的配置代码

```csharp
// AI配置类别
public partial class AIConfigCategory : ConfigSingleton<AIConfigCategory>, IMerge
{
    private Dictionary<int, AIConfig> dict = new();
    
    public AIConfig Get(int id)
    {
        return this.dict[id];
    }
    
    public Dictionary<int, AIConfig> GetAll()
    {
        return this.dict;
    }
    
    public void Merge(object obj)
    {
        AIConfigCategory other = (AIConfigCategory)obj;
        foreach (var kv in other.dict)
        {
            this.dict[kv.Key] = kv.Value;
        }
    }
}

// AI配置项
public partial class AIConfig : IConfig
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string BehaviorTree { get; set; }
    public float AttackRange { get; set; }
    public float ChaseRange { get; set; }
    public float PatrolRange { get; set; }
}
```

### 配置使用

```csharp
// 获取配置类别
AIConfigCategory configCategory = ConfigCategory.Instance.Get<AIConfigCategory>();

// 获取配置项
AIConfig config = configCategory.Get(1);

// 使用配置
string behaviorTree = config.BehaviorTree;
float attackRange = config.AttackRange;
```

## JSON配置

### JSON配置结构

```
Config/Json/
├── c/                     # 客户端JSON配置
│   ├── GameConfig.json    # 游戏配置
│   └── NetworkConfig.json # 网络配置
├── s/                     # 服务端JSON配置
│   ├── ServerConfig.json  # 服务器配置
│   └── DBConfig.json     # 数据库配置
└── cs/                    # 客户端和服务端共享配置
    └── CommonConfig.json  # 通用配置
```

### GameConfig.json

```json
{
  "FrameRate": 60,
  "ResolutionWidth": 1920,
  "ResolutionHeight": 1080,
  "QualityLevel": 2,
  "VSyncEnabled": true,
  "AntiAliasing": 4
}
```

### JSON配置加载

```csharp
// 加载JSON配置
public static async ETTask<T> LoadJsonConfigAsync<T>(string configPath)
{
    // 1. 读取JSON文件
    TextAsset jsonAsset = await ResourcesComponent.Instance.LoadAssetAsync<TextAsset>(configPath);
    
    // 2. 反序列化JSON
    T config = JsonHelper.FromJson<T>(jsonAsset.text);
    
    // 3. 返回配置
    return config;
}

// 使用JSON配置
GameConfig gameConfig = await LoadJsonConfigAsync<GameConfig>("Config/Json/c/GameConfig.json");
int frameRate = gameConfig.FrameRate;
```

## ScriptableObject配置

### ScriptableObject配置

```csharp
// 游戏配置ScriptableObject
[CreateAssetMenu(fileName = "GameConfig", menuName = "ET/Config/GameConfig")]
public class GameConfig : ScriptableObject
{
    // 帧率
    public int FrameRate = 60;
    
    // 分辨率
    public Vector2Int Resolution = new Vector2Int(1920, 1080);
    
    // 质量等级
    public int QualityLevel = 2;
    
    // 垂直同步
    public bool VSyncEnabled = true;
}
```

### 配置导出

```powershell
# 导出ScriptableObject配置
# Unity菜单: ET -> WOW -> ExportScriptableObject
```

## 配置热更新

### 配置更新

```csharp
// 重新加载配置
public static async ETTask ReloadConfigAsync(this ConfigComponent self)
{
    // 1. 卸载旧配置
    self.UnloadConfig();
    
    // 2. 加载新配置
    await self.LoadConfigAsync();
    
    // 3. 通知配置更新
    EventSystem.Instance.Publish(self.Scene(), new EventType.ConfigReload());
}
```

### 配置监听

```csharp
// 监听配置更新
[Event(SceneType.Client)]
public class ConfigReloadEvent : AEvent<Scene, EventType.ConfigReload>
{
    protected override async ETTask Run(Scene scene, EventType.ConfigReload args)
    {
        Log.Debug("Config reloaded");
        
        // 更新游戏设置
        UpdateGameSettings();
    }
}
```

## 配置验证

### 配置验证

```csharp
// 验证配置
public static bool ValidateConfig(this ConfigComponent self)
{
    bool isValid = true;
    
    // 1. 验证所有配置类别
    foreach (var kv in self.allConfig)
    {
        if (!ValidateConfigCategory(kv.Value))
        {
            Log.Error($"Config category {kv.Key.Name} validation failed");
            isValid = false;
        }
    }
    
    return isValid;
}

// 验证配置类别
private static bool ValidateConfigCategory(object config)
{
    // 1. 检查配置是否为空
    if (config == null)
    {
        return false;
    }
    
    // 2. 检查配置项
    if (config is ConfigCategory category)
    {
        return category.GetAll().Count > 0;
    }
    
    return true;
}
```

## 配置编辑器

### 配置编辑器

```csharp
// 配置编辑器窗口
public class ConfigEditorWindow : EditorWindow
{
    // 配置类别
    private Type configType;
    
    // 配置数据
    private object configData;
    
    // 显示编辑器
    [MenuItem("ET/Config Editor")]
    public static void ShowWindow()
    {
        GetWindow<ConfigEditorWindow>("Config Editor");
    }
    
    // 绘制GUI
    private void OnGUI()
    {
        // 1. 配置类别选择
        configType = EditorGUILayout.ObjectField("Config Type", configType, typeof(ScriptableObject), false) as Type;
        
        // 2. 配置编辑
        if (configData != null)
        {
            DrawConfigEditor(configData);
        }
        
        // 3. 保存按钮
        if (GUILayout.Button("Save"))
        {
            SaveConfig();
        }
    }
}
```

## 最佳实践

### 1. 配置设计
- 使用配置管理系统
- 配置类型安全
- 支持热更新
- 易于扩展

### 2. 配置管理
- 版本控制
- 配置文档
- 配置验证
- 配置备份

### 3. 性能优化
- 延迟加载
- 配置缓存
- 批量加载
- 异步加载

### 4. 调试工具
- 配置查看器
- 配置验证器
- 配置比较器
- 配置导出器

## 常见问题

### Q: 配置热更新后如何生效?
A: 
1. 重新加载配置
2. 通知配置更新事件
3. 各模块监听事件
4. 应用新配置

### Q: 如何处理配置冲突?
A: 
1. 定义优先级
2. 配置合并策略
3. 冲突检测
4. 冲突解决

### Q: 如何优化配置加载性能?
A: 
1. 延迟加载
2. 配置缓存
3. 异步加载
4. 增量加载

## 相关文档

- [工具模块](工具模块.md)
- [数值系统](数值系统.md)
- [AI模块](AI模块.md)
- [项目概述](项目概述.md)
