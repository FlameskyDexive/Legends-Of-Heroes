# 序列化系统

## 概述

ET框架提供多种序列化方案，包括MemoryPack、MongoBson等，支持高效的数据序列化和反序列化，用于网络通信、数据持久化等场景。

## 序列化架构

### 序列化组件

```
Serialize
├── MemoryPackHelper       # MemoryPack序列化助手
├── MongoHelper           # Mongo序列化助手
├── ProtoBufHelper        # ProtoBuf序列化助手
└── MemoryBuffer          # 内存缓冲区
```

## MemoryPack

### MemoryPackHelper

```csharp
// MemoryPack序列化助手
public static class MemoryPackHelper
{
    // 序列化
    public static byte[] Serialize<T>(T obj)
    {
        return MemoryPackSerializer.Serialize(obj);
    }
    
    // 反序列化
    public static T Deserialize<T>(byte[] bytes)
    {
        return MemoryPackSerializer.Deserialize<T>(bytes);
    }
    
    // 序列化到MemoryBuffer
    public static void Serialize<T>(T obj, MemoryBuffer buffer)
    {
        byte[] bytes = Serialize(obj);
        buffer.Write(bytes);
    }
    
    // 从MemoryBuffer反序列化
    public static T Deserialize<T>(MemoryBuffer buffer)
    {
        byte[] bytes = buffer.ReadBytes();
        return Deserialize<T>(bytes);
    }
}
```

### MemoryBuffer

```csharp
// 内存缓冲区
public class MemoryBuffer
{
    // 缓冲区数据
    private byte[] buffer;
    
    // 读写位置
    private int readPosition;
    private int writePosition;
    
    // 写入数据
    public void Write(byte value);
    public void Write(byte[] value);
    public void Write(int value);
    public void Write(long value);
    public void Write(float value);
    public void Write(double value);
    public void Write(string value);
    
    // 读取数据
    public byte ReadByte();
    public byte[] ReadBytes();
    public int ReadInt();
    public long ReadLong();
    public float ReadFloat();
    public double ReadDouble();
    public string ReadString();
}
```

### MemoryPack使用

```csharp
// 序列化对象
PlayerData data = new PlayerData
{
    Id = 1,
    Name = "Player",
    Level = 10,
    Hp = 1000
};

byte[] bytes = MemoryPackHelper.Serialize(data);

// 反序列化对象
PlayerData deserializedData = MemoryPackHelper.Deserialize<PlayerData>(bytes);
```

## MongoBson

### MongoHelper

```csharp
// Mongo序列化助手
public static class MongoHelper
{
    // 序列化到JSON
    public static string ToJson(object obj)
    {
        return obj.ToJson();
    }
    
    // 从JSON反序列化
    public static T FromJson<T>(string json)
    {
        return BsonSerializer.Deserialize<T>(json);
    }
    
    // 序列化到BsonDocument
    public static BsonDocument ToBsonDocument(object obj)
    {
        return obj.ToBsonDocument();
    }
    
    // 从BsonDocument反序列化
    public static T FromBsonDocument<T>(BsonDocument doc)
    {
        return BsonSerializer.Deserialize<T>(doc);
    }
    
    // 序列化到字节数组
    public static byte[] ToBson(object obj)
    {
        return obj.ToBson();
    }
    
    // 从字节数组反序列化
    public static T FromBson<T>(byte[] bytes)
    {
        return BsonSerializer.Deserialize<T>(bytes);
    }
}
```

### MongoBson使用

```csharp
// 序列化到JSON
PlayerData data = new PlayerData
{
    Id = 1,
    Name = "Player",
    Level = 10,
    Hp = 1000
};

string json = MongoHelper.ToJson(data);

// 从JSON反序列化
PlayerData deserializedData = MongoHelper.FromJson<PlayerData>(json);
```

## ProtoBuf

### ProtoBufHelper

```csharp
// ProtoBuf序列化助手
public static class ProtoBufHelper
{
    // 序列化
    public static byte[] Serialize<T>(T obj)
    {
        using MemoryStream stream = new MemoryStream();
        ProtoBuf.Serializer.Serialize(stream, obj);
        return stream.ToArray();
    }
    
    // 反序列化
    public static T Deserialize<T>(byte[] bytes)
    {
        using MemoryStream stream = new MemoryStream(bytes);
        return ProtoBuf.Serializer.Deserialize<T>(stream);
    }
}
```

### ProtoBuf使用

```csharp
// 定义ProtoBuf可序列化类
[ProtoContract]
public class PlayerData
{
    [ProtoMember(1)]
    public int Id { get; set; }
    
    [ProtoMember(2)]
    public string Name { get; set; }
    
    [ProtoMember(3)]
    public int Level { get; set; }
    
    [ProtoMember(4)]
    public long Hp { get; set; }
}

// 序列化
PlayerData data = new PlayerData
{
    Id = 1,
    Name = "Player",
    Level = 10,
    Hp = 1000
};

byte[] bytes = ProtoBufHelper.Serialize(data);

// 反序列化
PlayerData deserializedData = ProtoBufHelper.Deserialize<PlayerData>(bytes);
```

## Entity序列化

### ISerializeToEntity

```csharp
// 序列化到Entity接口
public interface ISerializeToEntity
{
    void SerializeTo(Entity entity);
    
    void DeserializeFrom(Entity entity);
}
```

### Entity序列化

```csharp
// Entity序列化
public static void Serialize(this Entity self, MemoryBuffer buffer)
{
    // 1. 写入Entity类型
    buffer.Write(self.GetType().FullName);
    
    // 2. 写入Entity ID
    buffer.Write(self.Id);
    
    // 3. 序列化组件
    foreach (Entity child in self.Children)
    {
        if (child is ISerializeToEntity serializeToEntity)
        {
            serializeToEntity.SerializeTo(self);
        }
    }
}

// Entity反序列化
public static Entity Deserialize(this Entity self, MemoryBuffer buffer)
{
    // 1. 读取Entity类型
    string typeName = buffer.ReadString();
    Type type = Type.GetType(typeName);
    
    // 2. 读取Entity ID
    long id = buffer.ReadLong();
    
    // 3. 创建Entity
    Entity entity = EntityFactory.Create(type, self, true);
    entity.Id = id;
    
    // 4. 反序列化组件
    foreach (Entity child in entity.Children)
    {
        if (child is ISerializeToEntity serializeToEntity)
        {
            serializeToEntity.DeserializeFrom(entity);
        }
    }
    
    return entity;
}
```

## 消息序列化

### IMessage

```csharp
// 消息接口
public interface IMessage
{
    int RpcId { get; set; }
}
```

### 消息序列化

```csharp
// 序列化消息
public static byte[] SerializeMessage(IMessage message)
{
    // 1. 获取消息类型
    Type messageType = message.GetType();
    
    // 2. 获取消息操作码
    ushort opcode = OpcodeType.GetOpcode(messageType);
    
    // 3. 序列化消息体
    byte[] body = MemoryPackHelper.Serialize(message);
    
    // 4. 组装消息包
    byte[] packet = new byte[2 + body.Length];
    packet[0] = (byte)(opcode >> 8);
    packet[1] = (byte)opcode;
    Array.Copy(body, 0, packet, 2, body.Length);
    
    return packet;
}

// 反序列化消息
public static IMessage DeserializeMessage(byte[] packet)
{
    // 1. 读取操作码
    ushort opcode = (ushort)((packet[0] << 8) | packet[1]);
    
    // 2. 获取消息类型
    Type messageType = OpcodeType.GetType(opcode);
    
    // 3. 反序列化消息体
    byte[] body = new byte[packet.Length - 2];
    Array.Copy(packet, 2, body, 0, body.Length);
    
    IMessage message = MemoryPackHelper.Deserialize<IMessage>(body);
    return message;
}
```

## 配置序列化

### 配置序列化

```csharp
// 序列化配置
public static byte[] SerializeConfig<T>(T config) where T : IConfig
{
    return MemoryPackHelper.Serialize(config);
}

// 反序列化配置
public static T DeserializeConfig<T>(byte[] bytes) where T : IConfig
{
    return MemoryPackHelper.Deserialize<T>(bytes);
}

// 批量序列化配置
public static byte[] SerializeAllConfig(List<IConfig> configs)
{
    return MemoryPackHelper.Serialize(configs);
}

// 批量反序列化配置
public static List<IConfig> DeserializeAllConfig(byte[] bytes)
{
    return MemoryPackHelper.Deserialize<List<IConfig>>(bytes);
}
```

## 数据持久化

### DB序列化

```csharp
// 保存到数据库
public static async ETTask SaveToDB(this Entity self)
{
    // 1. 序列化Entity
    MemoryBuffer buffer = new MemoryBuffer();
    self.Serialize(buffer);
    
    // 2. 获取数据库组件
    DBComponent db = self.Scene().GetComponent<DBComponent>();
    
    // 3. 保存到数据库
    await db.Save(self.Id, buffer.ToBytes());
}

// 从数据库加载
public static async ETTask<T> LoadFromDB<T>(this Scene scene, long id) where T : Entity
{
    // 1. 获取数据库组件
    DBComponent db = scene.GetComponent<DBComponent>();
    
    // 2. 从数据库加载
    byte[] bytes = await db.Query<T>(id);
    
    // 3. 反序列化Entity
    MemoryBuffer buffer = new MemoryBuffer(bytes);
    T entity = buffer.Deserialize<T>();
    
    return entity;
}
```

## 性能优化

### 对象池

```csharp
// MemoryBuffer对象池
public static class MemoryBufferPool
{
    // 对象池
    private static readonly Queue<MemoryBuffer> pool = new Queue<MemoryBuffer>();
    
    // 获取缓冲区
    public static MemoryBuffer Get()
    {
        if (pool.Count > 0)
        {
            return pool.Dequeue();
        }
        return new MemoryBuffer();
    }
    
    // 归还缓冲区
    public static void Return(MemoryBuffer buffer)
    {
        buffer.Clear();
        pool.Enqueue(buffer);
    }
}
```

### 批量序列化

```csharp
// 批量序列化
public static byte[] SerializeBatch<T>(List<T> items)
{
    using MemoryStream stream = new MemoryStream();
    foreach (T item in items)
    {
        byte[] bytes = MemoryPackHelper.Serialize(item);
        stream.Write(bytes, 0, bytes.Length);
    }
    return stream.ToArray();
}

// 批量反序列化
public static List<T> DeserializeBatch<T>(byte[] bytes)
{
    List<T> items = new List<T>();
    int position = 0;
    while (position < bytes.Length)
    {
        T item = MemoryPackHelper.Deserialize<T>(bytes, ref position);
        items.Add(item);
    }
    return items;
}
```

## 最佳实践

### 1. 序列化选择
- 网络通信：MemoryPack
- 数据持久化：MongoBson
- 配置文件：JSON/Excel
- Proto消息：ProtoBuf

### 2. 性能优化
- 使用对象池
- 批量序列化
- 延迟序列化
- 压缩数据

### 3. 数据安全
- 加密敏感数据
- 数据验证
- 版本兼容
- 错误处理

### 4. 调试工具
- 序列化查看器
- 数据比较器
- 性能分析器
- 版本迁移工具

## 常见问题

### Q: 如何处理序列化版本兼容?
A: 
1. 使用版本号
2. 兼容旧数据
3. 数据迁移
4. 版本检测

### Q: 如何优化序列化性能?
A: 
1. 使用对象池
2. 批量序列化
3. 减少序列化次数
4. 使用压缩

### Q: 如何处理大对象序列化?
A: 
1. 分块序列化
2. 流式处理
3. 异步序列化
4. 进度显示

## 相关文档

- [网络通信模块](网络通信模块.md)
- [配置系统](配置系统.md)
- [ECS架构](ECS架构.md)
- [项目概述](项目概述.md)
