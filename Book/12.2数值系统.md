# 数值系统

## 概述

ET框架提供强大的数值系统，支持复杂的数值计算、数值修改、数值同步等功能。数值系统是游戏数值设计的核心，用于管理角色的属性、技能效果、Buff等数值变化。

## 数值系统架构

### 核心组件

```
Numeric
├── NumericComponent       # 数值组件
├── NumericConfig          # 数值配置
├── NumericWatcher         # 数值监听器
└── NumericEvent           # 数值事件
```

## NumericComponent

### 核心组件

```csharp
// 数值组件
public class NumericComponent : Entity, IAwake
{
    // 数值字典
    private Dictionary<int, long> numericDic = new();
    
    // 数值监听器
    private List<INumericWatcher> watchers = new();
    
    // 获取数值
    public long Get(int numericType);
    
    // 设置数值
    public void Set(int numericType, long value);
    
    // 增加数值
    public void Add(int numericType, long value);
    
    // 减少数值
    public void Sub(int numericType, long value);
}
```

### 数值类型

```csharp
// 数值类型
public static class NumericType
{
    // 基础属性
    public const int MaxHp = 1000;              # 最大生命值
    public const int Hp = 1001;                 # 当前生命值
    public const int MaxMp = 1002;              # 最大魔法值
    public const int Mp = 1003;                 # 当前魔法值
    public const int Attack = 1004;             # 攻击力
    public const int Defense = 1005;            # 防御力
    public const int Speed = 1006;              # 移动速度
    public const int AttackSpeed = 1007;        # 攻击速度
    
    // 战斗属性
    public const int CriticalRate = 2000;       # 暴击率
    public const int CriticalDamage = 2001;     # 暴击伤害
    public const int HitRate = 2002;           # 命中率
    public const int DodgeRate = 2003;          # 闪避率
    
    // 等级和经验
    public const int Level = 3000;              # 等级
    public const int Exp = 3001;                # 经验值
    public const int MaxExp = 3002;             # 最大经验值
    
    // 资源
    public const int Gold = 4000;              # 金币
    public const int Diamond = 4001;            # 钻石
    public const int Stamina = 4002;            # 体力
    
    // Buff和技能
    public const int BuffCount = 5000;          # Buff数量
    public const int SkillLevel = 5001;         # 技能等级
}
```

### 数值操作

```csharp
// 获取数值
public static long Get(this NumericComponent self, int numericType)
{
    long value = 0;
    self.numericDic.TryGetValue(numericType, out value);
    return value;
}

// 设置数值
public static void Set(this NumericComponent self, int numericType, long value)
{
    long oldValue = self.Get(numericType);
    self.numericDic[numericType] = value;
    
    // 通知监听器
    self.NotifyWatcher(numericType, oldValue, value);
}

// 增加数值
public static void Add(this NumericComponent self, int numericType, long value)
{
    long oldValue = self.Get(numericType);
    long newValue = oldValue + value;
    self.Set(numericType, newValue);
}

// 减少数值
public static void Sub(this NumericComponent self, int numericType, long value)
{
    self.Add(numericType, -value);
}
```

## 数值计算

### 基础计算

```csharp
// 计算伤害
public static long CalculateDamage(this NumericComponent self, NumericComponent target)
{
    long attack = self.Get(NumericType.Attack);
    long defense = target.Get(NumericType.Defense);
    
    // 基础伤害
    long damage = attack - defense;
    if (damage < 1)
    {
        damage = 1;
    }
    
    // 暴击判断
    if (RandomHelper.RandomRate(self.Get(NumericType.CriticalRate)))
    {
        long criticalDamage = self.Get(NumericType.CriticalDamage);
        damage = damage * criticalDamage / 100;
    }
    
    return damage;
}
```

### 数值公式

```csharp
// 等级升级所需经验
public static long GetLevelUpExp(int level)
{
    return level * level * 100;
}

// 最大生命值计算
public static long CalculateMaxHp(int level, long baseHp)
{
    return baseHp + level * 100;
}

// 攻击力计算
public static long CalculateAttack(int level, long baseAttack)
{
    return baseAttack + level * 10;
}
```

### 百分比计算

```csharp
// 百分比加成
public static long AddPercentage(long baseValue, long percentage)
{
    return baseValue * (100 + percentage) / 100;
}

// 百分比减益
public static long SubPercentage(long baseValue, long percentage)
{
    return baseValue * (100 - percentage) / 100;
}
```

## 数值监听

### INumericWatcher

```csharp
// 数值监听器接口
public interface INumericWatcher
{
    // 数值变化回调
    void OnValueChanged(NumericComponent numeric, int numericType, long oldValue, long newValue);
}
```

### 注册监听器

```csharp
// 注册数值监听器
public static void RegisterWatcher(this NumericComponent self, INumericWatcher watcher)
{
    if (!self.watchers.Contains(watcher))
    {
        self.watchers.Add(watcher);
    }
}

// 注销监听器
public static void UnregisterWatcher(this NumericComponent self, INumericWatcher watcher)
{
    self.watchers.Remove(watcher);
}

// 通知监听器
private static void NotifyWatcher(this NumericComponent self, int numericType, long oldValue, long newValue)
{
    foreach (INumericWatcher watcher in self.watchers)
    {
        watcher.OnValueChanged(self, numericType, oldValue, newValue);
    }
}
```

### 监听器实现

```csharp
// HP监听器
public class HPWatcher : INumericWatcher
{
    private Unit unit;
    
    public HPWatcher(Unit unit)
    {
        this.unit = unit;
    }
    
    public void OnValueChanged(NumericComponent numeric, int numericType, long oldValue, long newValue)
    {
        if (numericType == NumericType.Hp)
        {
            // HP变化处理
            if (newValue <= 0)
            {
                // 角色死亡
                unit.Die();
            }
            else if (newValue < oldValue)
            {
                // 受到伤害
                OnDamage(oldValue - newValue);
            }
            else if (newValue > oldValue)
            {
                // 恢复生命
                OnHeal(newValue - oldValue);
            }
        }
    }
    
    private void OnDamage(long damage)
    {
        Log.Debug($"Unit {unit.Id} take damage: {damage}");
        
        // 触发受伤事件
        EventSystem.Instance.Publish(unit.Scene(), new EventType.UnitDamage()
        {
            Unit = unit,
            Damage = damage
        });
    }
    
    private void OnHeal(long heal)
    {
        Log.Debug($"Unit {unit.Id} heal: {heal}");
        
        // 触发治疗事件
        EventSystem.Instance.Publish(unit.Scene(), new EventType.UnitHeal()
        {
            Unit = unit,
            Heal = heal
        });
    }
}
```

## 数值同步

### 网络同步

```csharp
// 同步数值到客户端
public static async ETTask SyncNumeric(this NumericComponent self)
{
    // 获取需要同步的数值
    Dictionary<int, long> numericData = new Dictionary<int, long>();
    numericData[NumericType.Hp] = self.Get(NumericType.Hp);
    numericData[NumericType.Mp] = self.Get(NumericType.Mp);
    numericData[NumericType.Attack] = self.Get(NumericType.Attack);
    numericData[NumericType.Defense] = self.Get(NumericType.Defense);
    
    // 发送同步消息
    M2C_SyncNumeric message = M2C_SyncNumeric.Create();
    message.UnitId = self.GetParent<Unit>().Id;
    message.NumericData = numericData;
    
    await MessageHelper.SendActor(self.GetParent<Unit>().Id, message);
}
```

### 数值变化事件

```csharp
// 数值变化事件
[Event(SceneType.Map)]
public class NumericChangeEvent : AEvent<Scene, EventType.NumericChange>
{
    protected override async ETTask Run(Scene scene, EventType.NumericChange args)
    {
        // 广播数值变化
        M2C_NumericChange message = M2C_NumericChange.Create();
        message.UnitId = args.UnitId;
        message.NumericType = args.NumericType;
        message.OldValue = args.OldValue;
        message.NewValue = args.NewValue;
        
        await MessageHelper.Broadcast(message);
    }
}
```

## 数值配置

### NumericConfig

```csharp
// 数值配置
public partial class NumericConfig : IConfig
{
    public int Id { get; set; }
    public int Level { get; set; }
    public long MaxHp { get; set; }
    public long MaxMp { get; set; }
    public long Attack { get; set; }
    public long Defense { get; set; }
    public long Speed { get; set; }
}
```

### 配置示例

```
NumericConfig.xlsx:
Id  Level  MaxHp  MaxMp  Attack  Defense  Speed
1   1      100    50     10      5        3
2   2      200    100    20      10       4
3   3      300    150    30      15       5
```

## Buff系统

### BuffComponent

```csharp
// Buff组件
public class BuffComponent : Entity, IAwake
{
    // Buff列表
    public Dictionary<int, Buff> Buffs = new();
    
    // 添加Buff
    public Buff Add(int buffId);
    
    // 移除Buff
    public void Remove(int buffId);
    
    // 检查Buff
    public bool HasBuff(int buffId);
    
    // 更新Buff
    public void Update();
}
```

### Buff

```csharp
// Buff实体
public class Buff : Entity, IAwake
{
    // Buff ID
    public int BuffId;
    
    // Buff配置
    public BuffConfig Config;
    
    // 剩余时间
    public long RemainingTime;
    
    // 堆叠层数
    public int StackCount;
    
    // 应用Buff效果
    public void ApplyEffect();
    
    // 移除Buff效果
    public void RemoveEffect();
}
```

### Buff效果

```csharp
// 应用Buff效果
public static void ApplyEffect(this Buff self)
{
    Unit unit = self.GetParent<Unit>();
    NumericComponent numeric = unit.GetComponent<NumericComponent>();
    
    // 应用Buff效果
    foreach (BuffEffect effect in self.Config.Effects)
    {
        switch (effect.Type)
        {
            case BuffEffectType.AddHp:
                numeric.Add(NumericType.Hp, effect.Value);
                break;
            case BuffEffectType.AddAttack:
                numeric.Add(NumericType.Attack, effect.Value);
                break;
            case BuffEffectType.AddDefense:
                numeric.Add(NumericType.Defense, effect.Value);
                break;
            case BuffEffectType.AddSpeed:
                numeric.Add(NumericType.Speed, effect.Value);
                break;
        }
    }
}
```

## 技能系统

### SkillComponent

```csharp
// 技能组件
public class SkillComponent : Entity, IAwake
{
    // 技能列表
    public Dictionary<int, Skill> Skills = new();
    
    // 添加技能
    public Skill Add(int skillId);
    
    // 移除技能
    public void Remove(int skillId);
    
    // 使用技能
    public async ETTask UseSkill(int skillId);
}
```

### 技能伤害

```csharp
// 计算技能伤害
public static long CalculateSkillDamage(this Skill self, Unit target)
{
    Unit caster = self.GetParent<Unit>();
    NumericComponent casterNumeric = caster.GetComponent<NumericComponent>();
    NumericComponent targetNumeric = target.GetComponent<NumericComponent>();
    
    // 基础伤害
    long baseDamage = self.Config.BaseDamage;
    
    // 攻击力加成
    long attackBonus = casterNumeric.Get(NumericType.Attack) * self.Config.AttackPercent / 100;
    
    // 防御减免
    long defense = targetNumeric.Get(NumericType.Defense);
    long defenseReduction = defense * self.Config.DefensePercent / 100;
    
    // 计算最终伤害
    long damage = baseDamage + attackBonus - defenseReduction;
    if (damage < 1)
    {
        damage = 1;
    }
    
    return damage;
}
```

## 最佳实践

### 1. 数值设计
- 使用配置管理
- 支持动态调整
- 保持数值平衡
- 易于扩展

### 2. 性能优化
- 减少计算频率
- 使用缓存
- 批量更新
- 延迟计算

### 3. 数值同步
- 选择同步频率
- 优化网络带宽
- 使用压缩
- 差异同步

### 4. 调试工具
- 数值监控
- 变化追踪
- 公式验证
- 平衡测试

## 常见问题

### Q: 如何处理数值溢出?
A: 
1. 使用long类型
2. 添加边界检查
3. 数值限制
4. 异常处理

### Q: 如何优化数值计算性能?
A: 
1. 减少计算频率
2. 使用缓存
3. 批量更新
4. 预计算

### Q: 如何同步数值到客户端?
A: 
1. 选择同步策略
2. 压缩数据
3. 差异同步
4. 本地预测

## 相关文档

- [ECS架构](ECS架构.md)
- [Fiber模块](Fiber模块.md)
- [AI模块](AI模块.md)
- [服务端模块](服务端模块.md)
