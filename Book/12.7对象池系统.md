# 对象池系统

## 概述

ET框架提供高效的对象池系统，用于减少GC压力，提升游戏性能。对象池系统支持Entity、Message、Unity对象等多种对象类型。

## 对象池架构

### 对象池组件

```
ObjectPool
├── ObjectPool<T>          # 对象池基类
├── EntityPool             # Entity对象池
├── MessagePool            # 消息对象池
├── UnityObjectPool        # Unity对象池
└── Pool<T>                # 通用对象池
```

## 对象池基类

### ObjectPool<T>

```csharp
// 对象池基类
public abstract class ObjectPool<T> where T : class, new()
{
    // 对象池
    private readonly Queue<T> pool = new Queue<T>();
    
    // 对象池容量
    private readonly int capacity;
    
    // 创建对象
    protected abstract T CreateObject();
    
    // 重置对象
    protected abstract void ResetObject(T obj);
    
    // 获取对象
    public T Fetch()
    {
        if (pool.Count > 0)
        {
            return pool.Dequeue();
        }
        return CreateObject();
    }
    
    // 回收对象
    public void Recycle(T obj)
    {
        if (pool.Count < capacity)
        {
            ResetObject(obj);
            pool.Enqueue(obj);
        }
    }
    
    // 清空对象池
    public void Clear()
    {
        pool.Clear();
    }
}
```

## Entity对象池

### EntityPool

```csharp
// Entity对象池
public class EntityPool : ObjectPool<Entity>
{
    private readonly Scene scene;
    private readonly Type type;
    
    public EntityPool(Scene scene, Type type, int capacity) : base(capacity)
    {
        this.scene = scene;
        this.type = type;
    }
    
    protected override Entity CreateObject()
    {
        return EntityFactory.Create(type, scene, false);
    }
    
    protected override void ResetObject(Entity obj)
    {
        // 清理Entity
        obj.DisposeChildren();
    }
}
```

### Entity对象池使用

```csharp
// 创建Entity对象池
EntityPool pool = new EntityPool(scene, typeof(Player), 100);

// 获取Entity
Player player = (Player)pool.Fetch();
player.Id = IdGenerater.Instance.GenerateId();
player.AddComponent<PlayerComponent>();

// 使用Entity...

// 回收Entity
pool.Recycle(player);
```

## 消息对象池

### MessagePool

```csharp
// 消息对象池
public class MessagePool : ObjectPool<IMessage>
{
    private readonly Type messageType;
    
    public MessagePool(Type messageType, int capacity) : base(capacity)
    {
        this.messageType = messageType;
    }
    
    protected override IMessage CreateObject()
    {
        return (IMessage)Activator.CreateInstance(messageType);
    }
    
    protected override void ResetObject(IMessage obj)
    {
        // 重置消息
        obj.RpcId = 0;
    }
}
```

### MessagePool使用

```csharp
// 创建消息对象池
MessagePool pool = new MessagePool(typeof(C2M_Login), 50);

// 获取消息
C2M_Login message = (C2M_Login)pool.Fetch();
message.RpcId = RpcId;
message.Account = "account";
message.Password = "password";

// 发送消息...
net.Send(message);

// 回收消息
pool.Recycle(message);
```

## Unity对象池

### UnityObjectPool

```csharp
// Unity对象池
public class UnityObjectPool<T> where T : Object
{
    // 对象池
    private readonly Queue<T> pool = new Queue<T>();
    
    // 对象池容量
    private readonly int capacity;
    
    // 预制体
    private readonly T prefab;
    
    // 父节点
    private readonly Transform parent;
    
    public UnityObjectPool(T prefab, int capacity, Transform parent = null)
    {
        this.prefab = prefab;
        this.capacity = capacity;
        this.parent = parent;
    }
    
    // 获取对象
    public T Fetch()
    {
        if (pool.Count > 0)
        {
            T obj = pool.Dequeue();
            obj.gameObject.SetActive(true);
            return obj;
        }
        return Object.Instantiate(prefab, parent);
    }
    
    // 回收对象
    public void Recycle(T obj)
    {
        if (pool.Count < capacity)
        {
            obj.gameObject.SetActive(false);
            pool.Enqueue(obj);
        }
        else
        {
            Object.Destroy(obj);
        }
    }
    
    // 清空对象池
    public void Clear()
    {
        foreach (T obj in pool)
        {
            Object.Destroy(obj);
        }
        pool.Clear();
    }
}
```

### Unity对象池使用

```csharp
// 创建Unity对象池
UnityObjectPool<GameObject> pool = new UnityObjectPool<GameObject>(bulletPrefab, 100, bulletContainer);

// 获取对象
GameObject bullet = pool.Fetch();
bullet.transform.position = spawnPosition;
bullet.GetComponent<Bullet>().Fire();

// 回收对象
pool.Recycle(bullet);
```

## 通用对象池

### Pool<T>

```csharp
// 通用对象池
public class Pool<T> where T : class, new()
{
    // 对象池
    private readonly Queue<T> pool = new Queue<T>();
    
    // 对象池容量
    private readonly int capacity;
    
    // 创建对象回调
    private readonly Func<T> createCallback;
    
    // 重置对象回调
    private readonly Action<T> resetCallback;
    
    public Pool(int capacity, Func<T> createCallback = null, Action<T> resetCallback = null)
    {
        this.capacity = capacity;
        this.createCallback = createCallback ?? (() => new T());
        this.resetCallback = resetCallback;
    }
    
    // 获取对象
    public T Fetch()
    {
        if (pool.Count > 0)
        {
            return pool.Dequeue();
        }
        return createCallback();
    }
    
    // 回收对象
    public void Recycle(T obj)
    {
        if (pool.Count < capacity)
        {
            resetCallback?.Invoke(obj);
            pool.Enqueue(obj);
        }
    }
    
    // 清空对象池
    public void Clear()
    {
        pool.Clear();
    }
}
```

### Pool使用

```csharp
// 创建对象池
Pool<List<int>> pool = new Pool<List<int>>(50,
    () => new List<int>(),
    list => list.Clear());

// 获取对象
List<int> list = pool.Fetch();
list.Add(1);
list.Add(2);
list.Add(3);

// 使用列表...

// 回收对象
pool.Recycle(list);
```

## 对象池管理器

### ObjectPoolManager

```csharp
// 对象池管理器
public class ObjectPoolManager : Singleton<ObjectPoolManager>
{
    // 对象池字典
    private readonly Dictionary<Type, object> pools = new Dictionary<Type, object>();
    
    // 获取或创建对象池
    public Pool<T> GetOrCreatePool<T>(int capacity, Func<T> createCallback = null, Action<T> resetCallback = null) where T : class, new()
    {
        Type type = typeof(T);
        if (!pools.TryGetValue(type, out object pool))
        {
            pool = new Pool<T>(capacity, createCallback, resetCallback);
            pools[type] = pool;
        }
        return (Pool<T>)pool;
    }
    
    // 获取或创建Unity对象池
    public UnityObjectPool<T> GetOrCreateUnityPool<T>(T prefab, int capacity, Transform parent = null) where T : Object
    {
        Type type = typeof(T);
        if (!pools.TryGetValue(type, out object pool))
        {
            pool = new UnityObjectPool<T>(prefab, capacity, parent);
            pools[type] = pool;
        }
        return (UnityObjectPool<T>)pool;
    }
    
    // 清空所有对象池
    public void ClearAll()
    {
        foreach (object pool in pools.Values)
        {
            if (pool is IDisposable disposable)
            {
                disposable.Dispose();
            }
        }
        pools.Clear();
    }
}
```

### 对象池管理器使用

```csharp
// 获取或创建对象池
Pool<List<int>> pool = ObjectPoolManager.Instance.GetOrCreatePool<List<int>>(50);

// 获取对象
List<int> list = pool.Fetch();

// 回收对象
pool.Recycle(list);

// 清空所有对象池
ObjectPoolManager.Instance.ClearAll();
```

## 对象池组件

### ObjectPoolComponent

```csharp
// 对象池组件
public class ObjectPoolComponent : Entity, IAwake
{
    // 对象池字典
    private readonly Dictionary<Type, object> pools = new Dictionary<Type, object>();
    
    // 获取或创建对象池
    public Pool<T> GetOrCreatePool<T>(int capacity, Func<T> createCallback = null, Action<T> resetCallback = null) where T : class, new()
    {
        Type type = typeof(T);
        if (!pools.TryGetValue(type, out object pool))
        {
            pool = new Pool<T>(capacity, createCallback, resetCallback);
            pools[type] = pool;
        }
        return (Pool<T>)pool;
    }
}
```

### 对象池组件使用

```csharp
// 获取对象池组件
ObjectPoolComponent poolComponent = scene.GetComponent<ObjectPoolComponent>();

// 获取或创建对象池
Pool<List<int>> pool = poolComponent.GetOrCreatePool<List<int>>(50);

// 获取对象
List<int> list = pool.Fetch();

// 回收对象
pool.Recycle(list);
```

## 性能监控

### 对象池统计

```csharp
// 对象池统计
public class ObjectPoolStats
{
    // 对象类型
    public Type Type { get; set; }
    
    // 对象池容量
    public int Capacity { get; set; }
    
    // 当前数量
    public int Count { get; set; }
    
    // 获取次数
    public int FetchCount { get; set; }
    
    // 回收次数
    public int RecycleCount { get; set; }
    
    // 创建次数
    public int CreateCount { get; set; }
}
```

### 对象池监控

```csharp
// 对象池监控
public static class ObjectPoolMonitor
{
    // 对象池统计字典
    private static readonly Dictionary<Type, ObjectPoolStats> stats = new Dictionary<Type, ObjectPoolStats>();
    
    // 记录获取
    public static void RecordFetch<T>()
    {
        Type type = typeof(T);
        if (!stats.TryGetValue(type, out ObjectPoolStats stat))
        {
            stat = new ObjectPoolStats { Type = type };
            stats[type] = stat;
        }
        stat.FetchCount++;
    }
    
    // 记录回收
    public static void RecordRecycle<T>()
    {
        Type type = typeof(T);
        if (!stats.TryGetValue(type, out ObjectPoolStats stat))
        {
            stat = new ObjectPoolStats { Type = type };
            stats[type] = stat;
        }
        stat.RecycleCount++;
    }
    
    // 获取统计
    public static ObjectPoolStats GetStats<T>()
    {
        Type type = typeof(T);
        return stats.TryGetValue(type, out ObjectPoolStats stat) ? stat : null;
    }
}
```

## 最佳实践

### 1. 对象池设计
- 合理设置容量
- 正确重置对象
- 避免对象泄漏
- 及时回收对象

### 2. 性能优化
- 预热对象池
- 分级对象池
- 异步回收
- 定期清理

### 3. 内存管理
- 监控内存使用
- 及时清理
- 避免过度分配
- 使用弱引用

### 4. 调试工具
- 对象池监控
- 内存分析
- 泄漏检测
- 性能统计

## 常见问题

### Q: 如何设置对象池容量?
A: 
1. 分析使用模式
2. 统计峰值数量
3. 设置合理容量
4. 动态调整

### Q: 如何处理对象泄漏?
A: 
1. 使用弱引用
2. 定期清理
3. 监控对象数量
4. 自动回收

### Q: 如何优化对象池性能?
A: 
1. 预热对象池
2. 分级对象池
3. 异步回收
4. 批量操作

## 相关文档

- [ECS架构](ECS架构.md)
- [Fiber模块](Fiber模块.md)
- [序列化系统](序列化系统.md)
- [项目概述](项目概述.md)
