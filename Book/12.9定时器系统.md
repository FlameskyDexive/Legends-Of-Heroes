# 定时器系统

## 概述

ET框架提供高效的定时器系统，支持一次性定时器、循环定时器、延迟任务等多种定时器类型。定时器系统是游戏开发中处理延迟操作和周期性任务的重要工具。

## 定时器架构

### 定时器组件

```
Timer
├── TimerComponent         # 定时器组件
├── ATimer                # 定时器基类
├── TimerCore             # 定时器核心
└── TimerTicker           # 定时器触发器
```

## TimerComponent

### TimerComponent

```csharp
// 定时器组件
public class TimerComponent : Entity, IAwake
{
    // 定时器字典
    private readonly Dictionary<long, ETTaskCompletionSource> timers = new Dictionary<long, ETTaskCompletionSource>();
    
    // 定时器ID生成器
    private long timerIdGenerator;
    
    // 创建一次性定时器
    public async ETTask WaitAsync(long time)
    {
        long timerId = ++timerIdGenerator;
        ETTaskCompletionSource tcs = ETTaskCompletionSource.Create();
        timers[timerId] = tcs;
        
        await TimerCore.Instance.AddAsyncTimer(timerId, time);
        
        await tcs.Task;
        timers.Remove(timerId);
    }
    
    // 创建循环定时器
    public async ETTask WaitRepeatedAsync(long time)
    {
        while (true)
        {
            await WaitAsync(time);
        }
    }
    
    // 取消定时器
    public void Remove(long id)
    {
        if (timers.TryGetValue(id, out ETTaskCompletionSource tcs))
        {
            timers.Remove(id);
            TimerCore.Instance.Remove(id);
            tcs.SetResult();
        }
    }
}
```

## ATimer

### ATimer

```csharp
// 定时器基类
public abstract class ATimer : Entity
{
    // 定时器ID
    protected long TimerId { get; set; }
    
    // 初始化定时器
    public void Init(long timerId)
    {
        TimerId = timerId;
    }
    
    // 定时器回调
    public abstract void Run();
}
```

### ATimer使用

```csharp
// 自定义定时器
public class HealTimer : ATimer
{
    // 角色组件
    private Unit unit;
    
    // 初始化
    public void Init(Unit u)
    {
        this.unit = u;
    }
    
    // 定时器回调
    public override void Run()
    {
        // 恢复生命值
        unit.GetComponent<NumericComponent>().Add(NumericType.Hp, 10);
    }
}

// 使用定时器
HealTimer timer = EntityFactory.Create<HealTimer>(scene, true);
timer.Init(unit);
timer.Init(timerId);
```

## TimerCore

### TimerCore

```csharp
// 定时器核心
public class TimerCore : Singleton<TimerCore>
{
    // 定时器队列
    private readonly PriorityQueue<TimerInfo, long> timerQueue = new PriorityQueue<TimerInfo, long>();
    
    // 定时器字典
    private readonly Dictionary<long, TimerInfo> timers = new Dictionary<long, TimerInfo>();
    
    // 添加一次性定时器
    public async ETTask AddAsyncTimer(long id, long time)
    {
        TimerInfo timerInfo = new TimerInfo
        {
            Id = id,
            Time = TimeInfo.Instance.ServerFrameTime() + time,
            Type = TimerType.Once,
            Task = ETTaskCompletionSource.Create()
        };
        
        timers[id] = timerInfo;
        timerQueue.Enqueue(timerInfo, timerInfo.Time);
        
        return timerInfo.Task.Task;
    }
    
    // 添加循环定时器
    public void AddRepeatedTimer(long id, long time)
    {
        TimerInfo timerInfo = new TimerInfo
        {
            Id = id,
            Time = TimeInfo.Instance.ServerFrameTime() + time,
            Interval = time,
            Type = TimerType.Repeated
        };
        
        timers[id] = timerInfo;
        timerQueue.Enqueue(timerInfo, timerInfo.Time);
    }
    
    // 移除定时器
    public void Remove(long id)
    {
        if (timers.TryGetValue(id, out TimerInfo timerInfo))
        {
            timers.Remove(id);
            timerInfo.Removed = true;
        }
    }
    
    // 更新定时器
    public void Update()
    {
        long currentTime = TimeInfo.Instance.ServerFrameTime();
        
        while (timerQueue.Count > 0)
        {
            TimerInfo timerInfo = timerQueue.Peek();
            
            if (timerInfo.Time > currentTime)
            {
                break;
            }
            
            timerQueue.Dequeue();
            
            if (timerInfo.Removed)
            {
                continue;
            }
            
            // 执行定时器
            if (timerInfo.Type == TimerType.Once)
            {
                timerInfo.Task?.SetResult();
                timers.Remove(timerInfo.Id);
            }
            else if (timerInfo.Type == TimerType.Repeated)
            {
                timerInfo.Time = currentTime + timerInfo.Interval;
                timerQueue.Enqueue(timerInfo, timerInfo.Time);
                
                // 触发定时器事件
                if (timerInfo.Callback != null)
                {
                    timerInfo.Callback();
                }
            }
        }
    }
}

// 定时器信息
public class TimerInfo
{
    public long Id { get; set; }
    public long Time { get; set; }
    public long Interval { get; set; }
    public TimerType Type { get; set; }
    public ETTaskCompletionSource Task { get; set; }
    public Action Callback { get; set; }
    public bool Removed { get; set; }
}

// 定时器类型
public enum TimerType
{
    Once,        # 一次性定时器
    Repeated     # 循环定时器
}
```

## TimerTicker

### TimerTicker

```csharp
// 定时器触发器
public class TimerTicker : MonoBehaviour
{
    // 固定更新
    private void FixedUpdate()
    {
        TimerCore.Instance.Update();
    }
}
```

## 定时器使用

### 一次性定时器

```csharp
// 等待指定时间
TimerComponent timer = scene.GetComponent<TimerComponent>();
await timer.WaitAsync(1000);  # 等待1000毫秒

Log.Debug("1 second passed");
```

### 循环定时器

```csharp
// 循环执行
TimerComponent timer = scene.GetComponent<TimerComponent>();

# 启动循环定时器
_ = TimerRepeated(timer, 1000);

async ETTask TimerRepeated(TimerComponent timer, long time)
{
    while (true)
    {
        await timer.WaitAsync(time);
        Log.Debug("Repeated timer triggered");
    }
}
```

### 延迟任务

```csharp
// 延迟执行任务
TimerComponent timer = scene.GetComponent<TimerComponent>();

# 延迟3秒后执行
await timer.WaitAsync(3000);
DoSomething();
```

### 取消定时器

```csharp
// 取消定时器
TimerComponent timer = scene.GetComponent<TimerComponent>();
long timerId = await timer.WaitAsync(5000);

# 取消定时器
timer.Remove(timerId);
```

## 高级定时器

### 倒计时定时器

```csharp
// 倒计时定时器
public class CountdownTimer : ATimer
{
    // 倒计时时间
    private long remainingTime;
    
    // 回调
    private Action<long> onTick;
    private Action onComplete;
    
    // 初始化
    public void Init(long totalTime, Action<long> tick, Action complete)
    {
        remainingTime = totalTime;
        onTick = tick;
        onComplete = complete;
    }
    
    // 定时器回调
    public override void Run()
    {
        remainingTime -= 100;  # 每100ms触发一次
        
        if (remainingTime <= 0)
        {
            onComplete?.Invoke();
            this.Dispose();
        }
        else
        {
            onTick?.Invoke(remainingTime);
        }
    }
}

// 使用倒计时定时器
CountdownTimer timer = EntityFactory.Create<CountdownTimer>(scene, true);
timer.Init(10000,  # 10秒倒计时
    time => Log.Debug($"Remaining: {time}ms"),
    () => Log.Debug("Countdown complete"));
```

### 间隔定时器

```csharp
// 间隔定时器
public class IntervalTimer : ATimer
{
    // 间隔次数
    private int intervalCount;
    private int currentCount;
    
    // 回调
    private Action<int> onInterval;
    private Action onComplete;
    
    // 初始化
    public void Init(int count, Action<int> interval, Action complete)
    {
        intervalCount = count;
        currentCount = 0;
        onInterval = interval;
        onComplete = complete;
    }
    
    // 定时器回调
    public override void Run()
    {
        currentCount++;
        
        if (currentCount >= intervalCount)
        {
            onComplete?.Invoke();
            this.Dispose();
        }
        else
        {
            onInterval?.Invoke(currentCount);
        }
    }
}

// 使用间隔定时器
IntervalTimer timer = EntityFactory.Create<IntervalTimer>(scene, true);
timer.Init(5,  # 5次间隔
    count => Log.Debug($"Interval: {count}"),
    () => Log.Debug("All intervals complete"));
```

## 定时器优化

### 定时器池

```csharp
// 定时器对象池
public class TimerPool : ObjectPool<ATimer>
{
    private readonly Scene scene;
    private readonly Type timerType;
    
    public TimerPool(Scene scene, Type timerType, int capacity) : base(capacity)
    {
        this.scene = scene;
        this.timerType = timerType;
    }
    
    protected override ATimer CreateObject()
    {
        return (ATimer)EntityFactory.Create(timerType, scene, false);
    }
    
    protected override void ResetObject(ATimer obj)
    {
        // 重置定时器状态
    }
}
```

### 批量定时器

```csharp
// 批量定时器
public class BatchTimer : ATimer
{
    // 定时器列表
    private readonly List<Action> callbacks = new List<Action>();
    
    // 添加回调
    public void AddCallback(Action callback)
    {
        callbacks.Add(callback);
    }
    
    // 定时器回调
    public override void Run()
    {
        foreach (Action callback in callbacks)
        {
            callback?.Invoke();
        }
    }
}
```

## 最佳实践

### 1. 定时器设计
- 合理设置定时器间隔
- 及时取消不需要的定时器
- 使用对象池优化性能
- 避免定时器泄漏

### 2. 性能优化
- 使用定时器池
- 批量处理定时器
- 减少定时器数量
- 使用高效数据结构

### 3. 定时器管理
- 记录定时器信息
- 监控定时器性能
- 定时器超时处理
- 定时器错误处理

### 4. 调试工具
- 定时器可视化
- 定时器统计
- 定时器追踪
- 定时器分析

## 常见问题

### Q: 如何处理定时器精度问题?
A: 
1. 使用固定更新
2. 调整定时器间隔
3. 使用系统时间
4. 补偿时间偏差

### Q: 如何避免定时器泄漏?
A: 
1. 及时取消定时器
2. 使用对象池
3. 监控定时器数量
4. 定期清理

### Q: 如何优化定时器性能?
A: 
1. 使用对象池
2. 批量处理
3. 减少定时器数量
4. 使用高效数据结构

## 相关文档

- [ECS架构](ECS架构.md)
- [Fiber模块](Fiber模块.md)
- [项目概述](项目概述.md)
- [服务端模块](服务端模块.md)
