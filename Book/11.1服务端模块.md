# 服务端模块

## 概述

ET框架服务端采用分布式架构，支持多进程部署和水平扩展。服务端模块包括Gate、Map、Match、Room等核心服务器，每个服务器负责特定的游戏逻辑。

## 服务器架构

### 服务器类型

```csharp
public enum SceneType
{
    Realm,          # 登录服务器
    Gate,           # 网关服务器
    Map,            # 地图服务器
    Location,       # 位置服务器
    Match,          # 匹配服务器
    Room,           # 房间服务器
    Robot,          # 机器人服务器
    Benchmark       # 压测服务器
}
```

### 服务器部署

```
进程1: Realm (登录服务器)
进程2: Gate (网关服务器)
进程3-N: Map (地图服务器集群)
进程N+1: Match (匹配服务器)
进程N+2: Location (位置服务器)
```

## Realm服务器

### 功能
- 处理用户登录认证
- 验证账号密码
- 分配Gate服务器
- 管理玩家会话

### 核心组件

```csharp
// Realm服务器初始化
[Event(SceneType.Realm)]
public class RealmEvent : AEvent<Scene, EventType.RealmInit>
{
    protected override async ETTask Run(Scene scene, EventType.RealmInit args)
    {
        // 初始化Realm服务器
        scene.AddComponent<RealmGateAddressComponent>();
        scene.AddComponent<RealmTokenKeyComponent>();
    }
}
```

### 登录流程

```csharp
// 1. 客户端请求登录
C2R_Login loginRequest = C2R_Login.Create();
loginRequest.Account = "account";
loginRequest.Password = "password";

// 2. Realm验证账号
var response = await session.Call<R2C_Login>(loginRequest);

// 3. Realm分配Gate服务器
string gateAddress = response.Address;
long gateId = response.GateId;

// 4. 客户端连接到Gate服务器
await ConnectToGate(gateAddress, gateId);
```

## Gate服务器

### 功能
- 作为客户端和游戏服务器的网关
- 管理玩家连接
- 消息转发和路由
- 玩家状态管理

### 核心组件

```csharp
// Gate服务器核心组件
public class GateSessionKeyComponent : Entity, IAwake
{
    // 会话密钥管理
    public Dictionary<long, string> SessionKeys = new();
}

public class GatePlayerComponent : Entity, IAwake
{
    // 玩家管理
    public Dictionary<long, Player> Players = new();
}
```

### 玩家连接管理

```csharp
// 玩家连接到Gate
[MessageHandler(SceneType.Gate)]
public class C2G_LoginGateHandler : MessageHandler<Scene, C2G_LoginGate, G2C_LoginGate>
{
    protected override async ETTask Run(Scene scene, C2G_LoginGate request, G2C_LoginGate response)
    {
        // 1. 验证Token
        string key = scene.GetComponent<GateSessionKeyComponent>().Get(request.Account);
        
        // 2. 创建玩家
        Player player = EntityFactory.Create<Player>(scene, true);
        
        // 3. 添加组件
        player.AddComponent<PlayerSessionComponent>().Session = session;
        
        // 4. 保存玩家
        scene.GetComponent<GatePlayerComponent>().Add(player);
        
        // 5. 返回玩家ID
        response.PlayerId = player.Id;
    }
}
```

### 消息转发

```csharp
// Gate消息转发
public class GateMessageDispatcher : Entity
{
    public async ETTask Dispatch(Session session, IMessage message)
    {
        // 获取目标服务器
        ActorId targetActorId = GetTargetActorId(message);
        
        // 转发消息
        await ActorMessageSenderComponent.Instance.Call(targetActorId, message);
    }
}
```

## Map服务器

### 功能
- 管理游戏地图
- 处理玩家移动和交互
- 管理NPC和怪物
- 处理战斗逻辑

### 核心组件

```csharp
// 地图组件
public class MapComponent : Entity, IAwake
{
    // 地图信息
    public string MapName;
    public int MapId;
    
    // 场景管理
    public Scene Scene;
    
    // 单位管理
    public UnitComponent UnitComponent;
}

// 单位组件
public class UnitComponent : Entity, IAwake
{
    // 单位列表
    public Dictionary<long, Unit> Units = new();
    
    // 添加单位
    public Unit Add(UnitType type, long id);
    
    // 获取单位
    public Unit Get(long id);
    
    // 移除单位
    public void Remove(long id);
}
```

### 单位管理

```csharp
// 创建单位
public static Unit Create(UnitComponent self, UnitType type, long id)
{
    Unit unit = EntityFactory.Create<Unit>(self.Scene(), true);
    unit.Id = id;
    unit.AddComponent<MoveComponent>();
    unit.AddComponent<NumericComponent>();
    
    self.Add(unit);
    return unit;
}

// 单位移动
[MessageHandler(SceneType.Map)]
public class C2M_PathfindingResultHandler : MessageHandler<Scene, C2M_PathfindingResult>
{
    protected override async ETTask Run(Scene scene, C2M_PathfindingResult message)
    {
        // 获取单位
        Unit unit = scene.GetComponent<UnitComponent>().Get(message.UnitId);
        
        // 移动单位
        unit.GetComponent<MoveComponent>().MoveTo(message.Points);
    }
}
```

### AOI (Area of Interest)

```csharp
// AOI组件
public class AOIEntity : Entity, IAwake
{
    // 位置
    public Vector3 Position;
    
    // 观察者列表
    public HashSet<long> Watchers = new();
    
    // 被观察者列表
    public HashSet<long> Watched = new();
}

// AOI管理器
public class AOIComponent : Entity, IAwake
{
    // AOI实体列表
    public Dictionary<long, AOIEntity> Entities = new();
    
    // 添加实体
    public void Add(AOIEntity entity);
    
    // 移除实体
    public void Remove(long id);
    
    // 获取附近实体
    public List<AOIEntity> GetNearbyEntities(AOIEntity entity, float radius);
}
```

## Match服务器

### 功能
- 玩家匹配
- 队伍管理
- 房间分配
- 匹配算法

### 核心组件

```csharp
// 匹配组件
public class MatchComponent : Entity, IAwake
{
    // 匹配队列
    public Queue<MatchPlayer> MatchQueue = new();
    
    // 队伍管理
    public Dictionary<long, MatchTeam> Teams = new();
    
    // 房间管理
    public Dictionary<long, long> RoomMap = new();
}

// 匹配玩家
public class MatchPlayer : Entity
{
    public long PlayerId;
    public int Rank;
    public long TeamId;
}

// 匹配队伍
public class MatchTeam : Entity
{
    public long TeamId;
    public List<MatchPlayer> Players = new();
    public int TeamRank;
}
```

### 匹配流程

```csharp
// 玩家请求匹配
[MessageHandler(SceneType.Match)]
public class C2M_MatchHandler : MessageHandler<Scene, C2M_Match, M2C_Match>
{
    protected override async ETTask Run(Scene scene, C2M_Match request, M2C_Match response)
    {
        // 1. 创建匹配玩家
        MatchPlayer player = EntityFactory.Create<MatchPlayer>(scene, true);
        player.PlayerId = request.PlayerId;
        player.Rank = request.Rank;
        
        // 2. 加入匹配队列
        scene.GetComponent<MatchComponent>().AddToQueue(player);
        
        // 3. 开始匹配
        await scene.GetComponent<MatchComponent>().MatchAsync();
    }
}

// 匹配逻辑
public static async ETTask MatchAsync(this MatchComponent self)
{
    // 1. 从队列获取玩家
    while (self.MatchQueue.Count >= 2)
    {
        // 2. 匹配两个玩家
        MatchPlayer player1 = self.MatchQueue.Dequeue();
        MatchPlayer player2 = self.MatchQueue.Dequeue();
        
        // 3. 创建房间
        long roomId = await CreateRoomAsync(player1, player2);
        
        // 4. 通知玩家
        await NotifyMatchSuccess(player1, roomId);
        await NotifyMatchSuccess(player2, roomId);
    }
}
```

## Room服务器

### 功能
- 房间管理
- 房间逻辑
- 房间同步
- 房间销毁

### 核心组件

```csharp
// 房间组件
public class RoomComponent : Entity, IAwake
{
    // 房间列表
    public Dictionary<long, Room> Rooms = new();
    
    // 创建房间
    public Room Create(long roomId);
    
    // 获取房间
    public Room Get(long roomId);
    
    // 移除房间
    public void Remove(long roomId);
}

// 房间实体
public class Room : Entity, IAwake
{
    // 房间ID
    public long RoomId;
    
    // 房间类型
    public RoomType Type;
    
    // 玩家列表
    public List<long> PlayerIds = new();
    
    // 房间状态
    public RoomState State;
    
    // 房间配置
    public RoomConfig Config;
}
```

### 房间管理

```csharp
// 创建房间
public static Room Create(this RoomComponent self, long roomId)
{
    Room room = EntityFactory.Create<Room>(self.Scene(), true);
    room.RoomId = roomId;
    room.State = RoomState.Waiting;
    
    self.Rooms.Add(roomId, room);
    return room;
}

// 玩家加入房间
[MessageHandler(SceneType.Room)]
public class C2M_JoinRoomHandler : MessageHandler<Scene, C2M_JoinRoom, M2C_JoinRoom>
{
    protected override async ETTask Run(Scene scene, C2M_JoinRoom request, M2C_JoinRoom response)
    {
        // 1. 获取房间
        Room room = scene.GetComponent<RoomComponent>().Get(request.RoomId);
        
        // 2. 检查房间状态
        if (room.State != RoomState.Waiting)
        {
            response.Error = ErrorCode.ERR_RoomNotAvailable;
            return;
        }
        
        // 3. 加入房间
        room.PlayerIds.Add(request.PlayerId);
        
        // 4. 通知其他玩家
        await NotifyPlayerJoin(room, request.PlayerId);
    }
}
```

## Location服务器

### 功能
- Actor位置管理
- 查找Actor所在的Fiber
- Actor迁移支持

### 核心组件

```csharp
// Location组件
public class LocationComponent : Entity, IAwake
{
    // Actor位置映射
    public Dictionary<long, ActorId> ActorLocations = new();
    
    // 添加Actor位置
    public void Add(long entityId, ActorId actorId);
    
    // 获取Actor位置
    public ActorId Get(long entityId);
    
    // 移除Actor位置
    public void Remove(long entityId);
}
```

## 数据库管理

### DBComponent

```csharp
// 数据库组件
public class DBComponent : Entity, IAwake
{
    // 数据库连接
    private MongoClient mongoClient;
    private IMongoDatabase database;
    
    // 保存数据
    public async ETTask Save(Entity entity);
    
    // 查询数据
    public async ETTask<T> Query<T>(long id);
    
    // 删除数据
    public async ETTask Delete<T>(long id);
}
```

## 最佳实践

### 1. 服务器分离
- 按功能分离服务器
- 支持水平扩展
- 降低单点故障

### 2. 消息设计
- 统一消息格式
- 明确消息流向
- 错误处理完善

### 3. 状态管理
- 避免共享状态
- 通过消息传递
- 使用数据库持久化

### 4. 性能优化
- 使用对象池
- 异步处理
- 负载均衡

## 常见问题

### Q: 如何扩展服务器数量?
A: 
1. 修改配置文件
2. 启动新服务器进程
3. 更新服务器列表
4. 负载均衡器会自动分配

### Q: 如何处理服务器崩溃?
A: 
1. 使用看门狗监控
2. 自动重启服务
3. 从数据库恢复状态
4. 通知玩家重连

### Q: 如何优化服务器性能?
A: 
1. 使用对象池
2. 异步处理
3. 减少网络消息
4. 优化数据库查询

## 相关文档

- [ECS架构](ECS架构.md)
- [Fiber模块](Fiber模块.md)
- [网络通信模块](网络通信模块.md)
- [客户端模块](客户端模块.md)
